// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               unknown
// source: flux/strategy/v1beta1/strategy.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { FISQueryRequest } from "../../astromesh/v1beta1/query";
import { FISInstruction } from "../../astromesh/v1beta1/tx";

export enum StrategyType {
  GENERIC = 0,
  INTENT_SOLVER = 1,
  UNRECOGNIZED = -1,
}

export function strategyTypeFromJSON(object: any): StrategyType {
  switch (object) {
    case 0:
    case "GENERIC":
      return StrategyType.GENERIC;
    case 1:
    case "INTENT_SOLVER":
      return StrategyType.INTENT_SOLVER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StrategyType.UNRECOGNIZED;
  }
}

export function strategyTypeToJSON(object: StrategyType): string {
  switch (object) {
    case StrategyType.GENERIC:
      return "GENERIC";
    case StrategyType.INTENT_SOLVER:
      return "INTENT_SOLVER";
    case StrategyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AccessType {
  anyone = 0,
  only_addresses = 1,
  UNRECOGNIZED = -1,
}

export function accessTypeFromJSON(object: any): AccessType {
  switch (object) {
    case 0:
    case "anyone":
      return AccessType.anyone;
    case 1:
    case "only_addresses":
      return AccessType.only_addresses;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessType.UNRECOGNIZED;
  }
}

export function accessTypeToJSON(object: AccessType): string {
  switch (object) {
    case AccessType.anyone:
      return "anyone";
    case AccessType.only_addresses:
      return "only_addresses";
    case AccessType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PermissionConfig {
  type: AccessType;
  addresses: string[];
}

export interface Strategy {
  id: Uint8Array;
  code_checksum: Uint8Array;
  owner: string;
  query:
    | FISQueryRequest
    | undefined;
  /**
   * query hash stores hash(query), so that msg server don't need to calculate
   * all the time
   */
  query_hash: Uint8Array;
  is_enabled: boolean;
  trigger_permission: PermissionConfig | undefined;
  metadata: StrategyMetadata | undefined;
}

/**
 * schema for intent's query that allows arbitrary input from user
 * FE should be able to translate to a real FISQuery
 */
export interface SchemaFISInstruction {
  plane: string;
  action: string;
  address: Uint8Array;
  input: Uint8Array[];
}

export interface SchemaFISQuery {
  instructions: SchemaFISInstruction[];
}

export interface SchemaPrompt {
  template: string;
  query: SchemaFISQuery | undefined;
  extensions: { [key: string]: string };
}

export interface SchemaPrompt_ExtensionsEntry {
  key: string;
  value: string;
}

export interface SchemaGroup {
  name: string;
  prompts: { [key: string]: SchemaPrompt };
}

export interface SchemaGroup_PromptsEntry {
  key: string;
  value: SchemaPrompt | undefined;
}

export interface Schema {
  groups: SchemaGroup[];
}

export interface StrategyMetadata {
  /** Strategy name */
  name: string;
  /** Description, meaningful for strategy/intent's usage */
  description: string;
  /** URL of the logo, owner should host their own logo file */
  logo: string;
  /** Strategy website for user references or documentations */
  website: string;
  /** Strategy type */
  type: StrategyType;
  /** Meaningful tags for searching, categorizing */
  tags: string[];
  /** Strategy schema, usually used for intent's instructions display on FE */
  schema: string;
}

export interface StrategyInput {
  msg: Uint8Array;
  fis_input: FISInput[];
}

export interface FISInput {
  data: Uint8Array[];
}

export interface StrategyOutput {
  instructions: FISInstruction[];
}

function createBasePermissionConfig(): PermissionConfig {
  return { type: 0, addresses: [] };
}

export const PermissionConfig = {
  $type: "flux.strategy.v1beta1.PermissionConfig" as const,

  encode(message: PermissionConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.addresses) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PermissionConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionConfig {
    return {
      type: isSet(object.type) ? accessTypeFromJSON(object.type) : 0,
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PermissionConfig): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = accessTypeToJSON(message.type);
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses;
    }
    return obj;
  },

  create(base?: DeepPartial<PermissionConfig>): PermissionConfig {
    return PermissionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PermissionConfig>): PermissionConfig {
    const message = createBasePermissionConfig();
    message.type = object.type ?? 0;
    message.addresses = object.addresses?.map((e) => e) || [];
    return message;
  },
};

function createBaseStrategy(): Strategy {
  return {
    id: new Uint8Array(0),
    code_checksum: new Uint8Array(0),
    owner: "",
    query: undefined,
    query_hash: new Uint8Array(0),
    is_enabled: false,
    trigger_permission: undefined,
    metadata: undefined,
  };
}

export const Strategy = {
  $type: "flux.strategy.v1beta1.Strategy" as const,

  encode(message: Strategy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.code_checksum.length !== 0) {
      writer.uint32(18).bytes(message.code_checksum);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.query !== undefined) {
      FISQueryRequest.encode(message.query, writer.uint32(34).fork()).ldelim();
    }
    if (message.query_hash.length !== 0) {
      writer.uint32(42).bytes(message.query_hash);
    }
    if (message.is_enabled !== false) {
      writer.uint32(48).bool(message.is_enabled);
    }
    if (message.trigger_permission !== undefined) {
      PermissionConfig.encode(message.trigger_permission, writer.uint32(58).fork()).ldelim();
    }
    if (message.metadata !== undefined) {
      StrategyMetadata.encode(message.metadata, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Strategy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.code_checksum = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.query = FISQueryRequest.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.query_hash = reader.bytes();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.is_enabled = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.trigger_permission = PermissionConfig.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.metadata = StrategyMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Strategy {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      code_checksum: isSet(object.code_checksum) ? bytesFromBase64(object.code_checksum) : new Uint8Array(0),
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      query: isSet(object.query) ? FISQueryRequest.fromJSON(object.query) : undefined,
      query_hash: isSet(object.query_hash) ? bytesFromBase64(object.query_hash) : new Uint8Array(0),
      is_enabled: isSet(object.is_enabled) ? globalThis.Boolean(object.is_enabled) : false,
      trigger_permission: isSet(object.trigger_permission)
        ? PermissionConfig.fromJSON(object.trigger_permission)
        : undefined,
      metadata: isSet(object.metadata) ? StrategyMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: Strategy): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.code_checksum !== undefined) {
      obj.code_checksum = base64FromBytes(message.code_checksum);
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.query !== undefined) {
      obj.query = FISQueryRequest.toJSON(message.query);
    }
    if (message.query_hash !== undefined) {
      obj.query_hash = base64FromBytes(message.query_hash);
    }
    if (message.is_enabled !== undefined) {
      obj.is_enabled = message.is_enabled;
    }
    if (message.trigger_permission !== undefined) {
      obj.trigger_permission = PermissionConfig.toJSON(message.trigger_permission);
    }
    if (message.metadata !== undefined) {
      obj.metadata = StrategyMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create(base?: DeepPartial<Strategy>): Strategy {
    return Strategy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Strategy>): Strategy {
    const message = createBaseStrategy();
    message.id = object.id ?? new Uint8Array(0);
    message.code_checksum = object.code_checksum ?? new Uint8Array(0);
    message.owner = object.owner ?? "";
    message.query = (object.query !== undefined && object.query !== null)
      ? FISQueryRequest.fromPartial(object.query)
      : undefined;
    message.query_hash = object.query_hash ?? new Uint8Array(0);
    message.is_enabled = object.is_enabled ?? false;
    message.trigger_permission = (object.trigger_permission !== undefined && object.trigger_permission !== null)
      ? PermissionConfig.fromPartial(object.trigger_permission)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? StrategyMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseSchemaFISInstruction(): SchemaFISInstruction {
  return { plane: "", action: "", address: new Uint8Array(0), input: [] };
}

export const SchemaFISInstruction = {
  $type: "flux.strategy.v1beta1.SchemaFISInstruction" as const,

  encode(message: SchemaFISInstruction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.plane !== "") {
      writer.uint32(10).string(message.plane);
    }
    if (message.action !== "") {
      writer.uint32(18).string(message.action);
    }
    if (message.address.length !== 0) {
      writer.uint32(26).bytes(message.address);
    }
    for (const v of message.input) {
      writer.uint32(34).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SchemaFISInstruction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemaFISInstruction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.plane = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.action = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.address = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.input.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchemaFISInstruction {
    return {
      plane: isSet(object.plane) ? globalThis.String(object.plane) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0),
      input: globalThis.Array.isArray(object?.input) ? object.input.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: SchemaFISInstruction): unknown {
    const obj: any = {};
    if (message.plane !== undefined) {
      obj.plane = message.plane;
    }
    if (message.action !== undefined) {
      obj.action = message.action;
    }
    if (message.address !== undefined) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.input?.length) {
      obj.input = message.input.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SchemaFISInstruction>): SchemaFISInstruction {
    return SchemaFISInstruction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchemaFISInstruction>): SchemaFISInstruction {
    const message = createBaseSchemaFISInstruction();
    message.plane = object.plane ?? "";
    message.action = object.action ?? "";
    message.address = object.address ?? new Uint8Array(0);
    message.input = object.input?.map((e) => e) || [];
    return message;
  },
};

function createBaseSchemaFISQuery(): SchemaFISQuery {
  return { instructions: [] };
}

export const SchemaFISQuery = {
  $type: "flux.strategy.v1beta1.SchemaFISQuery" as const,

  encode(message: SchemaFISQuery, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.instructions) {
      SchemaFISInstruction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SchemaFISQuery {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemaFISQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instructions.push(SchemaFISInstruction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchemaFISQuery {
    return {
      instructions: globalThis.Array.isArray(object?.instructions)
        ? object.instructions.map((e: any) => SchemaFISInstruction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SchemaFISQuery): unknown {
    const obj: any = {};
    if (message.instructions?.length) {
      obj.instructions = message.instructions.map((e) => SchemaFISInstruction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SchemaFISQuery>): SchemaFISQuery {
    return SchemaFISQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchemaFISQuery>): SchemaFISQuery {
    const message = createBaseSchemaFISQuery();
    message.instructions = object.instructions?.map((e) => SchemaFISInstruction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSchemaPrompt(): SchemaPrompt {
  return { template: "", query: undefined, extensions: {} };
}

export const SchemaPrompt = {
  $type: "flux.strategy.v1beta1.SchemaPrompt" as const,

  encode(message: SchemaPrompt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.template !== "") {
      writer.uint32(10).string(message.template);
    }
    if (message.query !== undefined) {
      SchemaFISQuery.encode(message.query, writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.extensions).forEach(([key, value]) => {
      SchemaPrompt_ExtensionsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SchemaPrompt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemaPrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.template = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = SchemaFISQuery.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = SchemaPrompt_ExtensionsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.extensions[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchemaPrompt {
    return {
      template: isSet(object.template) ? globalThis.String(object.template) : "",
      query: isSet(object.query) ? SchemaFISQuery.fromJSON(object.query) : undefined,
      extensions: isObject(object.extensions)
        ? Object.entries(object.extensions).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SchemaPrompt): unknown {
    const obj: any = {};
    if (message.template !== undefined) {
      obj.template = message.template;
    }
    if (message.query !== undefined) {
      obj.query = SchemaFISQuery.toJSON(message.query);
    }
    if (message.extensions) {
      const entries = Object.entries(message.extensions);
      if (entries.length > 0) {
        obj.extensions = {};
        entries.forEach(([k, v]) => {
          obj.extensions[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SchemaPrompt>): SchemaPrompt {
    return SchemaPrompt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchemaPrompt>): SchemaPrompt {
    const message = createBaseSchemaPrompt();
    message.template = object.template ?? "";
    message.query = (object.query !== undefined && object.query !== null)
      ? SchemaFISQuery.fromPartial(object.query)
      : undefined;
    message.extensions = Object.entries(object.extensions ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSchemaPrompt_ExtensionsEntry(): SchemaPrompt_ExtensionsEntry {
  return { key: "", value: "" };
}

export const SchemaPrompt_ExtensionsEntry = {
  $type: "flux.strategy.v1beta1.SchemaPrompt.ExtensionsEntry" as const,

  encode(message: SchemaPrompt_ExtensionsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SchemaPrompt_ExtensionsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemaPrompt_ExtensionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchemaPrompt_ExtensionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SchemaPrompt_ExtensionsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SchemaPrompt_ExtensionsEntry>): SchemaPrompt_ExtensionsEntry {
    return SchemaPrompt_ExtensionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchemaPrompt_ExtensionsEntry>): SchemaPrompt_ExtensionsEntry {
    const message = createBaseSchemaPrompt_ExtensionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSchemaGroup(): SchemaGroup {
  return { name: "", prompts: {} };
}

export const SchemaGroup = {
  $type: "flux.strategy.v1beta1.SchemaGroup" as const,

  encode(message: SchemaGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.prompts).forEach(([key, value]) => {
      SchemaGroup_PromptsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SchemaGroup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemaGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = SchemaGroup_PromptsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.prompts[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchemaGroup {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      prompts: isObject(object.prompts)
        ? Object.entries(object.prompts).reduce<{ [key: string]: SchemaPrompt }>((acc, [key, value]) => {
          acc[key] = SchemaPrompt.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SchemaGroup): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.prompts) {
      const entries = Object.entries(message.prompts);
      if (entries.length > 0) {
        obj.prompts = {};
        entries.forEach(([k, v]) => {
          obj.prompts[k] = SchemaPrompt.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SchemaGroup>): SchemaGroup {
    return SchemaGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchemaGroup>): SchemaGroup {
    const message = createBaseSchemaGroup();
    message.name = object.name ?? "";
    message.prompts = Object.entries(object.prompts ?? {}).reduce<{ [key: string]: SchemaPrompt }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = SchemaPrompt.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSchemaGroup_PromptsEntry(): SchemaGroup_PromptsEntry {
  return { key: "", value: undefined };
}

export const SchemaGroup_PromptsEntry = {
  $type: "flux.strategy.v1beta1.SchemaGroup.PromptsEntry" as const,

  encode(message: SchemaGroup_PromptsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SchemaPrompt.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SchemaGroup_PromptsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemaGroup_PromptsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = SchemaPrompt.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchemaGroup_PromptsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SchemaPrompt.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SchemaGroup_PromptsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SchemaPrompt.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SchemaGroup_PromptsEntry>): SchemaGroup_PromptsEntry {
    return SchemaGroup_PromptsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchemaGroup_PromptsEntry>): SchemaGroup_PromptsEntry {
    const message = createBaseSchemaGroup_PromptsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SchemaPrompt.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSchema(): Schema {
  return { groups: [] };
}

export const Schema = {
  $type: "flux.strategy.v1beta1.Schema" as const,

  encode(message: Schema, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.groups) {
      SchemaGroup.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Schema {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.groups.push(SchemaGroup.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schema {
    return {
      groups: globalThis.Array.isArray(object?.groups) ? object.groups.map((e: any) => SchemaGroup.fromJSON(e)) : [],
    };
  },

  toJSON(message: Schema): unknown {
    const obj: any = {};
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => SchemaGroup.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Schema>): Schema {
    return Schema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Schema>): Schema {
    const message = createBaseSchema();
    message.groups = object.groups?.map((e) => SchemaGroup.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStrategyMetadata(): StrategyMetadata {
  return { name: "", description: "", logo: "", website: "", type: 0, tags: [], schema: "" };
}

export const StrategyMetadata = {
  $type: "flux.strategy.v1beta1.StrategyMetadata" as const,

  encode(message: StrategyMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.logo !== "") {
      writer.uint32(26).string(message.logo);
    }
    if (message.website !== "") {
      writer.uint32(34).string(message.website);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    for (const v of message.tags) {
      writer.uint32(50).string(v!);
    }
    if (message.schema !== "") {
      writer.uint32(58).string(message.schema);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StrategyMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrategyMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.logo = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.website = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.schema = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StrategyMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
      website: isSet(object.website) ? globalThis.String(object.website) : "",
      type: isSet(object.type) ? strategyTypeFromJSON(object.type) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
    };
  },

  toJSON(message: StrategyMetadata): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.logo !== undefined) {
      obj.logo = message.logo;
    }
    if (message.website !== undefined) {
      obj.website = message.website;
    }
    if (message.type !== undefined) {
      obj.type = strategyTypeToJSON(message.type);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.schema !== undefined) {
      obj.schema = message.schema;
    }
    return obj;
  },

  create(base?: DeepPartial<StrategyMetadata>): StrategyMetadata {
    return StrategyMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StrategyMetadata>): StrategyMetadata {
    const message = createBaseStrategyMetadata();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.logo = object.logo ?? "";
    message.website = object.website ?? "";
    message.type = object.type ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.schema = object.schema ?? "";
    return message;
  },
};

function createBaseStrategyInput(): StrategyInput {
  return { msg: new Uint8Array(0), fis_input: [] };
}

export const StrategyInput = {
  $type: "flux.strategy.v1beta1.StrategyInput" as const,

  encode(message: StrategyInput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.msg.length !== 0) {
      writer.uint32(10).bytes(message.msg);
    }
    for (const v of message.fis_input) {
      FISInput.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StrategyInput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrategyInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.msg = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fis_input.push(FISInput.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StrategyInput {
    return {
      msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(0),
      fis_input: globalThis.Array.isArray(object?.fis_input)
        ? object.fis_input.map((e: any) => FISInput.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StrategyInput): unknown {
    const obj: any = {};
    if (message.msg !== undefined) {
      obj.msg = base64FromBytes(message.msg);
    }
    if (message.fis_input?.length) {
      obj.fis_input = message.fis_input.map((e) => FISInput.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StrategyInput>): StrategyInput {
    return StrategyInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StrategyInput>): StrategyInput {
    const message = createBaseStrategyInput();
    message.msg = object.msg ?? new Uint8Array(0);
    message.fis_input = object.fis_input?.map((e) => FISInput.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFISInput(): FISInput {
  return { data: [] };
}

export const FISInput = {
  $type: "flux.strategy.v1beta1.FISInput" as const,

  encode(message: FISInput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.data) {
      writer.uint32(26).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FISInput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFISInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FISInput {
    return { data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => bytesFromBase64(e)) : [] };
  },

  toJSON(message: FISInput): unknown {
    const obj: any = {};
    if (message.data?.length) {
      obj.data = message.data.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FISInput>): FISInput {
    return FISInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FISInput>): FISInput {
    const message = createBaseFISInput();
    message.data = object.data?.map((e) => e) || [];
    return message;
  },
};

function createBaseStrategyOutput(): StrategyOutput {
  return { instructions: [] };
}

export const StrategyOutput = {
  $type: "flux.strategy.v1beta1.StrategyOutput" as const,

  encode(message: StrategyOutput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.instructions) {
      FISInstruction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StrategyOutput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrategyOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instructions.push(FISInstruction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StrategyOutput {
    return {
      instructions: globalThis.Array.isArray(object?.instructions)
        ? object.instructions.map((e: any) => FISInstruction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StrategyOutput): unknown {
    const obj: any = {};
    if (message.instructions?.length) {
      obj.instructions = message.instructions.map((e) => FISInstruction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StrategyOutput>): StrategyOutput {
    return StrategyOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StrategyOutput>): StrategyOutput {
    const message = createBaseStrategyOutput();
    message.instructions = object.instructions?.map((e) => FISInstruction.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
