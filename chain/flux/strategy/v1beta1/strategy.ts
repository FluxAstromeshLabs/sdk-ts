// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               unknown
// source: flux/strategy/v1beta1/strategy.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { FISQueryRequest } from "../../astromesh/v1beta1/query";
import { FISInstruction } from "../../astromesh/v1beta1/tx";

export enum StrategyType {
  GENERIC = 0,
  INTENT_SOLVER = 1,
  UNRECOGNIZED = -1,
}

export function strategyTypeFromJSON(object: any): StrategyType {
  switch (object) {
    case 0:
    case "GENERIC":
      return StrategyType.GENERIC;
    case 1:
    case "INTENT_SOLVER":
      return StrategyType.INTENT_SOLVER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StrategyType.UNRECOGNIZED;
  }
}

export function strategyTypeToJSON(object: StrategyType): string {
  switch (object) {
    case StrategyType.GENERIC:
      return "GENERIC";
    case StrategyType.INTENT_SOLVER:
      return "INTENT_SOLVER";
    case StrategyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AccessType {
  anyone = 0,
  only_addresses = 1,
  UNRECOGNIZED = -1,
}

export function accessTypeFromJSON(object: any): AccessType {
  switch (object) {
    case 0:
    case "anyone":
      return AccessType.anyone;
    case 1:
    case "only_addresses":
      return AccessType.only_addresses;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessType.UNRECOGNIZED;
  }
}

export function accessTypeToJSON(object: AccessType): string {
  switch (object) {
    case AccessType.anyone:
      return "anyone";
    case AccessType.only_addresses:
      return "only_addresses";
    case AccessType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PermissionConfig {
  type: AccessType;
  addresses: string[];
}

export interface Strategy {
  id: Uint8Array;
  code_checksum: Uint8Array;
  owner: string;
  query:
    | FISQueryRequest
    | undefined;
  /** query hash stores hash(query), so that msg server don't need to calculate all the time */
  query_hash: Uint8Array;
  type: StrategyType;
  description: string;
  is_enabled: boolean;
  trigger_permission: PermissionConfig | undefined;
}

export interface StrategyInput {
  msg: Uint8Array;
  fis_input: FISInput[];
}

export interface FISInput {
  data: Uint8Array[];
}

export interface StrategyOutput {
  instructions: FISInstruction[];
}

function createBasePermissionConfig(): PermissionConfig {
  return { type: 0, addresses: [] };
}

export const PermissionConfig = {
  $type: "flux.strategy.v1beta1.PermissionConfig" as const,

  encode(message: PermissionConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.addresses) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PermissionConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionConfig {
    return {
      type: isSet(object.type) ? accessTypeFromJSON(object.type) : 0,
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PermissionConfig): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = accessTypeToJSON(message.type);
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses;
    }
    return obj;
  },

  create(base?: DeepPartial<PermissionConfig>): PermissionConfig {
    return PermissionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PermissionConfig>): PermissionConfig {
    const message = createBasePermissionConfig();
    message.type = object.type ?? 0;
    message.addresses = object.addresses?.map((e) => e) || [];
    return message;
  },
};

function createBaseStrategy(): Strategy {
  return {
    id: new Uint8Array(0),
    code_checksum: new Uint8Array(0),
    owner: "",
    query: undefined,
    query_hash: new Uint8Array(0),
    type: 0,
    description: "",
    is_enabled: false,
    trigger_permission: undefined,
  };
}

export const Strategy = {
  $type: "flux.strategy.v1beta1.Strategy" as const,

  encode(message: Strategy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.code_checksum.length !== 0) {
      writer.uint32(18).bytes(message.code_checksum);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.query !== undefined) {
      FISQueryRequest.encode(message.query, writer.uint32(34).fork()).ldelim();
    }
    if (message.query_hash.length !== 0) {
      writer.uint32(42).bytes(message.query_hash);
    }
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    if (message.description !== "") {
      writer.uint32(58).string(message.description);
    }
    if (message.is_enabled !== false) {
      writer.uint32(64).bool(message.is_enabled);
    }
    if (message.trigger_permission !== undefined) {
      PermissionConfig.encode(message.trigger_permission, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Strategy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.code_checksum = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.query = FISQueryRequest.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.query_hash = reader.bytes();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.is_enabled = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.trigger_permission = PermissionConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Strategy {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      code_checksum: isSet(object.code_checksum) ? bytesFromBase64(object.code_checksum) : new Uint8Array(0),
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      query: isSet(object.query) ? FISQueryRequest.fromJSON(object.query) : undefined,
      query_hash: isSet(object.query_hash) ? bytesFromBase64(object.query_hash) : new Uint8Array(0),
      type: isSet(object.type) ? strategyTypeFromJSON(object.type) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      is_enabled: isSet(object.is_enabled) ? globalThis.Boolean(object.is_enabled) : false,
      trigger_permission: isSet(object.trigger_permission)
        ? PermissionConfig.fromJSON(object.trigger_permission)
        : undefined,
    };
  },

  toJSON(message: Strategy): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.code_checksum !== undefined) {
      obj.code_checksum = base64FromBytes(message.code_checksum);
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.query !== undefined) {
      obj.query = FISQueryRequest.toJSON(message.query);
    }
    if (message.query_hash !== undefined) {
      obj.query_hash = base64FromBytes(message.query_hash);
    }
    if (message.type !== undefined) {
      obj.type = strategyTypeToJSON(message.type);
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.is_enabled !== undefined) {
      obj.is_enabled = message.is_enabled;
    }
    if (message.trigger_permission !== undefined) {
      obj.trigger_permission = PermissionConfig.toJSON(message.trigger_permission);
    }
    return obj;
  },

  create(base?: DeepPartial<Strategy>): Strategy {
    return Strategy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Strategy>): Strategy {
    const message = createBaseStrategy();
    message.id = object.id ?? new Uint8Array(0);
    message.code_checksum = object.code_checksum ?? new Uint8Array(0);
    message.owner = object.owner ?? "";
    message.query = (object.query !== undefined && object.query !== null)
      ? FISQueryRequest.fromPartial(object.query)
      : undefined;
    message.query_hash = object.query_hash ?? new Uint8Array(0);
    message.type = object.type ?? 0;
    message.description = object.description ?? "";
    message.is_enabled = object.is_enabled ?? false;
    message.trigger_permission = (object.trigger_permission !== undefined && object.trigger_permission !== null)
      ? PermissionConfig.fromPartial(object.trigger_permission)
      : undefined;
    return message;
  },
};

function createBaseStrategyInput(): StrategyInput {
  return { msg: new Uint8Array(0), fis_input: [] };
}

export const StrategyInput = {
  $type: "flux.strategy.v1beta1.StrategyInput" as const,

  encode(message: StrategyInput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.msg.length !== 0) {
      writer.uint32(10).bytes(message.msg);
    }
    for (const v of message.fis_input) {
      FISInput.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StrategyInput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrategyInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.msg = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fis_input.push(FISInput.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StrategyInput {
    return {
      msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(0),
      fis_input: globalThis.Array.isArray(object?.fis_input)
        ? object.fis_input.map((e: any) => FISInput.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StrategyInput): unknown {
    const obj: any = {};
    if (message.msg !== undefined) {
      obj.msg = base64FromBytes(message.msg);
    }
    if (message.fis_input?.length) {
      obj.fis_input = message.fis_input.map((e) => FISInput.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StrategyInput>): StrategyInput {
    return StrategyInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StrategyInput>): StrategyInput {
    const message = createBaseStrategyInput();
    message.msg = object.msg ?? new Uint8Array(0);
    message.fis_input = object.fis_input?.map((e) => FISInput.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFISInput(): FISInput {
  return { data: [] };
}

export const FISInput = {
  $type: "flux.strategy.v1beta1.FISInput" as const,

  encode(message: FISInput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.data) {
      writer.uint32(26).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FISInput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFISInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FISInput {
    return { data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => bytesFromBase64(e)) : [] };
  },

  toJSON(message: FISInput): unknown {
    const obj: any = {};
    if (message.data?.length) {
      obj.data = message.data.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FISInput>): FISInput {
    return FISInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FISInput>): FISInput {
    const message = createBaseFISInput();
    message.data = object.data?.map((e) => e) || [];
    return message;
  },
};

function createBaseStrategyOutput(): StrategyOutput {
  return { instructions: [] };
}

export const StrategyOutput = {
  $type: "flux.strategy.v1beta1.StrategyOutput" as const,

  encode(message: StrategyOutput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.instructions) {
      FISInstruction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StrategyOutput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrategyOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instructions.push(FISInstruction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StrategyOutput {
    return {
      instructions: globalThis.Array.isArray(object?.instructions)
        ? object.instructions.map((e: any) => FISInstruction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StrategyOutput): unknown {
    const obj: any = {};
    if (message.instructions?.length) {
      obj.instructions = message.instructions.map((e) => FISInstruction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StrategyOutput>): StrategyOutput {
    return StrategyOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StrategyOutput>): StrategyOutput {
    const message = createBaseStrategyOutput();
    message.instructions = object.instructions?.map((e) => FISInstruction.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
