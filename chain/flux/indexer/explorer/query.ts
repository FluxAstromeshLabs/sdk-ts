// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: flux/indexer/explorer/query.proto

/* eslint-disable */
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import { share } from "rxjs/operators";
import { PageRequest, PageResponse } from "../../../cosmos/base/query/v1beta1/pagination";
import { Tx as Tx1 } from "../../../cosmos/tx/v1beta1/tx";
import { BoolValue } from "../../../google/protobuf/wrappers";
import { ExecTxResult } from "../../../tendermint/abci/types";
import { TokenMetadata } from "../../astromesh/v1beta1/event";
import { Plane, planeFromJSON, planeToJSON } from "../../astromesh/v1beta1/tx";
import { Block } from "../../eventstream/v1beta1/query";
import { ContractInfo } from "../../evm/v1beta1/evm";
import { StrategyTriggerEvent } from "../../strategy/v1beta1/event";
import { Strategy, StrategyType, strategyTypeFromJSON, strategyTypeToJSON } from "../../strategy/v1beta1/strategy";
import { AccountLink } from "../../svm/v1beta1/svm";

export enum OrderDirection {
  long = 0,
  short = 1,
  UNRECOGNIZED = -1,
}

export function orderDirectionFromJSON(object: any): OrderDirection {
  switch (object) {
    case 0:
    case "long":
      return OrderDirection.long;
    case 1:
    case "short":
      return OrderDirection.short;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderDirection.UNRECOGNIZED;
  }
}

export function orderDirectionToJSON(object: OrderDirection): string {
  switch (object) {
    case OrderDirection.long:
      return "long";
    case OrderDirection.short:
      return "short";
    case OrderDirection.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ListEvmContractsRequest {
  /** owner of the contract to filter */
  address: string;
  pagination: PageRequest | undefined;
}

export interface ListEvmContractsResponse {
  contracts: ContractInfo[];
  pagination: PageResponse | undefined;
}

export interface BalancesRequest {
  address: string;
  pagination: PageRequest | undefined;
}

export interface BalanceInfo {
  acc: string;
  plane: Plane;
  denom: string;
  amount: string;
  updated_height: string;
  updated_time: string;
  denom_metadata: TokenMetadata | undefined;
}

export interface BalancesResponse {
  balances: BalanceInfo[];
  pagination: PageResponse | undefined;
}

/** strategy type filter, could be generic strategies, intent solver or cron bot */
export interface TypeFilter {
  value: StrategyType;
}

export interface SupportedAppFilter {
  plane: Plane;
  contract_address: string;
  verified: boolean | undefined;
}

/**
 * ListStrategiesRequest is a query type to list out existing on-chain
 * strategies with some filters For unused fields, just leave them empty
 */
export interface ListStrategiesRequest {
  /** use pagination to limit the output item list */
  pagination: PageRequest | undefined;
  type:
    | TypeFilter
    | undefined;
  /** strategy id to filter, this is useful to get info of a single strategy */
  id: string;
  /** strategy enable/disable status to filter */
  enabled:
    | boolean
    | undefined;
  /** tags to filter */
  tags: string[];
  /** filter by supported app (filter single app for now) */
  supported_app: SupportedAppFilter | undefined;
}

export interface ListStrategiesResponse {
  /** pagination response shows which page the strategy list is at */
  pagination:
    | PageResponse
    | undefined;
  /**
   * strategies shows existing strategies after applied the filters in
   * ListStrategiesRequest
   */
  strategies: Strategy[];
}

/** List strategies by an owner with some additional filters */
export interface ListStrategiesByOwnerRequest {
  /** use pagination to limit the output item list */
  pagination:
    | PageRequest
    | undefined;
  /** owner of the strategy, required by this query */
  owner: string;
  /** strategy type, could be generic strategies, intent solver or cron bot */
  type:
    | TypeFilter
    | undefined;
  /** strategy enable/disable status to filter */
  enabled:
    | boolean
    | undefined;
  /** tags to filter */
  tags: string[];
  /** filter by supported app (filter single app for now) */
  supported_app: SupportedAppFilter | undefined;
}

export interface Pool {
  exchange: string;
  plane: Plane;
  /** ID of the pool */
  pool_id: string;
  /** Volume of token0 */
  token0_volume: string;
  /** Volume of token1 */
  token1_volume: string;
  /** Locked amount of token0 */
  token0_liquidity: string;
  /** Locked amount of token1 */
  token1_liquidity: string;
  /** total swap count */
  swap_count: string;
}

export interface Metrics {
  /** Transaction count */
  tx_count: string;
  /** Block count */
  block_count: string;
  /** List of pools with their token volumes */
  pools: Pool[];
}

export interface GetMetricsRequest {
}

export interface GetMetricsResponse {
  data: Metrics | undefined;
}

export interface StreamBalanceResponse {
  height: string;
  deleted: string;
  balances: BalanceInfo[];
}

export interface ListStrategyTriggerByIdRequest {
  /** Use pagination to limit the output item list */
  pagination:
    | PageRequest
    | undefined;
  /** Strategy ID to filter */
  id: string;
  /** Start time to filter */
  from_time: string;
  /** End time to filter */
  to_time: string;
  /** Filter only succeeded/failed triggers */
  success: boolean | undefined;
}

export interface ListStrategyTriggerByIdResponse {
  /** pagination response shows which page the strategy trigger list is at */
  pagination: PageResponse | undefined;
  triggers: StrategyTriggerEvent[];
}

export interface StreamStrategyTriggerRequest {
  id: string[];
}

export interface StreamStrategyTriggerResponse {
  height: string;
  deleted: string;
  triggers: StrategyTriggerEvent[];
}

export interface StreamStrategiesRequest {
  /** owner of the strategy, required by this query */
  owner: string;
  /** strategy type, could be generic strategies, intent solver or cron bot */
  type:
    | TypeFilter
    | undefined;
  /** tags to filter */
  tags: string[];
  /** filter by supported app (filter single app for now) */
  supported_app: SupportedAppFilter | undefined;
}

export interface StreamStrategiesResponse {
  height: string;
  deleted: string;
  strategies: Strategy[];
}

export interface ListTokenMetadataRequest {
  pagination: PageRequest | undefined;
}

export interface ListTokenMetadataResponse {
  pagination: PageResponse | undefined;
  metadata: TokenMetadata[];
}

export interface StreamTokenMetadataRequest {
}

export interface StreamTokenMetadataResponse {
  height: string;
  deleted: string;
  metadata: TokenMetadata[];
}

export interface ListSvmAccountLinksRequest {
  /** optional */
  cosmos_addr: string;
  /** optional */
  svm_addr: string;
  pagination: PageRequest | undefined;
}

export interface ListSvmAccountLinksResponse {
  pagination: PageResponse | undefined;
  account_links: AccountLink[];
}

export interface StreamSvmAccountLinkRequest {
  /** Optional input: Cosmos address */
  cosmos_address: string;
  /** Optional input: SVM address */
  svm_address: string;
}

export interface StreamSvmAccountLinkResponse {
  height: string;
  deleted: string;
  account_link: AccountLink[];
}

/** Request and response messages for ListDriftOrders */
export interface ListDriftOrdersRequest {
  /** Optional filter by market name */
  market_name: string;
}

export interface ListDriftOrdersResponse {
  orders: DriftOrder[];
  /** current block height */
  height: string;
}

/** Request and response messages for ListFillableDriftJITOrders */
export interface ListFillableDriftJITOrdersRequest {
  market_name: string;
  worst_price: string;
  direction: OrderDirection;
  quantity: string;
  exclude_owner: string;
}

export interface ListFillableDriftJITOrdersResponse {
  fillable_orders: DriftOrder[];
  /** current block height */
  height: string;
}

/** Order structure with auction_start_price and auction_end_price */
export interface DriftOrder {
  subaccount_address: string;
  owner_address: string;
  price: string;
  total_quantity: string;
  market_name: string;
  order_id: number;
  auction_start_price: string;
  auction_end_price: string;
  created_height: string;
  auction_duration: number;
  expired_at: string;
  direction: OrderDirection;
  fillable_quantity: string;
  updated_height: string;
}

export interface StreamDriftOrdersRequest {
  /** Optional filter by market name */
  market_name: string;
  /** Optional filter for specific price */
  price: string;
  /** Optional filter, e.g., "buy" or "sell" */
  direction: string;
}

export interface StreamDriftOrdersResponse {
  /** Block height at which the order was created or updated */
  height: string;
  /** Indicator if the order is deleted (1 for true, 0 for false) */
  deleted: string;
  /** The DriftOrder object */
  order: DriftOrder | undefined;
}

export interface ListTxsRequest {
  /** optional */
  start_block: string;
  /** optional */
  end_block: string;
  /** optional, UNIX timestamp */
  start_time: string;
  /** optional, UNIX timestamp */
  end_time: string;
  pagination: PageRequest | undefined;
}

export interface ListTxsResponse {
  pagination: PageResponse | undefined;
  txs: Tx[];
}

export interface GetTxRequest {
  tx_hash: string;
}

export interface Tx {
  height: string;
  time: string;
  hash: string;
  tx: Tx1 | undefined;
  tx_result:
    | ExecTxResult
    | undefined;
  /** serves as token in token_based pagination method */
  tx_index: string;
}

export interface GetTxResponse {
  tx: Tx | undefined;
}

export interface ListAccountTxsRequest {
  account: string;
  pagination: PageRequest | undefined;
}

export interface ListAccountTxsResponse {
  pagination: PageResponse | undefined;
  txs: Tx[];
}

export interface ListBlocksRequest {
  /** optional */
  start_block: string;
  /** optional */
  end_block: string;
  pagination: PageRequest | undefined;
}

export interface ListBlocksResponse {
  pagination: PageResponse | undefined;
  blocks: Block[];
}

export interface GetBlockRequest {
  block_height: string;
}

export interface GetBlockResponse {
  block: Block | undefined;
}

/** Request and response messages for StreamTxs */
export interface StreamTxsRequest {
  /** Optional filter for specific account address */
  address: string;
}

export interface StreamTxsResponse {
  /** Block height at which the transaction was created or updated */
  height: string;
  /** Indicator if the transaction is deleted (1 for true, 0 for false) */
  deleted: string;
  /** Transaction object */
  tx: Tx | undefined;
}

/** Request and response messages for StreamBlocks */
export interface StreamBlocksRequest {
}

export interface StreamBlocksResponse {
  /** Block height at which the block was created or updated */
  height: string;
  /** Indicator if the block is deleted (1 for true, 0 for false) */
  deleted: string;
  /** The Block object */
  block: Block | undefined;
}

export interface Contract {
  address: string;
  plane: Plane;
  name: string;
  creator: string;
  /** UNIX timestamp */
  created_at: string;
  /** UNIX timestamp */
  last_execution_time: string;
  execution_count: string;
  /** Init message, not available for SVM */
  init_msg: Uint8Array;
  /** Only available for WASM */
  code_id: string;
  tx_hash: string;
  /** Contract admin, upgrade authority */
  admin: string;
  height: string;
  contract_index: string;
}

export interface ListContractsRequest {
  pagination: PageRequest | undefined;
  plane: Plane;
}

export interface ListContractsResponse {
  contracts: Contract[];
  pagination: PageResponse | undefined;
}

export interface GetContractRequest {
  /** Contract address to fetch */
  address: string;
  plane: Plane;
}

export interface GetContractResponse {
  contract: Contract | undefined;
}

export interface StreamContractRequest {
  plane: Plane;
}

export interface StreamContractResponse {
  height: string;
  deleted: string;
  contract: Contract | undefined;
}

export interface ListDumpsadCoinsRequest {
  pagination: PageRequest | undefined;
}

export interface DumpsadCoin {
  /** denom of the coin */
  denom: string;
  /** Symbol of the coin */
  symbol: string;
  /** Name of the coin */
  name: string;
  /** Description of the coin */
  description: string;
  /** URL to the logo of the coin */
  logo: string;
  /** Virtual machine type (e.g., WASM, EVM, SVM) */
  vm: string;
  /** Associated cron ID */
  cron_id: string;
  /** Associated solver ID */
  solver_id: string;
  /** Current price of the coin */
  current_price: string;
  /** Block height */
  height: string;
  /** Pool id/address */
  pool_id: string;
  curve_sol_amount: string;
  market_cap: string;
}

export interface ListDumpsadCoinsResponse {
  /** List of DumpsadCoins */
  dumpsad_coins: DumpsadCoin[];
  /** Pagination response */
  pagination: PageResponse | undefined;
}

export interface StreamDumpsadCoinsRequest {
  /** denom of the coin */
  denom: string;
}

export interface StreamDumpsadCoinsResponse {
  /** Block height at which the order was created or updated */
  height: string;
  /** Indicator if the order is deleted (1 for true, 0 for false) */
  deleted: string;
  coin: DumpsadCoin | undefined;
}

export interface ListDumpsadTradesRequest {
  /** Filter by denom */
  denom: string;
  /** Filter by strategy ID */
  solver_id: string;
  /** Filter by trader */
  trader: string;
  /** Filter by sol amount */
  sol_amount: string;
  pagination: PageRequest | undefined;
}

export interface DumpsadTrade {
  denom: string;
  solver_id: string;
  trader: string;
  /** "buy" or "sell" */
  action: string;
  meme_amount: string;
  sol_amount: string;
  height: string;
  time: string;
}

export interface ListDumpsadTradesResponse {
  /** List of trades */
  trades: DumpsadTrade[];
  pagination: PageResponse | undefined;
}

export interface StreamDumpsadTradesRequest {
  /** Optional filter by denom */
  denom: string;
  /** Optional filter by strategy ID */
  strategy_id: string;
}

export interface StreamDumpsadTradesResponse {
  height: string;
  /** Indicator if the trade is deleted (1 for true, 0 for false) */
  deleted: string;
  trade: DumpsadTrade | undefined;
}

function createBaseListEvmContractsRequest(): ListEvmContractsRequest {
  return { address: "", pagination: undefined };
}

export const ListEvmContractsRequest = {
  $type: "flux.indexer.explorer.ListEvmContractsRequest" as const,

  encode(message: ListEvmContractsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListEvmContractsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEvmContractsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEvmContractsRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListEvmContractsRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListEvmContractsRequest>): ListEvmContractsRequest {
    return ListEvmContractsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEvmContractsRequest>): ListEvmContractsRequest {
    const message = createBaseListEvmContractsRequest();
    message.address = object.address ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListEvmContractsResponse(): ListEvmContractsResponse {
  return { contracts: [], pagination: undefined };
}

export const ListEvmContractsResponse = {
  $type: "flux.indexer.explorer.ListEvmContractsResponse" as const,

  encode(message: ListEvmContractsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.contracts) {
      ContractInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListEvmContractsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEvmContractsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contracts.push(ContractInfo.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEvmContractsResponse {
    return {
      contracts: globalThis.Array.isArray(object?.contracts)
        ? object.contracts.map((e: any) => ContractInfo.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListEvmContractsResponse): unknown {
    const obj: any = {};
    if (message.contracts?.length) {
      obj.contracts = message.contracts.map((e) => ContractInfo.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListEvmContractsResponse>): ListEvmContractsResponse {
    return ListEvmContractsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEvmContractsResponse>): ListEvmContractsResponse {
    const message = createBaseListEvmContractsResponse();
    message.contracts = object.contracts?.map((e) => ContractInfo.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseBalancesRequest(): BalancesRequest {
  return { address: "", pagination: undefined };
}

export const BalancesRequest = {
  $type: "flux.indexer.explorer.BalancesRequest" as const,

  encode(message: BalancesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BalancesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalancesRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: BalancesRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<BalancesRequest>): BalancesRequest {
    return BalancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BalancesRequest>): BalancesRequest {
    const message = createBaseBalancesRequest();
    message.address = object.address ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseBalanceInfo(): BalanceInfo {
  return {
    acc: "",
    plane: 0,
    denom: "",
    amount: "",
    updated_height: "0",
    updated_time: "0",
    denom_metadata: undefined,
  };
}

export const BalanceInfo = {
  $type: "flux.indexer.explorer.BalanceInfo" as const,

  encode(message: BalanceInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.acc !== "") {
      writer.uint32(10).string(message.acc);
    }
    if (message.plane !== 0) {
      writer.uint32(16).int32(message.plane);
    }
    if (message.denom !== "") {
      writer.uint32(26).string(message.denom);
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    if (message.updated_height !== "0") {
      writer.uint32(40).uint64(message.updated_height);
    }
    if (message.updated_time !== "0") {
      writer.uint32(48).uint64(message.updated_time);
    }
    if (message.denom_metadata !== undefined) {
      TokenMetadata.encode(message.denom_metadata, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BalanceInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.acc = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.plane = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.denom = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.updated_height = longToString(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.updated_time = longToString(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.denom_metadata = TokenMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalanceInfo {
    return {
      acc: isSet(object.acc) ? globalThis.String(object.acc) : "",
      plane: isSet(object.plane) ? planeFromJSON(object.plane) : 0,
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      updated_height: isSet(object.updated_height) ? globalThis.String(object.updated_height) : "0",
      updated_time: isSet(object.updated_time) ? globalThis.String(object.updated_time) : "0",
      denom_metadata: isSet(object.denom_metadata) ? TokenMetadata.fromJSON(object.denom_metadata) : undefined,
    };
  },

  toJSON(message: BalanceInfo): unknown {
    const obj: any = {};
    if (message.acc !== undefined) {
      obj.acc = message.acc;
    }
    if (message.plane !== undefined) {
      obj.plane = planeToJSON(message.plane);
    }
    if (message.denom !== undefined) {
      obj.denom = message.denom;
    }
    if (message.amount !== undefined) {
      obj.amount = message.amount;
    }
    if (message.updated_height !== undefined) {
      obj.updated_height = message.updated_height;
    }
    if (message.updated_time !== undefined) {
      obj.updated_time = message.updated_time;
    }
    if (message.denom_metadata !== undefined) {
      obj.denom_metadata = TokenMetadata.toJSON(message.denom_metadata);
    }
    return obj;
  },

  create(base?: DeepPartial<BalanceInfo>): BalanceInfo {
    return BalanceInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BalanceInfo>): BalanceInfo {
    const message = createBaseBalanceInfo();
    message.acc = object.acc ?? "";
    message.plane = object.plane ?? 0;
    message.denom = object.denom ?? "";
    message.amount = object.amount ?? "";
    message.updated_height = object.updated_height ?? "0";
    message.updated_time = object.updated_time ?? "0";
    message.denom_metadata = (object.denom_metadata !== undefined && object.denom_metadata !== null)
      ? TokenMetadata.fromPartial(object.denom_metadata)
      : undefined;
    return message;
  },
};

function createBaseBalancesResponse(): BalancesResponse {
  return { balances: [], pagination: undefined };
}

export const BalancesResponse = {
  $type: "flux.indexer.explorer.BalancesResponse" as const,

  encode(message: BalancesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.balances) {
      BalanceInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BalancesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.balances.push(BalanceInfo.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalancesResponse {
    return {
      balances: globalThis.Array.isArray(object?.balances)
        ? object.balances.map((e: any) => BalanceInfo.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: BalancesResponse): unknown {
    const obj: any = {};
    if (message.balances?.length) {
      obj.balances = message.balances.map((e) => BalanceInfo.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<BalancesResponse>): BalancesResponse {
    return BalancesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BalancesResponse>): BalancesResponse {
    const message = createBaseBalancesResponse();
    message.balances = object.balances?.map((e) => BalanceInfo.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseTypeFilter(): TypeFilter {
  return { value: 0 };
}

export const TypeFilter = {
  $type: "flux.indexer.explorer.TypeFilter" as const,

  encode(message: TypeFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TypeFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypeFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypeFilter {
    return { value: isSet(object.value) ? strategyTypeFromJSON(object.value) : 0 };
  },

  toJSON(message: TypeFilter): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = strategyTypeToJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<TypeFilter>): TypeFilter {
    return TypeFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TypeFilter>): TypeFilter {
    const message = createBaseTypeFilter();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseSupportedAppFilter(): SupportedAppFilter {
  return { plane: 0, contract_address: "", verified: undefined };
}

export const SupportedAppFilter = {
  $type: "flux.indexer.explorer.SupportedAppFilter" as const,

  encode(message: SupportedAppFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.plane !== 0) {
      writer.uint32(8).int32(message.plane);
    }
    if (message.contract_address !== "") {
      writer.uint32(18).string(message.contract_address);
    }
    if (message.verified !== undefined) {
      BoolValue.encode({ value: message.verified! }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SupportedAppFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupportedAppFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.plane = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contract_address = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.verified = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupportedAppFilter {
    return {
      plane: isSet(object.plane) ? planeFromJSON(object.plane) : 0,
      contract_address: isSet(object.contract_address) ? globalThis.String(object.contract_address) : "",
      verified: isSet(object.verified) ? Boolean(object.verified) : undefined,
    };
  },

  toJSON(message: SupportedAppFilter): unknown {
    const obj: any = {};
    if (message.plane !== undefined) {
      obj.plane = planeToJSON(message.plane);
    }
    if (message.contract_address !== undefined) {
      obj.contract_address = message.contract_address;
    }
    if (message.verified !== undefined) {
      obj.verified = message.verified;
    }
    return obj;
  },

  create(base?: DeepPartial<SupportedAppFilter>): SupportedAppFilter {
    return SupportedAppFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SupportedAppFilter>): SupportedAppFilter {
    const message = createBaseSupportedAppFilter();
    message.plane = object.plane ?? 0;
    message.contract_address = object.contract_address ?? "";
    message.verified = object.verified ?? undefined;
    return message;
  },
};

function createBaseListStrategiesRequest(): ListStrategiesRequest {
  return { pagination: undefined, type: undefined, id: "", enabled: undefined, tags: [], supported_app: undefined };
}

export const ListStrategiesRequest = {
  $type: "flux.indexer.explorer.ListStrategiesRequest" as const,

  encode(message: ListStrategiesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    if (message.type !== undefined) {
      TypeFilter.encode(message.type, writer.uint32(18).fork()).ldelim();
    }
    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }
    if (message.enabled !== undefined) {
      BoolValue.encode({ value: message.enabled! }, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.tags) {
      writer.uint32(42).string(v!);
    }
    if (message.supported_app !== undefined) {
      SupportedAppFilter.encode(message.supported_app, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListStrategiesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStrategiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = TypeFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.enabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.supported_app = SupportedAppFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStrategiesRequest {
    return {
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
      type: isSet(object.type) ? TypeFilter.fromJSON(object.type) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      enabled: isSet(object.enabled) ? Boolean(object.enabled) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      supported_app: isSet(object.supported_app) ? SupportedAppFilter.fromJSON(object.supported_app) : undefined,
    };
  },

  toJSON(message: ListStrategiesRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    if (message.type !== undefined) {
      obj.type = TypeFilter.toJSON(message.type);
    }
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.enabled !== undefined) {
      obj.enabled = message.enabled;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.supported_app !== undefined) {
      obj.supported_app = SupportedAppFilter.toJSON(message.supported_app);
    }
    return obj;
  },

  create(base?: DeepPartial<ListStrategiesRequest>): ListStrategiesRequest {
    return ListStrategiesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListStrategiesRequest>): ListStrategiesRequest {
    const message = createBaseListStrategiesRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    message.type = (object.type !== undefined && object.type !== null)
      ? TypeFilter.fromPartial(object.type)
      : undefined;
    message.id = object.id ?? "";
    message.enabled = object.enabled ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.supported_app = (object.supported_app !== undefined && object.supported_app !== null)
      ? SupportedAppFilter.fromPartial(object.supported_app)
      : undefined;
    return message;
  },
};

function createBaseListStrategiesResponse(): ListStrategiesResponse {
  return { pagination: undefined, strategies: [] };
}

export const ListStrategiesResponse = {
  $type: "flux.indexer.explorer.ListStrategiesResponse" as const,

  encode(message: ListStrategiesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.strategies) {
      Strategy.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListStrategiesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStrategiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.strategies.push(Strategy.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStrategiesResponse {
    return {
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
      strategies: globalThis.Array.isArray(object?.strategies)
        ? object.strategies.map((e: any) => Strategy.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListStrategiesResponse): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    if (message.strategies?.length) {
      obj.strategies = message.strategies.map((e) => Strategy.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListStrategiesResponse>): ListStrategiesResponse {
    return ListStrategiesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListStrategiesResponse>): ListStrategiesResponse {
    const message = createBaseListStrategiesResponse();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    message.strategies = object.strategies?.map((e) => Strategy.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListStrategiesByOwnerRequest(): ListStrategiesByOwnerRequest {
  return { pagination: undefined, owner: "", type: undefined, enabled: undefined, tags: [], supported_app: undefined };
}

export const ListStrategiesByOwnerRequest = {
  $type: "flux.indexer.explorer.ListStrategiesByOwnerRequest" as const,

  encode(message: ListStrategiesByOwnerRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    if (message.owner !== "") {
      writer.uint32(18).string(message.owner);
    }
    if (message.type !== undefined) {
      TypeFilter.encode(message.type, writer.uint32(26).fork()).ldelim();
    }
    if (message.enabled !== undefined) {
      BoolValue.encode({ value: message.enabled! }, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.tags) {
      writer.uint32(42).string(v!);
    }
    if (message.supported_app !== undefined) {
      SupportedAppFilter.encode(message.supported_app, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListStrategiesByOwnerRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStrategiesByOwnerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = TypeFilter.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.enabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.supported_app = SupportedAppFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStrategiesByOwnerRequest {
    return {
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      type: isSet(object.type) ? TypeFilter.fromJSON(object.type) : undefined,
      enabled: isSet(object.enabled) ? Boolean(object.enabled) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      supported_app: isSet(object.supported_app) ? SupportedAppFilter.fromJSON(object.supported_app) : undefined,
    };
  },

  toJSON(message: ListStrategiesByOwnerRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.type !== undefined) {
      obj.type = TypeFilter.toJSON(message.type);
    }
    if (message.enabled !== undefined) {
      obj.enabled = message.enabled;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.supported_app !== undefined) {
      obj.supported_app = SupportedAppFilter.toJSON(message.supported_app);
    }
    return obj;
  },

  create(base?: DeepPartial<ListStrategiesByOwnerRequest>): ListStrategiesByOwnerRequest {
    return ListStrategiesByOwnerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListStrategiesByOwnerRequest>): ListStrategiesByOwnerRequest {
    const message = createBaseListStrategiesByOwnerRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    message.owner = object.owner ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? TypeFilter.fromPartial(object.type)
      : undefined;
    message.enabled = object.enabled ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.supported_app = (object.supported_app !== undefined && object.supported_app !== null)
      ? SupportedAppFilter.fromPartial(object.supported_app)
      : undefined;
    return message;
  },
};

function createBasePool(): Pool {
  return {
    exchange: "",
    plane: 0,
    pool_id: "",
    token0_volume: "",
    token1_volume: "",
    token0_liquidity: "",
    token1_liquidity: "",
    swap_count: "0",
  };
}

export const Pool = {
  $type: "flux.indexer.explorer.Pool" as const,

  encode(message: Pool, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.exchange !== "") {
      writer.uint32(10).string(message.exchange);
    }
    if (message.plane !== 0) {
      writer.uint32(16).int32(message.plane);
    }
    if (message.pool_id !== "") {
      writer.uint32(26).string(message.pool_id);
    }
    if (message.token0_volume !== "") {
      writer.uint32(34).string(message.token0_volume);
    }
    if (message.token1_volume !== "") {
      writer.uint32(42).string(message.token1_volume);
    }
    if (message.token0_liquidity !== "") {
      writer.uint32(50).string(message.token0_liquidity);
    }
    if (message.token1_liquidity !== "") {
      writer.uint32(58).string(message.token1_liquidity);
    }
    if (message.swap_count !== "0") {
      writer.uint32(64).int64(message.swap_count);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Pool {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.exchange = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.plane = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pool_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.token0_volume = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.token1_volume = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.token0_liquidity = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.token1_liquidity = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.swap_count = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pool {
    return {
      exchange: isSet(object.exchange) ? globalThis.String(object.exchange) : "",
      plane: isSet(object.plane) ? planeFromJSON(object.plane) : 0,
      pool_id: isSet(object.pool_id) ? globalThis.String(object.pool_id) : "",
      token0_volume: isSet(object.token0_volume) ? globalThis.String(object.token0_volume) : "",
      token1_volume: isSet(object.token1_volume) ? globalThis.String(object.token1_volume) : "",
      token0_liquidity: isSet(object.token0_liquidity) ? globalThis.String(object.token0_liquidity) : "",
      token1_liquidity: isSet(object.token1_liquidity) ? globalThis.String(object.token1_liquidity) : "",
      swap_count: isSet(object.swap_count) ? globalThis.String(object.swap_count) : "0",
    };
  },

  toJSON(message: Pool): unknown {
    const obj: any = {};
    if (message.exchange !== undefined) {
      obj.exchange = message.exchange;
    }
    if (message.plane !== undefined) {
      obj.plane = planeToJSON(message.plane);
    }
    if (message.pool_id !== undefined) {
      obj.pool_id = message.pool_id;
    }
    if (message.token0_volume !== undefined) {
      obj.token0_volume = message.token0_volume;
    }
    if (message.token1_volume !== undefined) {
      obj.token1_volume = message.token1_volume;
    }
    if (message.token0_liquidity !== undefined) {
      obj.token0_liquidity = message.token0_liquidity;
    }
    if (message.token1_liquidity !== undefined) {
      obj.token1_liquidity = message.token1_liquidity;
    }
    if (message.swap_count !== undefined) {
      obj.swap_count = message.swap_count;
    }
    return obj;
  },

  create(base?: DeepPartial<Pool>): Pool {
    return Pool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Pool>): Pool {
    const message = createBasePool();
    message.exchange = object.exchange ?? "";
    message.plane = object.plane ?? 0;
    message.pool_id = object.pool_id ?? "";
    message.token0_volume = object.token0_volume ?? "";
    message.token1_volume = object.token1_volume ?? "";
    message.token0_liquidity = object.token0_liquidity ?? "";
    message.token1_liquidity = object.token1_liquidity ?? "";
    message.swap_count = object.swap_count ?? "0";
    return message;
  },
};

function createBaseMetrics(): Metrics {
  return { tx_count: "0", block_count: "0", pools: [] };
}

export const Metrics = {
  $type: "flux.indexer.explorer.Metrics" as const,

  encode(message: Metrics, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tx_count !== "0") {
      writer.uint32(8).int64(message.tx_count);
    }
    if (message.block_count !== "0") {
      writer.uint32(16).int64(message.block_count);
    }
    for (const v of message.pools) {
      Pool.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Metrics {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tx_count = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.block_count = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pools.push(Pool.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metrics {
    return {
      tx_count: isSet(object.tx_count) ? globalThis.String(object.tx_count) : "0",
      block_count: isSet(object.block_count) ? globalThis.String(object.block_count) : "0",
      pools: globalThis.Array.isArray(object?.pools) ? object.pools.map((e: any) => Pool.fromJSON(e)) : [],
    };
  },

  toJSON(message: Metrics): unknown {
    const obj: any = {};
    if (message.tx_count !== undefined) {
      obj.tx_count = message.tx_count;
    }
    if (message.block_count !== undefined) {
      obj.block_count = message.block_count;
    }
    if (message.pools?.length) {
      obj.pools = message.pools.map((e) => Pool.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Metrics>): Metrics {
    return Metrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Metrics>): Metrics {
    const message = createBaseMetrics();
    message.tx_count = object.tx_count ?? "0";
    message.block_count = object.block_count ?? "0";
    message.pools = object.pools?.map((e) => Pool.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetMetricsRequest(): GetMetricsRequest {
  return {};
}

export const GetMetricsRequest = {
  $type: "flux.indexer.explorer.GetMetricsRequest" as const,

  encode(_: GetMetricsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMetricsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetMetricsRequest {
    return {};
  },

  toJSON(_: GetMetricsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetMetricsRequest>): GetMetricsRequest {
    return GetMetricsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetMetricsRequest>): GetMetricsRequest {
    const message = createBaseGetMetricsRequest();
    return message;
  },
};

function createBaseGetMetricsResponse(): GetMetricsResponse {
  return { data: undefined };
}

export const GetMetricsResponse = {
  $type: "flux.indexer.explorer.GetMetricsResponse" as const,

  encode(message: GetMetricsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data !== undefined) {
      Metrics.encode(message.data, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMetricsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = Metrics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMetricsResponse {
    return { data: isSet(object.data) ? Metrics.fromJSON(object.data) : undefined };
  },

  toJSON(message: GetMetricsResponse): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = Metrics.toJSON(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<GetMetricsResponse>): GetMetricsResponse {
    return GetMetricsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMetricsResponse>): GetMetricsResponse {
    const message = createBaseGetMetricsResponse();
    message.data = (object.data !== undefined && object.data !== null) ? Metrics.fromPartial(object.data) : undefined;
    return message;
  },
};

function createBaseStreamBalanceResponse(): StreamBalanceResponse {
  return { height: "0", deleted: "0", balances: [] };
}

export const StreamBalanceResponse = {
  $type: "flux.indexer.explorer.StreamBalanceResponse" as const,

  encode(message: StreamBalanceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).uint64(message.height);
    }
    if (message.deleted !== "0") {
      writer.uint32(16).uint64(message.deleted);
    }
    for (const v of message.balances) {
      BalanceInfo.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamBalanceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamBalanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.balances.push(BalanceInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamBalanceResponse {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "0",
      balances: globalThis.Array.isArray(object?.balances)
        ? object.balances.map((e: any) => BalanceInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamBalanceResponse): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.balances?.length) {
      obj.balances = message.balances.map((e) => BalanceInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StreamBalanceResponse>): StreamBalanceResponse {
    return StreamBalanceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamBalanceResponse>): StreamBalanceResponse {
    const message = createBaseStreamBalanceResponse();
    message.height = object.height ?? "0";
    message.deleted = object.deleted ?? "0";
    message.balances = object.balances?.map((e) => BalanceInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListStrategyTriggerByIdRequest(): ListStrategyTriggerByIdRequest {
  return { pagination: undefined, id: "", from_time: "0", to_time: "0", success: undefined };
}

export const ListStrategyTriggerByIdRequest = {
  $type: "flux.indexer.explorer.ListStrategyTriggerByIdRequest" as const,

  encode(message: ListStrategyTriggerByIdRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.from_time !== "0") {
      writer.uint32(24).int64(message.from_time);
    }
    if (message.to_time !== "0") {
      writer.uint32(32).int64(message.to_time);
    }
    if (message.success !== undefined) {
      BoolValue.encode({ value: message.success! }, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListStrategyTriggerByIdRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStrategyTriggerByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.from_time = longToString(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.to_time = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.success = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStrategyTriggerByIdRequest {
    return {
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      from_time: isSet(object.from_time) ? globalThis.String(object.from_time) : "0",
      to_time: isSet(object.to_time) ? globalThis.String(object.to_time) : "0",
      success: isSet(object.success) ? Boolean(object.success) : undefined,
    };
  },

  toJSON(message: ListStrategyTriggerByIdRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.from_time !== undefined) {
      obj.from_time = message.from_time;
    }
    if (message.to_time !== undefined) {
      obj.to_time = message.to_time;
    }
    if (message.success !== undefined) {
      obj.success = message.success;
    }
    return obj;
  },

  create(base?: DeepPartial<ListStrategyTriggerByIdRequest>): ListStrategyTriggerByIdRequest {
    return ListStrategyTriggerByIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListStrategyTriggerByIdRequest>): ListStrategyTriggerByIdRequest {
    const message = createBaseListStrategyTriggerByIdRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    message.id = object.id ?? "";
    message.from_time = object.from_time ?? "0";
    message.to_time = object.to_time ?? "0";
    message.success = object.success ?? undefined;
    return message;
  },
};

function createBaseListStrategyTriggerByIdResponse(): ListStrategyTriggerByIdResponse {
  return { pagination: undefined, triggers: [] };
}

export const ListStrategyTriggerByIdResponse = {
  $type: "flux.indexer.explorer.ListStrategyTriggerByIdResponse" as const,

  encode(message: ListStrategyTriggerByIdResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.triggers) {
      StrategyTriggerEvent.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListStrategyTriggerByIdResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStrategyTriggerByIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.triggers.push(StrategyTriggerEvent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStrategyTriggerByIdResponse {
    return {
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
      triggers: globalThis.Array.isArray(object?.triggers)
        ? object.triggers.map((e: any) => StrategyTriggerEvent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListStrategyTriggerByIdResponse): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    if (message.triggers?.length) {
      obj.triggers = message.triggers.map((e) => StrategyTriggerEvent.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListStrategyTriggerByIdResponse>): ListStrategyTriggerByIdResponse {
    return ListStrategyTriggerByIdResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListStrategyTriggerByIdResponse>): ListStrategyTriggerByIdResponse {
    const message = createBaseListStrategyTriggerByIdResponse();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    message.triggers = object.triggers?.map((e) => StrategyTriggerEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStreamStrategyTriggerRequest(): StreamStrategyTriggerRequest {
  return { id: [] };
}

export const StreamStrategyTriggerRequest = {
  $type: "flux.indexer.explorer.StreamStrategyTriggerRequest" as const,

  encode(message: StreamStrategyTriggerRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.id) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamStrategyTriggerRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamStrategyTriggerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamStrategyTriggerRequest {
    return { id: globalThis.Array.isArray(object?.id) ? object.id.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: StreamStrategyTriggerRequest): unknown {
    const obj: any = {};
    if (message.id?.length) {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamStrategyTriggerRequest>): StreamStrategyTriggerRequest {
    return StreamStrategyTriggerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamStrategyTriggerRequest>): StreamStrategyTriggerRequest {
    const message = createBaseStreamStrategyTriggerRequest();
    message.id = object.id?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamStrategyTriggerResponse(): StreamStrategyTriggerResponse {
  return { height: "0", deleted: "0", triggers: [] };
}

export const StreamStrategyTriggerResponse = {
  $type: "flux.indexer.explorer.StreamStrategyTriggerResponse" as const,

  encode(message: StreamStrategyTriggerResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).uint64(message.height);
    }
    if (message.deleted !== "0") {
      writer.uint32(16).uint64(message.deleted);
    }
    for (const v of message.triggers) {
      StrategyTriggerEvent.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamStrategyTriggerResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamStrategyTriggerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.triggers.push(StrategyTriggerEvent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamStrategyTriggerResponse {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "0",
      triggers: globalThis.Array.isArray(object?.triggers)
        ? object.triggers.map((e: any) => StrategyTriggerEvent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamStrategyTriggerResponse): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.triggers?.length) {
      obj.triggers = message.triggers.map((e) => StrategyTriggerEvent.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StreamStrategyTriggerResponse>): StreamStrategyTriggerResponse {
    return StreamStrategyTriggerResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamStrategyTriggerResponse>): StreamStrategyTriggerResponse {
    const message = createBaseStreamStrategyTriggerResponse();
    message.height = object.height ?? "0";
    message.deleted = object.deleted ?? "0";
    message.triggers = object.triggers?.map((e) => StrategyTriggerEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStreamStrategiesRequest(): StreamStrategiesRequest {
  return { owner: "", type: undefined, tags: [], supported_app: undefined };
}

export const StreamStrategiesRequest = {
  $type: "flux.indexer.explorer.StreamStrategiesRequest" as const,

  encode(message: StreamStrategiesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.type !== undefined) {
      TypeFilter.encode(message.type, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.tags) {
      writer.uint32(26).string(v!);
    }
    if (message.supported_app !== undefined) {
      SupportedAppFilter.encode(message.supported_app, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamStrategiesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamStrategiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = TypeFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.supported_app = SupportedAppFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamStrategiesRequest {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      type: isSet(object.type) ? TypeFilter.fromJSON(object.type) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      supported_app: isSet(object.supported_app) ? SupportedAppFilter.fromJSON(object.supported_app) : undefined,
    };
  },

  toJSON(message: StreamStrategiesRequest): unknown {
    const obj: any = {};
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.type !== undefined) {
      obj.type = TypeFilter.toJSON(message.type);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.supported_app !== undefined) {
      obj.supported_app = SupportedAppFilter.toJSON(message.supported_app);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamStrategiesRequest>): StreamStrategiesRequest {
    return StreamStrategiesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamStrategiesRequest>): StreamStrategiesRequest {
    const message = createBaseStreamStrategiesRequest();
    message.owner = object.owner ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? TypeFilter.fromPartial(object.type)
      : undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.supported_app = (object.supported_app !== undefined && object.supported_app !== null)
      ? SupportedAppFilter.fromPartial(object.supported_app)
      : undefined;
    return message;
  },
};

function createBaseStreamStrategiesResponse(): StreamStrategiesResponse {
  return { height: "0", deleted: "0", strategies: [] };
}

export const StreamStrategiesResponse = {
  $type: "flux.indexer.explorer.StreamStrategiesResponse" as const,

  encode(message: StreamStrategiesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).uint64(message.height);
    }
    if (message.deleted !== "0") {
      writer.uint32(16).uint64(message.deleted);
    }
    for (const v of message.strategies) {
      Strategy.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamStrategiesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamStrategiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.strategies.push(Strategy.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamStrategiesResponse {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "0",
      strategies: globalThis.Array.isArray(object?.strategies)
        ? object.strategies.map((e: any) => Strategy.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamStrategiesResponse): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.strategies?.length) {
      obj.strategies = message.strategies.map((e) => Strategy.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StreamStrategiesResponse>): StreamStrategiesResponse {
    return StreamStrategiesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamStrategiesResponse>): StreamStrategiesResponse {
    const message = createBaseStreamStrategiesResponse();
    message.height = object.height ?? "0";
    message.deleted = object.deleted ?? "0";
    message.strategies = object.strategies?.map((e) => Strategy.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListTokenMetadataRequest(): ListTokenMetadataRequest {
  return { pagination: undefined };
}

export const ListTokenMetadataRequest = {
  $type: "flux.indexer.explorer.ListTokenMetadataRequest" as const,

  encode(message: ListTokenMetadataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTokenMetadataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTokenMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTokenMetadataRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: ListTokenMetadataRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListTokenMetadataRequest>): ListTokenMetadataRequest {
    return ListTokenMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTokenMetadataRequest>): ListTokenMetadataRequest {
    const message = createBaseListTokenMetadataRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListTokenMetadataResponse(): ListTokenMetadataResponse {
  return { pagination: undefined, metadata: [] };
}

export const ListTokenMetadataResponse = {
  $type: "flux.indexer.explorer.ListTokenMetadataResponse" as const,

  encode(message: ListTokenMetadataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.metadata) {
      TokenMetadata.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTokenMetadataResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTokenMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metadata.push(TokenMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTokenMetadataResponse {
    return {
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
      metadata: globalThis.Array.isArray(object?.metadata)
        ? object.metadata.map((e: any) => TokenMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListTokenMetadataResponse): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata.map((e) => TokenMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListTokenMetadataResponse>): ListTokenMetadataResponse {
    return ListTokenMetadataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTokenMetadataResponse>): ListTokenMetadataResponse {
    const message = createBaseListTokenMetadataResponse();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    message.metadata = object.metadata?.map((e) => TokenMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStreamTokenMetadataRequest(): StreamTokenMetadataRequest {
  return {};
}

export const StreamTokenMetadataRequest = {
  $type: "flux.indexer.explorer.StreamTokenMetadataRequest" as const,

  encode(_: StreamTokenMetadataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamTokenMetadataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamTokenMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StreamTokenMetadataRequest {
    return {};
  },

  toJSON(_: StreamTokenMetadataRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<StreamTokenMetadataRequest>): StreamTokenMetadataRequest {
    return StreamTokenMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<StreamTokenMetadataRequest>): StreamTokenMetadataRequest {
    const message = createBaseStreamTokenMetadataRequest();
    return message;
  },
};

function createBaseStreamTokenMetadataResponse(): StreamTokenMetadataResponse {
  return { height: "0", deleted: "0", metadata: [] };
}

export const StreamTokenMetadataResponse = {
  $type: "flux.indexer.explorer.StreamTokenMetadataResponse" as const,

  encode(message: StreamTokenMetadataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).uint64(message.height);
    }
    if (message.deleted !== "0") {
      writer.uint32(16).uint64(message.deleted);
    }
    for (const v of message.metadata) {
      TokenMetadata.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamTokenMetadataResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamTokenMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadata.push(TokenMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamTokenMetadataResponse {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "0",
      metadata: globalThis.Array.isArray(object?.metadata)
        ? object.metadata.map((e: any) => TokenMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamTokenMetadataResponse): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata.map((e) => TokenMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StreamTokenMetadataResponse>): StreamTokenMetadataResponse {
    return StreamTokenMetadataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamTokenMetadataResponse>): StreamTokenMetadataResponse {
    const message = createBaseStreamTokenMetadataResponse();
    message.height = object.height ?? "0";
    message.deleted = object.deleted ?? "0";
    message.metadata = object.metadata?.map((e) => TokenMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListSvmAccountLinksRequest(): ListSvmAccountLinksRequest {
  return { cosmos_addr: "", svm_addr: "", pagination: undefined };
}

export const ListSvmAccountLinksRequest = {
  $type: "flux.indexer.explorer.ListSvmAccountLinksRequest" as const,

  encode(message: ListSvmAccountLinksRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cosmos_addr !== "") {
      writer.uint32(10).string(message.cosmos_addr);
    }
    if (message.svm_addr !== "") {
      writer.uint32(18).string(message.svm_addr);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSvmAccountLinksRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSvmAccountLinksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cosmos_addr = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.svm_addr = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSvmAccountLinksRequest {
    return {
      cosmos_addr: isSet(object.cosmos_addr) ? globalThis.String(object.cosmos_addr) : "",
      svm_addr: isSet(object.svm_addr) ? globalThis.String(object.svm_addr) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListSvmAccountLinksRequest): unknown {
    const obj: any = {};
    if (message.cosmos_addr !== undefined) {
      obj.cosmos_addr = message.cosmos_addr;
    }
    if (message.svm_addr !== undefined) {
      obj.svm_addr = message.svm_addr;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListSvmAccountLinksRequest>): ListSvmAccountLinksRequest {
    return ListSvmAccountLinksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSvmAccountLinksRequest>): ListSvmAccountLinksRequest {
    const message = createBaseListSvmAccountLinksRequest();
    message.cosmos_addr = object.cosmos_addr ?? "";
    message.svm_addr = object.svm_addr ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListSvmAccountLinksResponse(): ListSvmAccountLinksResponse {
  return { pagination: undefined, account_links: [] };
}

export const ListSvmAccountLinksResponse = {
  $type: "flux.indexer.explorer.ListSvmAccountLinksResponse" as const,

  encode(message: ListSvmAccountLinksResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.account_links) {
      AccountLink.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSvmAccountLinksResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSvmAccountLinksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.account_links.push(AccountLink.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSvmAccountLinksResponse {
    return {
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
      account_links: globalThis.Array.isArray(object?.account_links)
        ? object.account_links.map((e: any) => AccountLink.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListSvmAccountLinksResponse): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    if (message.account_links?.length) {
      obj.account_links = message.account_links.map((e) => AccountLink.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListSvmAccountLinksResponse>): ListSvmAccountLinksResponse {
    return ListSvmAccountLinksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSvmAccountLinksResponse>): ListSvmAccountLinksResponse {
    const message = createBaseListSvmAccountLinksResponse();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    message.account_links = object.account_links?.map((e) => AccountLink.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStreamSvmAccountLinkRequest(): StreamSvmAccountLinkRequest {
  return { cosmos_address: "", svm_address: "" };
}

export const StreamSvmAccountLinkRequest = {
  $type: "flux.indexer.explorer.StreamSvmAccountLinkRequest" as const,

  encode(message: StreamSvmAccountLinkRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cosmos_address !== "") {
      writer.uint32(10).string(message.cosmos_address);
    }
    if (message.svm_address !== "") {
      writer.uint32(18).string(message.svm_address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamSvmAccountLinkRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamSvmAccountLinkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cosmos_address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.svm_address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamSvmAccountLinkRequest {
    return {
      cosmos_address: isSet(object.cosmos_address) ? globalThis.String(object.cosmos_address) : "",
      svm_address: isSet(object.svm_address) ? globalThis.String(object.svm_address) : "",
    };
  },

  toJSON(message: StreamSvmAccountLinkRequest): unknown {
    const obj: any = {};
    if (message.cosmos_address !== undefined) {
      obj.cosmos_address = message.cosmos_address;
    }
    if (message.svm_address !== undefined) {
      obj.svm_address = message.svm_address;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamSvmAccountLinkRequest>): StreamSvmAccountLinkRequest {
    return StreamSvmAccountLinkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamSvmAccountLinkRequest>): StreamSvmAccountLinkRequest {
    const message = createBaseStreamSvmAccountLinkRequest();
    message.cosmos_address = object.cosmos_address ?? "";
    message.svm_address = object.svm_address ?? "";
    return message;
  },
};

function createBaseStreamSvmAccountLinkResponse(): StreamSvmAccountLinkResponse {
  return { height: "0", deleted: "0", account_link: [] };
}

export const StreamSvmAccountLinkResponse = {
  $type: "flux.indexer.explorer.StreamSvmAccountLinkResponse" as const,

  encode(message: StreamSvmAccountLinkResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).uint64(message.height);
    }
    if (message.deleted !== "0") {
      writer.uint32(16).uint64(message.deleted);
    }
    for (const v of message.account_link) {
      AccountLink.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamSvmAccountLinkResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamSvmAccountLinkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.account_link.push(AccountLink.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamSvmAccountLinkResponse {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "0",
      account_link: globalThis.Array.isArray(object?.account_link)
        ? object.account_link.map((e: any) => AccountLink.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamSvmAccountLinkResponse): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.account_link?.length) {
      obj.account_link = message.account_link.map((e) => AccountLink.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StreamSvmAccountLinkResponse>): StreamSvmAccountLinkResponse {
    return StreamSvmAccountLinkResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamSvmAccountLinkResponse>): StreamSvmAccountLinkResponse {
    const message = createBaseStreamSvmAccountLinkResponse();
    message.height = object.height ?? "0";
    message.deleted = object.deleted ?? "0";
    message.account_link = object.account_link?.map((e) => AccountLink.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListDriftOrdersRequest(): ListDriftOrdersRequest {
  return { market_name: "" };
}

export const ListDriftOrdersRequest = {
  $type: "flux.indexer.explorer.ListDriftOrdersRequest" as const,

  encode(message: ListDriftOrdersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.market_name !== "") {
      writer.uint32(10).string(message.market_name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDriftOrdersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDriftOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.market_name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDriftOrdersRequest {
    return { market_name: isSet(object.market_name) ? globalThis.String(object.market_name) : "" };
  },

  toJSON(message: ListDriftOrdersRequest): unknown {
    const obj: any = {};
    if (message.market_name !== undefined) {
      obj.market_name = message.market_name;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDriftOrdersRequest>): ListDriftOrdersRequest {
    return ListDriftOrdersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDriftOrdersRequest>): ListDriftOrdersRequest {
    const message = createBaseListDriftOrdersRequest();
    message.market_name = object.market_name ?? "";
    return message;
  },
};

function createBaseListDriftOrdersResponse(): ListDriftOrdersResponse {
  return { orders: [], height: "0" };
}

export const ListDriftOrdersResponse = {
  $type: "flux.indexer.explorer.ListDriftOrdersResponse" as const,

  encode(message: ListDriftOrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orders) {
      DriftOrder.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.height !== "0") {
      writer.uint32(16).uint64(message.height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDriftOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDriftOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orders.push(DriftOrder.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDriftOrdersResponse {
    return {
      orders: globalThis.Array.isArray(object?.orders) ? object.orders.map((e: any) => DriftOrder.fromJSON(e)) : [],
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
    };
  },

  toJSON(message: ListDriftOrdersResponse): unknown {
    const obj: any = {};
    if (message.orders?.length) {
      obj.orders = message.orders.map((e) => DriftOrder.toJSON(e));
    }
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDriftOrdersResponse>): ListDriftOrdersResponse {
    return ListDriftOrdersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDriftOrdersResponse>): ListDriftOrdersResponse {
    const message = createBaseListDriftOrdersResponse();
    message.orders = object.orders?.map((e) => DriftOrder.fromPartial(e)) || [];
    message.height = object.height ?? "0";
    return message;
  },
};

function createBaseListFillableDriftJITOrdersRequest(): ListFillableDriftJITOrdersRequest {
  return { market_name: "", worst_price: "0", direction: 0, quantity: "0", exclude_owner: "" };
}

export const ListFillableDriftJITOrdersRequest = {
  $type: "flux.indexer.explorer.ListFillableDriftJITOrdersRequest" as const,

  encode(message: ListFillableDriftJITOrdersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.market_name !== "") {
      writer.uint32(10).string(message.market_name);
    }
    if (message.worst_price !== "0") {
      writer.uint32(16).uint64(message.worst_price);
    }
    if (message.direction !== 0) {
      writer.uint32(24).int32(message.direction);
    }
    if (message.quantity !== "0") {
      writer.uint32(32).uint64(message.quantity);
    }
    if (message.exclude_owner !== "") {
      writer.uint32(42).string(message.exclude_owner);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListFillableDriftJITOrdersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFillableDriftJITOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.market_name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.worst_price = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.quantity = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.exclude_owner = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFillableDriftJITOrdersRequest {
    return {
      market_name: isSet(object.market_name) ? globalThis.String(object.market_name) : "",
      worst_price: isSet(object.worst_price) ? globalThis.String(object.worst_price) : "0",
      direction: isSet(object.direction) ? orderDirectionFromJSON(object.direction) : 0,
      quantity: isSet(object.quantity) ? globalThis.String(object.quantity) : "0",
      exclude_owner: isSet(object.exclude_owner) ? globalThis.String(object.exclude_owner) : "",
    };
  },

  toJSON(message: ListFillableDriftJITOrdersRequest): unknown {
    const obj: any = {};
    if (message.market_name !== undefined) {
      obj.market_name = message.market_name;
    }
    if (message.worst_price !== undefined) {
      obj.worst_price = message.worst_price;
    }
    if (message.direction !== undefined) {
      obj.direction = orderDirectionToJSON(message.direction);
    }
    if (message.quantity !== undefined) {
      obj.quantity = message.quantity;
    }
    if (message.exclude_owner !== undefined) {
      obj.exclude_owner = message.exclude_owner;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFillableDriftJITOrdersRequest>): ListFillableDriftJITOrdersRequest {
    return ListFillableDriftJITOrdersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFillableDriftJITOrdersRequest>): ListFillableDriftJITOrdersRequest {
    const message = createBaseListFillableDriftJITOrdersRequest();
    message.market_name = object.market_name ?? "";
    message.worst_price = object.worst_price ?? "0";
    message.direction = object.direction ?? 0;
    message.quantity = object.quantity ?? "0";
    message.exclude_owner = object.exclude_owner ?? "";
    return message;
  },
};

function createBaseListFillableDriftJITOrdersResponse(): ListFillableDriftJITOrdersResponse {
  return { fillable_orders: [], height: "0" };
}

export const ListFillableDriftJITOrdersResponse = {
  $type: "flux.indexer.explorer.ListFillableDriftJITOrdersResponse" as const,

  encode(message: ListFillableDriftJITOrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.fillable_orders) {
      DriftOrder.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.height !== "0") {
      writer.uint32(16).uint64(message.height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListFillableDriftJITOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFillableDriftJITOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fillable_orders.push(DriftOrder.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFillableDriftJITOrdersResponse {
    return {
      fillable_orders: globalThis.Array.isArray(object?.fillable_orders)
        ? object.fillable_orders.map((e: any) => DriftOrder.fromJSON(e))
        : [],
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
    };
  },

  toJSON(message: ListFillableDriftJITOrdersResponse): unknown {
    const obj: any = {};
    if (message.fillable_orders?.length) {
      obj.fillable_orders = message.fillable_orders.map((e) => DriftOrder.toJSON(e));
    }
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFillableDriftJITOrdersResponse>): ListFillableDriftJITOrdersResponse {
    return ListFillableDriftJITOrdersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFillableDriftJITOrdersResponse>): ListFillableDriftJITOrdersResponse {
    const message = createBaseListFillableDriftJITOrdersResponse();
    message.fillable_orders = object.fillable_orders?.map((e) => DriftOrder.fromPartial(e)) || [];
    message.height = object.height ?? "0";
    return message;
  },
};

function createBaseDriftOrder(): DriftOrder {
  return {
    subaccount_address: "",
    owner_address: "",
    price: "0",
    total_quantity: "0",
    market_name: "",
    order_id: 0,
    auction_start_price: "0",
    auction_end_price: "0",
    created_height: "0",
    auction_duration: 0,
    expired_at: "0",
    direction: 0,
    fillable_quantity: "0",
    updated_height: "0",
  };
}

export const DriftOrder = {
  $type: "flux.indexer.explorer.DriftOrder" as const,

  encode(message: DriftOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccount_address !== "") {
      writer.uint32(10).string(message.subaccount_address);
    }
    if (message.owner_address !== "") {
      writer.uint32(18).string(message.owner_address);
    }
    if (message.price !== "0") {
      writer.uint32(24).uint64(message.price);
    }
    if (message.total_quantity !== "0") {
      writer.uint32(32).uint64(message.total_quantity);
    }
    if (message.market_name !== "") {
      writer.uint32(42).string(message.market_name);
    }
    if (message.order_id !== 0) {
      writer.uint32(48).uint32(message.order_id);
    }
    if (message.auction_start_price !== "0") {
      writer.uint32(56).int64(message.auction_start_price);
    }
    if (message.auction_end_price !== "0") {
      writer.uint32(64).int64(message.auction_end_price);
    }
    if (message.created_height !== "0") {
      writer.uint32(72).uint64(message.created_height);
    }
    if (message.auction_duration !== 0) {
      writer.uint32(80).uint32(message.auction_duration);
    }
    if (message.expired_at !== "0") {
      writer.uint32(88).int64(message.expired_at);
    }
    if (message.direction !== 0) {
      writer.uint32(96).int32(message.direction);
    }
    if (message.fillable_quantity !== "0") {
      writer.uint32(104).uint64(message.fillable_quantity);
    }
    if (message.updated_height !== "0") {
      writer.uint32(112).uint64(message.updated_height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DriftOrder {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDriftOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subaccount_address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.owner_address = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.price = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.total_quantity = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.market_name = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.order_id = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.auction_start_price = longToString(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.auction_end_price = longToString(reader.int64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.created_height = longToString(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.auction_duration = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.expired_at = longToString(reader.int64() as Long);
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.fillable_quantity = longToString(reader.uint64() as Long);
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.updated_height = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DriftOrder {
    return {
      subaccount_address: isSet(object.subaccount_address) ? globalThis.String(object.subaccount_address) : "",
      owner_address: isSet(object.owner_address) ? globalThis.String(object.owner_address) : "",
      price: isSet(object.price) ? globalThis.String(object.price) : "0",
      total_quantity: isSet(object.total_quantity) ? globalThis.String(object.total_quantity) : "0",
      market_name: isSet(object.market_name) ? globalThis.String(object.market_name) : "",
      order_id: isSet(object.order_id) ? globalThis.Number(object.order_id) : 0,
      auction_start_price: isSet(object.auction_start_price) ? globalThis.String(object.auction_start_price) : "0",
      auction_end_price: isSet(object.auction_end_price) ? globalThis.String(object.auction_end_price) : "0",
      created_height: isSet(object.created_height) ? globalThis.String(object.created_height) : "0",
      auction_duration: isSet(object.auction_duration) ? globalThis.Number(object.auction_duration) : 0,
      expired_at: isSet(object.expired_at) ? globalThis.String(object.expired_at) : "0",
      direction: isSet(object.direction) ? orderDirectionFromJSON(object.direction) : 0,
      fillable_quantity: isSet(object.fillable_quantity) ? globalThis.String(object.fillable_quantity) : "0",
      updated_height: isSet(object.updated_height) ? globalThis.String(object.updated_height) : "0",
    };
  },

  toJSON(message: DriftOrder): unknown {
    const obj: any = {};
    if (message.subaccount_address !== undefined) {
      obj.subaccount_address = message.subaccount_address;
    }
    if (message.owner_address !== undefined) {
      obj.owner_address = message.owner_address;
    }
    if (message.price !== undefined) {
      obj.price = message.price;
    }
    if (message.total_quantity !== undefined) {
      obj.total_quantity = message.total_quantity;
    }
    if (message.market_name !== undefined) {
      obj.market_name = message.market_name;
    }
    if (message.order_id !== undefined) {
      obj.order_id = Math.round(message.order_id);
    }
    if (message.auction_start_price !== undefined) {
      obj.auction_start_price = message.auction_start_price;
    }
    if (message.auction_end_price !== undefined) {
      obj.auction_end_price = message.auction_end_price;
    }
    if (message.created_height !== undefined) {
      obj.created_height = message.created_height;
    }
    if (message.auction_duration !== undefined) {
      obj.auction_duration = Math.round(message.auction_duration);
    }
    if (message.expired_at !== undefined) {
      obj.expired_at = message.expired_at;
    }
    if (message.direction !== undefined) {
      obj.direction = orderDirectionToJSON(message.direction);
    }
    if (message.fillable_quantity !== undefined) {
      obj.fillable_quantity = message.fillable_quantity;
    }
    if (message.updated_height !== undefined) {
      obj.updated_height = message.updated_height;
    }
    return obj;
  },

  create(base?: DeepPartial<DriftOrder>): DriftOrder {
    return DriftOrder.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DriftOrder>): DriftOrder {
    const message = createBaseDriftOrder();
    message.subaccount_address = object.subaccount_address ?? "";
    message.owner_address = object.owner_address ?? "";
    message.price = object.price ?? "0";
    message.total_quantity = object.total_quantity ?? "0";
    message.market_name = object.market_name ?? "";
    message.order_id = object.order_id ?? 0;
    message.auction_start_price = object.auction_start_price ?? "0";
    message.auction_end_price = object.auction_end_price ?? "0";
    message.created_height = object.created_height ?? "0";
    message.auction_duration = object.auction_duration ?? 0;
    message.expired_at = object.expired_at ?? "0";
    message.direction = object.direction ?? 0;
    message.fillable_quantity = object.fillable_quantity ?? "0";
    message.updated_height = object.updated_height ?? "0";
    return message;
  },
};

function createBaseStreamDriftOrdersRequest(): StreamDriftOrdersRequest {
  return { market_name: "", price: "0", direction: "" };
}

export const StreamDriftOrdersRequest = {
  $type: "flux.indexer.explorer.StreamDriftOrdersRequest" as const,

  encode(message: StreamDriftOrdersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.market_name !== "") {
      writer.uint32(10).string(message.market_name);
    }
    if (message.price !== "0") {
      writer.uint32(16).uint64(message.price);
    }
    if (message.direction !== "") {
      writer.uint32(26).string(message.direction);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamDriftOrdersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamDriftOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.market_name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.price = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.direction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamDriftOrdersRequest {
    return {
      market_name: isSet(object.market_name) ? globalThis.String(object.market_name) : "",
      price: isSet(object.price) ? globalThis.String(object.price) : "0",
      direction: isSet(object.direction) ? globalThis.String(object.direction) : "",
    };
  },

  toJSON(message: StreamDriftOrdersRequest): unknown {
    const obj: any = {};
    if (message.market_name !== undefined) {
      obj.market_name = message.market_name;
    }
    if (message.price !== undefined) {
      obj.price = message.price;
    }
    if (message.direction !== undefined) {
      obj.direction = message.direction;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamDriftOrdersRequest>): StreamDriftOrdersRequest {
    return StreamDriftOrdersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamDriftOrdersRequest>): StreamDriftOrdersRequest {
    const message = createBaseStreamDriftOrdersRequest();
    message.market_name = object.market_name ?? "";
    message.price = object.price ?? "0";
    message.direction = object.direction ?? "";
    return message;
  },
};

function createBaseStreamDriftOrdersResponse(): StreamDriftOrdersResponse {
  return { height: "0", deleted: "0", order: undefined };
}

export const StreamDriftOrdersResponse = {
  $type: "flux.indexer.explorer.StreamDriftOrdersResponse" as const,

  encode(message: StreamDriftOrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).uint64(message.height);
    }
    if (message.deleted !== "0") {
      writer.uint32(16).uint64(message.deleted);
    }
    if (message.order !== undefined) {
      DriftOrder.encode(message.order, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamDriftOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamDriftOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.order = DriftOrder.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamDriftOrdersResponse {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "0",
      order: isSet(object.order) ? DriftOrder.fromJSON(object.order) : undefined,
    };
  },

  toJSON(message: StreamDriftOrdersResponse): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.order !== undefined) {
      obj.order = DriftOrder.toJSON(message.order);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamDriftOrdersResponse>): StreamDriftOrdersResponse {
    return StreamDriftOrdersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamDriftOrdersResponse>): StreamDriftOrdersResponse {
    const message = createBaseStreamDriftOrdersResponse();
    message.height = object.height ?? "0";
    message.deleted = object.deleted ?? "0";
    message.order = (object.order !== undefined && object.order !== null)
      ? DriftOrder.fromPartial(object.order)
      : undefined;
    return message;
  },
};

function createBaseListTxsRequest(): ListTxsRequest {
  return { start_block: "0", end_block: "0", start_time: "0", end_time: "0", pagination: undefined };
}

export const ListTxsRequest = {
  $type: "flux.indexer.explorer.ListTxsRequest" as const,

  encode(message: ListTxsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.start_block !== "0") {
      writer.uint32(8).int64(message.start_block);
    }
    if (message.end_block !== "0") {
      writer.uint32(16).int64(message.end_block);
    }
    if (message.start_time !== "0") {
      writer.uint32(24).int64(message.start_time);
    }
    if (message.end_time !== "0") {
      writer.uint32(32).int64(message.end_time);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTxsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTxsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start_block = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.end_block = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.start_time = longToString(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.end_time = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTxsRequest {
    return {
      start_block: isSet(object.start_block) ? globalThis.String(object.start_block) : "0",
      end_block: isSet(object.end_block) ? globalThis.String(object.end_block) : "0",
      start_time: isSet(object.start_time) ? globalThis.String(object.start_time) : "0",
      end_time: isSet(object.end_time) ? globalThis.String(object.end_time) : "0",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListTxsRequest): unknown {
    const obj: any = {};
    if (message.start_block !== undefined) {
      obj.start_block = message.start_block;
    }
    if (message.end_block !== undefined) {
      obj.end_block = message.end_block;
    }
    if (message.start_time !== undefined) {
      obj.start_time = message.start_time;
    }
    if (message.end_time !== undefined) {
      obj.end_time = message.end_time;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListTxsRequest>): ListTxsRequest {
    return ListTxsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTxsRequest>): ListTxsRequest {
    const message = createBaseListTxsRequest();
    message.start_block = object.start_block ?? "0";
    message.end_block = object.end_block ?? "0";
    message.start_time = object.start_time ?? "0";
    message.end_time = object.end_time ?? "0";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListTxsResponse(): ListTxsResponse {
  return { pagination: undefined, txs: [] };
}

export const ListTxsResponse = {
  $type: "flux.indexer.explorer.ListTxsResponse" as const,

  encode(message: ListTxsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.txs) {
      Tx.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTxsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTxsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.txs.push(Tx.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTxsResponse {
    return {
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
      txs: globalThis.Array.isArray(object?.txs) ? object.txs.map((e: any) => Tx.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListTxsResponse): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    if (message.txs?.length) {
      obj.txs = message.txs.map((e) => Tx.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListTxsResponse>): ListTxsResponse {
    return ListTxsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTxsResponse>): ListTxsResponse {
    const message = createBaseListTxsResponse();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    message.txs = object.txs?.map((e) => Tx.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetTxRequest(): GetTxRequest {
  return { tx_hash: "" };
}

export const GetTxRequest = {
  $type: "flux.indexer.explorer.GetTxRequest" as const,

  encode(message: GetTxRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tx_hash !== "") {
      writer.uint32(10).string(message.tx_hash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTxRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tx_hash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTxRequest {
    return { tx_hash: isSet(object.tx_hash) ? globalThis.String(object.tx_hash) : "" };
  },

  toJSON(message: GetTxRequest): unknown {
    const obj: any = {};
    if (message.tx_hash !== undefined) {
      obj.tx_hash = message.tx_hash;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTxRequest>): GetTxRequest {
    return GetTxRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTxRequest>): GetTxRequest {
    const message = createBaseGetTxRequest();
    message.tx_hash = object.tx_hash ?? "";
    return message;
  },
};

function createBaseTx(): Tx {
  return { height: "0", time: "0", hash: "", tx: undefined, tx_result: undefined, tx_index: "0" };
}

export const Tx = {
  $type: "flux.indexer.explorer.Tx" as const,

  encode(message: Tx, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).int64(message.height);
    }
    if (message.time !== "0") {
      writer.uint32(16).int64(message.time);
    }
    if (message.hash !== "") {
      writer.uint32(26).string(message.hash);
    }
    if (message.tx !== undefined) {
      Tx1.encode(message.tx, writer.uint32(34).fork()).ldelim();
    }
    if (message.tx_result !== undefined) {
      ExecTxResult.encode(message.tx_result, writer.uint32(42).fork()).ldelim();
    }
    if (message.tx_index !== "0") {
      writer.uint32(48).int64(message.tx_index);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Tx {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTx();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.time = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tx = Tx1.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tx_result = ExecTxResult.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.tx_index = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tx {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      time: isSet(object.time) ? globalThis.String(object.time) : "0",
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      tx: isSet(object.tx) ? Tx1.fromJSON(object.tx) : undefined,
      tx_result: isSet(object.tx_result) ? ExecTxResult.fromJSON(object.tx_result) : undefined,
      tx_index: isSet(object.tx_index) ? globalThis.String(object.tx_index) : "0",
    };
  },

  toJSON(message: Tx): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.time !== undefined) {
      obj.time = message.time;
    }
    if (message.hash !== undefined) {
      obj.hash = message.hash;
    }
    if (message.tx !== undefined) {
      obj.tx = Tx1.toJSON(message.tx);
    }
    if (message.tx_result !== undefined) {
      obj.tx_result = ExecTxResult.toJSON(message.tx_result);
    }
    if (message.tx_index !== undefined) {
      obj.tx_index = message.tx_index;
    }
    return obj;
  },

  create(base?: DeepPartial<Tx>): Tx {
    return Tx.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Tx>): Tx {
    const message = createBaseTx();
    message.height = object.height ?? "0";
    message.time = object.time ?? "0";
    message.hash = object.hash ?? "";
    message.tx = (object.tx !== undefined && object.tx !== null) ? Tx1.fromPartial(object.tx) : undefined;
    message.tx_result = (object.tx_result !== undefined && object.tx_result !== null)
      ? ExecTxResult.fromPartial(object.tx_result)
      : undefined;
    message.tx_index = object.tx_index ?? "0";
    return message;
  },
};

function createBaseGetTxResponse(): GetTxResponse {
  return { tx: undefined };
}

export const GetTxResponse = {
  $type: "flux.indexer.explorer.GetTxResponse" as const,

  encode(message: GetTxResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tx !== undefined) {
      Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTxResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tx = Tx.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTxResponse {
    return { tx: isSet(object.tx) ? Tx.fromJSON(object.tx) : undefined };
  },

  toJSON(message: GetTxResponse): unknown {
    const obj: any = {};
    if (message.tx !== undefined) {
      obj.tx = Tx.toJSON(message.tx);
    }
    return obj;
  },

  create(base?: DeepPartial<GetTxResponse>): GetTxResponse {
    return GetTxResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTxResponse>): GetTxResponse {
    const message = createBaseGetTxResponse();
    message.tx = (object.tx !== undefined && object.tx !== null) ? Tx.fromPartial(object.tx) : undefined;
    return message;
  },
};

function createBaseListAccountTxsRequest(): ListAccountTxsRequest {
  return { account: "", pagination: undefined };
}

export const ListAccountTxsRequest = {
  $type: "flux.indexer.explorer.ListAccountTxsRequest" as const,

  encode(message: ListAccountTxsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListAccountTxsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAccountTxsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAccountTxsRequest {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListAccountTxsRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = message.account;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListAccountTxsRequest>): ListAccountTxsRequest {
    return ListAccountTxsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAccountTxsRequest>): ListAccountTxsRequest {
    const message = createBaseListAccountTxsRequest();
    message.account = object.account ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListAccountTxsResponse(): ListAccountTxsResponse {
  return { pagination: undefined, txs: [] };
}

export const ListAccountTxsResponse = {
  $type: "flux.indexer.explorer.ListAccountTxsResponse" as const,

  encode(message: ListAccountTxsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.txs) {
      Tx.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListAccountTxsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAccountTxsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.txs.push(Tx.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAccountTxsResponse {
    return {
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
      txs: globalThis.Array.isArray(object?.txs) ? object.txs.map((e: any) => Tx.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListAccountTxsResponse): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    if (message.txs?.length) {
      obj.txs = message.txs.map((e) => Tx.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListAccountTxsResponse>): ListAccountTxsResponse {
    return ListAccountTxsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAccountTxsResponse>): ListAccountTxsResponse {
    const message = createBaseListAccountTxsResponse();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    message.txs = object.txs?.map((e) => Tx.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListBlocksRequest(): ListBlocksRequest {
  return { start_block: "0", end_block: "0", pagination: undefined };
}

export const ListBlocksRequest = {
  $type: "flux.indexer.explorer.ListBlocksRequest" as const,

  encode(message: ListBlocksRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.start_block !== "0") {
      writer.uint32(8).int64(message.start_block);
    }
    if (message.end_block !== "0") {
      writer.uint32(16).int64(message.end_block);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBlocksRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBlocksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start_block = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.end_block = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBlocksRequest {
    return {
      start_block: isSet(object.start_block) ? globalThis.String(object.start_block) : "0",
      end_block: isSet(object.end_block) ? globalThis.String(object.end_block) : "0",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListBlocksRequest): unknown {
    const obj: any = {};
    if (message.start_block !== undefined) {
      obj.start_block = message.start_block;
    }
    if (message.end_block !== undefined) {
      obj.end_block = message.end_block;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListBlocksRequest>): ListBlocksRequest {
    return ListBlocksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBlocksRequest>): ListBlocksRequest {
    const message = createBaseListBlocksRequest();
    message.start_block = object.start_block ?? "0";
    message.end_block = object.end_block ?? "0";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListBlocksResponse(): ListBlocksResponse {
  return { pagination: undefined, blocks: [] };
}

export const ListBlocksResponse = {
  $type: "flux.indexer.explorer.ListBlocksResponse" as const,

  encode(message: ListBlocksResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.blocks) {
      Block.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBlocksResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBlocksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blocks.push(Block.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBlocksResponse {
    return {
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
      blocks: globalThis.Array.isArray(object?.blocks) ? object.blocks.map((e: any) => Block.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListBlocksResponse): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    if (message.blocks?.length) {
      obj.blocks = message.blocks.map((e) => Block.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListBlocksResponse>): ListBlocksResponse {
    return ListBlocksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBlocksResponse>): ListBlocksResponse {
    const message = createBaseListBlocksResponse();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    message.blocks = object.blocks?.map((e) => Block.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetBlockRequest(): GetBlockRequest {
  return { block_height: "0" };
}

export const GetBlockRequest = {
  $type: "flux.indexer.explorer.GetBlockRequest" as const,

  encode(message: GetBlockRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.block_height !== "0") {
      writer.uint32(8).int64(message.block_height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBlockRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.block_height = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlockRequest {
    return { block_height: isSet(object.block_height) ? globalThis.String(object.block_height) : "0" };
  },

  toJSON(message: GetBlockRequest): unknown {
    const obj: any = {};
    if (message.block_height !== undefined) {
      obj.block_height = message.block_height;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBlockRequest>): GetBlockRequest {
    return GetBlockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBlockRequest>): GetBlockRequest {
    const message = createBaseGetBlockRequest();
    message.block_height = object.block_height ?? "0";
    return message;
  },
};

function createBaseGetBlockResponse(): GetBlockResponse {
  return { block: undefined };
}

export const GetBlockResponse = {
  $type: "flux.indexer.explorer.GetBlockResponse" as const,

  encode(message: GetBlockResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.block !== undefined) {
      Block.encode(message.block, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBlockResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.block = Block.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlockResponse {
    return { block: isSet(object.block) ? Block.fromJSON(object.block) : undefined };
  },

  toJSON(message: GetBlockResponse): unknown {
    const obj: any = {};
    if (message.block !== undefined) {
      obj.block = Block.toJSON(message.block);
    }
    return obj;
  },

  create(base?: DeepPartial<GetBlockResponse>): GetBlockResponse {
    return GetBlockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBlockResponse>): GetBlockResponse {
    const message = createBaseGetBlockResponse();
    message.block = (object.block !== undefined && object.block !== null) ? Block.fromPartial(object.block) : undefined;
    return message;
  },
};

function createBaseStreamTxsRequest(): StreamTxsRequest {
  return { address: "" };
}

export const StreamTxsRequest = {
  $type: "flux.indexer.explorer.StreamTxsRequest" as const,

  encode(message: StreamTxsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamTxsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamTxsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamTxsRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: StreamTxsRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamTxsRequest>): StreamTxsRequest {
    return StreamTxsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamTxsRequest>): StreamTxsRequest {
    const message = createBaseStreamTxsRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseStreamTxsResponse(): StreamTxsResponse {
  return { height: "0", deleted: "0", tx: undefined };
}

export const StreamTxsResponse = {
  $type: "flux.indexer.explorer.StreamTxsResponse" as const,

  encode(message: StreamTxsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).uint64(message.height);
    }
    if (message.deleted !== "0") {
      writer.uint32(16).uint64(message.deleted);
    }
    if (message.tx !== undefined) {
      Tx.encode(message.tx, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamTxsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamTxsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tx = Tx.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamTxsResponse {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "0",
      tx: isSet(object.tx) ? Tx.fromJSON(object.tx) : undefined,
    };
  },

  toJSON(message: StreamTxsResponse): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.tx !== undefined) {
      obj.tx = Tx.toJSON(message.tx);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamTxsResponse>): StreamTxsResponse {
    return StreamTxsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamTxsResponse>): StreamTxsResponse {
    const message = createBaseStreamTxsResponse();
    message.height = object.height ?? "0";
    message.deleted = object.deleted ?? "0";
    message.tx = (object.tx !== undefined && object.tx !== null) ? Tx.fromPartial(object.tx) : undefined;
    return message;
  },
};

function createBaseStreamBlocksRequest(): StreamBlocksRequest {
  return {};
}

export const StreamBlocksRequest = {
  $type: "flux.indexer.explorer.StreamBlocksRequest" as const,

  encode(_: StreamBlocksRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamBlocksRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamBlocksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StreamBlocksRequest {
    return {};
  },

  toJSON(_: StreamBlocksRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<StreamBlocksRequest>): StreamBlocksRequest {
    return StreamBlocksRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<StreamBlocksRequest>): StreamBlocksRequest {
    const message = createBaseStreamBlocksRequest();
    return message;
  },
};

function createBaseStreamBlocksResponse(): StreamBlocksResponse {
  return { height: "0", deleted: "0", block: undefined };
}

export const StreamBlocksResponse = {
  $type: "flux.indexer.explorer.StreamBlocksResponse" as const,

  encode(message: StreamBlocksResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).uint64(message.height);
    }
    if (message.deleted !== "0") {
      writer.uint32(16).uint64(message.deleted);
    }
    if (message.block !== undefined) {
      Block.encode(message.block, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamBlocksResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamBlocksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.block = Block.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamBlocksResponse {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "0",
      block: isSet(object.block) ? Block.fromJSON(object.block) : undefined,
    };
  },

  toJSON(message: StreamBlocksResponse): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.block !== undefined) {
      obj.block = Block.toJSON(message.block);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamBlocksResponse>): StreamBlocksResponse {
    return StreamBlocksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamBlocksResponse>): StreamBlocksResponse {
    const message = createBaseStreamBlocksResponse();
    message.height = object.height ?? "0";
    message.deleted = object.deleted ?? "0";
    message.block = (object.block !== undefined && object.block !== null) ? Block.fromPartial(object.block) : undefined;
    return message;
  },
};

function createBaseContract(): Contract {
  return {
    address: "",
    plane: 0,
    name: "",
    creator: "",
    created_at: "0",
    last_execution_time: "0",
    execution_count: "0",
    init_msg: new Uint8Array(0),
    code_id: "0",
    tx_hash: "",
    admin: "",
    height: "0",
    contract_index: "0",
  };
}

export const Contract = {
  $type: "flux.indexer.explorer.Contract" as const,

  encode(message: Contract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.plane !== 0) {
      writer.uint32(16).int32(message.plane);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.creator !== "") {
      writer.uint32(34).string(message.creator);
    }
    if (message.created_at !== "0") {
      writer.uint32(40).int64(message.created_at);
    }
    if (message.last_execution_time !== "0") {
      writer.uint32(48).int64(message.last_execution_time);
    }
    if (message.execution_count !== "0") {
      writer.uint32(56).uint64(message.execution_count);
    }
    if (message.init_msg.length !== 0) {
      writer.uint32(66).bytes(message.init_msg);
    }
    if (message.code_id !== "0") {
      writer.uint32(72).uint64(message.code_id);
    }
    if (message.tx_hash !== "") {
      writer.uint32(82).string(message.tx_hash);
    }
    if (message.admin !== "") {
      writer.uint32(90).string(message.admin);
    }
    if (message.height !== "0") {
      writer.uint32(96).int64(message.height);
    }
    if (message.contract_index !== "0") {
      writer.uint32(104).int64(message.contract_index);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Contract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.plane = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.creator = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.created_at = longToString(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.last_execution_time = longToString(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.execution_count = longToString(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.init_msg = reader.bytes();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.code_id = longToString(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.tx_hash = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.admin = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.height = longToString(reader.int64() as Long);
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.contract_index = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Contract {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      plane: isSet(object.plane) ? planeFromJSON(object.plane) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      created_at: isSet(object.created_at) ? globalThis.String(object.created_at) : "0",
      last_execution_time: isSet(object.last_execution_time) ? globalThis.String(object.last_execution_time) : "0",
      execution_count: isSet(object.execution_count) ? globalThis.String(object.execution_count) : "0",
      init_msg: isSet(object.init_msg) ? bytesFromBase64(object.init_msg) : new Uint8Array(0),
      code_id: isSet(object.code_id) ? globalThis.String(object.code_id) : "0",
      tx_hash: isSet(object.tx_hash) ? globalThis.String(object.tx_hash) : "",
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      contract_index: isSet(object.contract_index) ? globalThis.String(object.contract_index) : "0",
    };
  },

  toJSON(message: Contract): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.plane !== undefined) {
      obj.plane = planeToJSON(message.plane);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.creator !== undefined) {
      obj.creator = message.creator;
    }
    if (message.created_at !== undefined) {
      obj.created_at = message.created_at;
    }
    if (message.last_execution_time !== undefined) {
      obj.last_execution_time = message.last_execution_time;
    }
    if (message.execution_count !== undefined) {
      obj.execution_count = message.execution_count;
    }
    if (message.init_msg !== undefined) {
      obj.init_msg = base64FromBytes(message.init_msg);
    }
    if (message.code_id !== undefined) {
      obj.code_id = message.code_id;
    }
    if (message.tx_hash !== undefined) {
      obj.tx_hash = message.tx_hash;
    }
    if (message.admin !== undefined) {
      obj.admin = message.admin;
    }
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.contract_index !== undefined) {
      obj.contract_index = message.contract_index;
    }
    return obj;
  },

  create(base?: DeepPartial<Contract>): Contract {
    return Contract.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Contract>): Contract {
    const message = createBaseContract();
    message.address = object.address ?? "";
    message.plane = object.plane ?? 0;
    message.name = object.name ?? "";
    message.creator = object.creator ?? "";
    message.created_at = object.created_at ?? "0";
    message.last_execution_time = object.last_execution_time ?? "0";
    message.execution_count = object.execution_count ?? "0";
    message.init_msg = object.init_msg ?? new Uint8Array(0);
    message.code_id = object.code_id ?? "0";
    message.tx_hash = object.tx_hash ?? "";
    message.admin = object.admin ?? "";
    message.height = object.height ?? "0";
    message.contract_index = object.contract_index ?? "0";
    return message;
  },
};

function createBaseListContractsRequest(): ListContractsRequest {
  return { pagination: undefined, plane: 0 };
}

export const ListContractsRequest = {
  $type: "flux.indexer.explorer.ListContractsRequest" as const,

  encode(message: ListContractsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    if (message.plane !== 0) {
      writer.uint32(16).int32(message.plane);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListContractsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListContractsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.plane = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListContractsRequest {
    return {
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
      plane: isSet(object.plane) ? planeFromJSON(object.plane) : 0,
    };
  },

  toJSON(message: ListContractsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    if (message.plane !== undefined) {
      obj.plane = planeToJSON(message.plane);
    }
    return obj;
  },

  create(base?: DeepPartial<ListContractsRequest>): ListContractsRequest {
    return ListContractsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListContractsRequest>): ListContractsRequest {
    const message = createBaseListContractsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    message.plane = object.plane ?? 0;
    return message;
  },
};

function createBaseListContractsResponse(): ListContractsResponse {
  return { contracts: [], pagination: undefined };
}

export const ListContractsResponse = {
  $type: "flux.indexer.explorer.ListContractsResponse" as const,

  encode(message: ListContractsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.contracts) {
      Contract.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListContractsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListContractsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contracts.push(Contract.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListContractsResponse {
    return {
      contracts: globalThis.Array.isArray(object?.contracts)
        ? object.contracts.map((e: any) => Contract.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListContractsResponse): unknown {
    const obj: any = {};
    if (message.contracts?.length) {
      obj.contracts = message.contracts.map((e) => Contract.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListContractsResponse>): ListContractsResponse {
    return ListContractsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListContractsResponse>): ListContractsResponse {
    const message = createBaseListContractsResponse();
    message.contracts = object.contracts?.map((e) => Contract.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetContractRequest(): GetContractRequest {
  return { address: "", plane: 0 };
}

export const GetContractRequest = {
  $type: "flux.indexer.explorer.GetContractRequest" as const,

  encode(message: GetContractRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.plane !== 0) {
      writer.uint32(16).int32(message.plane);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContractRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.plane = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContractRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      plane: isSet(object.plane) ? planeFromJSON(object.plane) : 0,
    };
  },

  toJSON(message: GetContractRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.plane !== undefined) {
      obj.plane = planeToJSON(message.plane);
    }
    return obj;
  },

  create(base?: DeepPartial<GetContractRequest>): GetContractRequest {
    return GetContractRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetContractRequest>): GetContractRequest {
    const message = createBaseGetContractRequest();
    message.address = object.address ?? "";
    message.plane = object.plane ?? 0;
    return message;
  },
};

function createBaseGetContractResponse(): GetContractResponse {
  return { contract: undefined };
}

export const GetContractResponse = {
  $type: "flux.indexer.explorer.GetContractResponse" as const,

  encode(message: GetContractResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contract !== undefined) {
      Contract.encode(message.contract, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContractResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contract = Contract.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContractResponse {
    return { contract: isSet(object.contract) ? Contract.fromJSON(object.contract) : undefined };
  },

  toJSON(message: GetContractResponse): unknown {
    const obj: any = {};
    if (message.contract !== undefined) {
      obj.contract = Contract.toJSON(message.contract);
    }
    return obj;
  },

  create(base?: DeepPartial<GetContractResponse>): GetContractResponse {
    return GetContractResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetContractResponse>): GetContractResponse {
    const message = createBaseGetContractResponse();
    message.contract = (object.contract !== undefined && object.contract !== null)
      ? Contract.fromPartial(object.contract)
      : undefined;
    return message;
  },
};

function createBaseStreamContractRequest(): StreamContractRequest {
  return { plane: 0 };
}

export const StreamContractRequest = {
  $type: "flux.indexer.explorer.StreamContractRequest" as const,

  encode(message: StreamContractRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.plane !== 0) {
      writer.uint32(8).int32(message.plane);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamContractRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.plane = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamContractRequest {
    return { plane: isSet(object.plane) ? planeFromJSON(object.plane) : 0 };
  },

  toJSON(message: StreamContractRequest): unknown {
    const obj: any = {};
    if (message.plane !== undefined) {
      obj.plane = planeToJSON(message.plane);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamContractRequest>): StreamContractRequest {
    return StreamContractRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamContractRequest>): StreamContractRequest {
    const message = createBaseStreamContractRequest();
    message.plane = object.plane ?? 0;
    return message;
  },
};

function createBaseStreamContractResponse(): StreamContractResponse {
  return { height: "0", deleted: "0", contract: undefined };
}

export const StreamContractResponse = {
  $type: "flux.indexer.explorer.StreamContractResponse" as const,

  encode(message: StreamContractResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).uint64(message.height);
    }
    if (message.deleted !== "0") {
      writer.uint32(16).uint64(message.deleted);
    }
    if (message.contract !== undefined) {
      Contract.encode(message.contract, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamContractResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contract = Contract.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamContractResponse {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "0",
      contract: isSet(object.contract) ? Contract.fromJSON(object.contract) : undefined,
    };
  },

  toJSON(message: StreamContractResponse): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.contract !== undefined) {
      obj.contract = Contract.toJSON(message.contract);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamContractResponse>): StreamContractResponse {
    return StreamContractResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamContractResponse>): StreamContractResponse {
    const message = createBaseStreamContractResponse();
    message.height = object.height ?? "0";
    message.deleted = object.deleted ?? "0";
    message.contract = (object.contract !== undefined && object.contract !== null)
      ? Contract.fromPartial(object.contract)
      : undefined;
    return message;
  },
};

function createBaseListDumpsadCoinsRequest(): ListDumpsadCoinsRequest {
  return { pagination: undefined };
}

export const ListDumpsadCoinsRequest = {
  $type: "flux.indexer.explorer.ListDumpsadCoinsRequest" as const,

  encode(message: ListDumpsadCoinsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDumpsadCoinsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDumpsadCoinsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDumpsadCoinsRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: ListDumpsadCoinsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListDumpsadCoinsRequest>): ListDumpsadCoinsRequest {
    return ListDumpsadCoinsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDumpsadCoinsRequest>): ListDumpsadCoinsRequest {
    const message = createBaseListDumpsadCoinsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseDumpsadCoin(): DumpsadCoin {
  return {
    denom: "",
    symbol: "",
    name: "",
    description: "",
    logo: "",
    vm: "",
    cron_id: "",
    solver_id: "",
    current_price: "",
    height: "0",
    pool_id: "",
    curve_sol_amount: "",
    market_cap: "",
  };
}

export const DumpsadCoin = {
  $type: "flux.indexer.explorer.DumpsadCoin" as const,

  encode(message: DumpsadCoin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.logo !== "") {
      writer.uint32(42).string(message.logo);
    }
    if (message.vm !== "") {
      writer.uint32(50).string(message.vm);
    }
    if (message.cron_id !== "") {
      writer.uint32(58).string(message.cron_id);
    }
    if (message.solver_id !== "") {
      writer.uint32(66).string(message.solver_id);
    }
    if (message.current_price !== "") {
      writer.uint32(74).string(message.current_price);
    }
    if (message.height !== "0") {
      writer.uint32(80).int64(message.height);
    }
    if (message.pool_id !== "") {
      writer.uint32(90).string(message.pool_id);
    }
    if (message.curve_sol_amount !== "") {
      writer.uint32(98).string(message.curve_sol_amount);
    }
    if (message.market_cap !== "") {
      writer.uint32(106).string(message.market_cap);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DumpsadCoin {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDumpsadCoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.logo = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.vm = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.cron_id = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.solver_id = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.current_price = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.height = longToString(reader.int64() as Long);
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.pool_id = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.curve_sol_amount = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.market_cap = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DumpsadCoin {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
      vm: isSet(object.vm) ? globalThis.String(object.vm) : "",
      cron_id: isSet(object.cron_id) ? globalThis.String(object.cron_id) : "",
      solver_id: isSet(object.solver_id) ? globalThis.String(object.solver_id) : "",
      current_price: isSet(object.current_price) ? globalThis.String(object.current_price) : "",
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      pool_id: isSet(object.pool_id) ? globalThis.String(object.pool_id) : "",
      curve_sol_amount: isSet(object.curve_sol_amount) ? globalThis.String(object.curve_sol_amount) : "",
      market_cap: isSet(object.market_cap) ? globalThis.String(object.market_cap) : "",
    };
  },

  toJSON(message: DumpsadCoin): unknown {
    const obj: any = {};
    if (message.denom !== undefined) {
      obj.denom = message.denom;
    }
    if (message.symbol !== undefined) {
      obj.symbol = message.symbol;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.logo !== undefined) {
      obj.logo = message.logo;
    }
    if (message.vm !== undefined) {
      obj.vm = message.vm;
    }
    if (message.cron_id !== undefined) {
      obj.cron_id = message.cron_id;
    }
    if (message.solver_id !== undefined) {
      obj.solver_id = message.solver_id;
    }
    if (message.current_price !== undefined) {
      obj.current_price = message.current_price;
    }
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.pool_id !== undefined) {
      obj.pool_id = message.pool_id;
    }
    if (message.curve_sol_amount !== undefined) {
      obj.curve_sol_amount = message.curve_sol_amount;
    }
    if (message.market_cap !== undefined) {
      obj.market_cap = message.market_cap;
    }
    return obj;
  },

  create(base?: DeepPartial<DumpsadCoin>): DumpsadCoin {
    return DumpsadCoin.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DumpsadCoin>): DumpsadCoin {
    const message = createBaseDumpsadCoin();
    message.denom = object.denom ?? "";
    message.symbol = object.symbol ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.logo = object.logo ?? "";
    message.vm = object.vm ?? "";
    message.cron_id = object.cron_id ?? "";
    message.solver_id = object.solver_id ?? "";
    message.current_price = object.current_price ?? "";
    message.height = object.height ?? "0";
    message.pool_id = object.pool_id ?? "";
    message.curve_sol_amount = object.curve_sol_amount ?? "";
    message.market_cap = object.market_cap ?? "";
    return message;
  },
};

function createBaseListDumpsadCoinsResponse(): ListDumpsadCoinsResponse {
  return { dumpsad_coins: [], pagination: undefined };
}

export const ListDumpsadCoinsResponse = {
  $type: "flux.indexer.explorer.ListDumpsadCoinsResponse" as const,

  encode(message: ListDumpsadCoinsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.dumpsad_coins) {
      DumpsadCoin.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDumpsadCoinsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDumpsadCoinsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dumpsad_coins.push(DumpsadCoin.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDumpsadCoinsResponse {
    return {
      dumpsad_coins: globalThis.Array.isArray(object?.dumpsad_coins)
        ? object.dumpsad_coins.map((e: any) => DumpsadCoin.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListDumpsadCoinsResponse): unknown {
    const obj: any = {};
    if (message.dumpsad_coins?.length) {
      obj.dumpsad_coins = message.dumpsad_coins.map((e) => DumpsadCoin.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListDumpsadCoinsResponse>): ListDumpsadCoinsResponse {
    return ListDumpsadCoinsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDumpsadCoinsResponse>): ListDumpsadCoinsResponse {
    const message = createBaseListDumpsadCoinsResponse();
    message.dumpsad_coins = object.dumpsad_coins?.map((e) => DumpsadCoin.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseStreamDumpsadCoinsRequest(): StreamDumpsadCoinsRequest {
  return { denom: "" };
}

export const StreamDumpsadCoinsRequest = {
  $type: "flux.indexer.explorer.StreamDumpsadCoinsRequest" as const,

  encode(message: StreamDumpsadCoinsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamDumpsadCoinsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamDumpsadCoinsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamDumpsadCoinsRequest {
    return { denom: isSet(object.denom) ? globalThis.String(object.denom) : "" };
  },

  toJSON(message: StreamDumpsadCoinsRequest): unknown {
    const obj: any = {};
    if (message.denom !== undefined) {
      obj.denom = message.denom;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamDumpsadCoinsRequest>): StreamDumpsadCoinsRequest {
    return StreamDumpsadCoinsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamDumpsadCoinsRequest>): StreamDumpsadCoinsRequest {
    const message = createBaseStreamDumpsadCoinsRequest();
    message.denom = object.denom ?? "";
    return message;
  },
};

function createBaseStreamDumpsadCoinsResponse(): StreamDumpsadCoinsResponse {
  return { height: "0", deleted: "0", coin: undefined };
}

export const StreamDumpsadCoinsResponse = {
  $type: "flux.indexer.explorer.StreamDumpsadCoinsResponse" as const,

  encode(message: StreamDumpsadCoinsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).uint64(message.height);
    }
    if (message.deleted !== "0") {
      writer.uint32(16).uint64(message.deleted);
    }
    if (message.coin !== undefined) {
      DumpsadCoin.encode(message.coin, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamDumpsadCoinsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamDumpsadCoinsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.coin = DumpsadCoin.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamDumpsadCoinsResponse {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "0",
      coin: isSet(object.coin) ? DumpsadCoin.fromJSON(object.coin) : undefined,
    };
  },

  toJSON(message: StreamDumpsadCoinsResponse): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.coin !== undefined) {
      obj.coin = DumpsadCoin.toJSON(message.coin);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamDumpsadCoinsResponse>): StreamDumpsadCoinsResponse {
    return StreamDumpsadCoinsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamDumpsadCoinsResponse>): StreamDumpsadCoinsResponse {
    const message = createBaseStreamDumpsadCoinsResponse();
    message.height = object.height ?? "0";
    message.deleted = object.deleted ?? "0";
    message.coin = (object.coin !== undefined && object.coin !== null)
      ? DumpsadCoin.fromPartial(object.coin)
      : undefined;
    return message;
  },
};

function createBaseListDumpsadTradesRequest(): ListDumpsadTradesRequest {
  return { denom: "", solver_id: "", trader: "", sol_amount: "", pagination: undefined };
}

export const ListDumpsadTradesRequest = {
  $type: "flux.indexer.explorer.ListDumpsadTradesRequest" as const,

  encode(message: ListDumpsadTradesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.solver_id !== "") {
      writer.uint32(18).string(message.solver_id);
    }
    if (message.trader !== "") {
      writer.uint32(26).string(message.trader);
    }
    if (message.sol_amount !== "") {
      writer.uint32(34).string(message.sol_amount);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDumpsadTradesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDumpsadTradesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.solver_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.trader = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sol_amount = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDumpsadTradesRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      solver_id: isSet(object.solver_id) ? globalThis.String(object.solver_id) : "",
      trader: isSet(object.trader) ? globalThis.String(object.trader) : "",
      sol_amount: isSet(object.sol_amount) ? globalThis.String(object.sol_amount) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListDumpsadTradesRequest): unknown {
    const obj: any = {};
    if (message.denom !== undefined) {
      obj.denom = message.denom;
    }
    if (message.solver_id !== undefined) {
      obj.solver_id = message.solver_id;
    }
    if (message.trader !== undefined) {
      obj.trader = message.trader;
    }
    if (message.sol_amount !== undefined) {
      obj.sol_amount = message.sol_amount;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListDumpsadTradesRequest>): ListDumpsadTradesRequest {
    return ListDumpsadTradesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDumpsadTradesRequest>): ListDumpsadTradesRequest {
    const message = createBaseListDumpsadTradesRequest();
    message.denom = object.denom ?? "";
    message.solver_id = object.solver_id ?? "";
    message.trader = object.trader ?? "";
    message.sol_amount = object.sol_amount ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseDumpsadTrade(): DumpsadTrade {
  return { denom: "", solver_id: "", trader: "", action: "", meme_amount: "", sol_amount: "", height: "0", time: "0" };
}

export const DumpsadTrade = {
  $type: "flux.indexer.explorer.DumpsadTrade" as const,

  encode(message: DumpsadTrade, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.solver_id !== "") {
      writer.uint32(18).string(message.solver_id);
    }
    if (message.trader !== "") {
      writer.uint32(26).string(message.trader);
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    if (message.meme_amount !== "") {
      writer.uint32(42).string(message.meme_amount);
    }
    if (message.sol_amount !== "") {
      writer.uint32(50).string(message.sol_amount);
    }
    if (message.height !== "0") {
      writer.uint32(56).int64(message.height);
    }
    if (message.time !== "0") {
      writer.uint32(64).int64(message.time);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DumpsadTrade {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDumpsadTrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.solver_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.trader = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.meme_amount = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sol_amount = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.height = longToString(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.time = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DumpsadTrade {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      solver_id: isSet(object.solver_id) ? globalThis.String(object.solver_id) : "",
      trader: isSet(object.trader) ? globalThis.String(object.trader) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      meme_amount: isSet(object.meme_amount) ? globalThis.String(object.meme_amount) : "",
      sol_amount: isSet(object.sol_amount) ? globalThis.String(object.sol_amount) : "",
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      time: isSet(object.time) ? globalThis.String(object.time) : "0",
    };
  },

  toJSON(message: DumpsadTrade): unknown {
    const obj: any = {};
    if (message.denom !== undefined) {
      obj.denom = message.denom;
    }
    if (message.solver_id !== undefined) {
      obj.solver_id = message.solver_id;
    }
    if (message.trader !== undefined) {
      obj.trader = message.trader;
    }
    if (message.action !== undefined) {
      obj.action = message.action;
    }
    if (message.meme_amount !== undefined) {
      obj.meme_amount = message.meme_amount;
    }
    if (message.sol_amount !== undefined) {
      obj.sol_amount = message.sol_amount;
    }
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.time !== undefined) {
      obj.time = message.time;
    }
    return obj;
  },

  create(base?: DeepPartial<DumpsadTrade>): DumpsadTrade {
    return DumpsadTrade.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DumpsadTrade>): DumpsadTrade {
    const message = createBaseDumpsadTrade();
    message.denom = object.denom ?? "";
    message.solver_id = object.solver_id ?? "";
    message.trader = object.trader ?? "";
    message.action = object.action ?? "";
    message.meme_amount = object.meme_amount ?? "";
    message.sol_amount = object.sol_amount ?? "";
    message.height = object.height ?? "0";
    message.time = object.time ?? "0";
    return message;
  },
};

function createBaseListDumpsadTradesResponse(): ListDumpsadTradesResponse {
  return { trades: [], pagination: undefined };
}

export const ListDumpsadTradesResponse = {
  $type: "flux.indexer.explorer.ListDumpsadTradesResponse" as const,

  encode(message: ListDumpsadTradesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.trades) {
      DumpsadTrade.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDumpsadTradesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDumpsadTradesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.trades.push(DumpsadTrade.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDumpsadTradesResponse {
    return {
      trades: globalThis.Array.isArray(object?.trades) ? object.trades.map((e: any) => DumpsadTrade.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListDumpsadTradesResponse): unknown {
    const obj: any = {};
    if (message.trades?.length) {
      obj.trades = message.trades.map((e) => DumpsadTrade.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListDumpsadTradesResponse>): ListDumpsadTradesResponse {
    return ListDumpsadTradesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDumpsadTradesResponse>): ListDumpsadTradesResponse {
    const message = createBaseListDumpsadTradesResponse();
    message.trades = object.trades?.map((e) => DumpsadTrade.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseStreamDumpsadTradesRequest(): StreamDumpsadTradesRequest {
  return { denom: "", strategy_id: "" };
}

export const StreamDumpsadTradesRequest = {
  $type: "flux.indexer.explorer.StreamDumpsadTradesRequest" as const,

  encode(message: StreamDumpsadTradesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.strategy_id !== "") {
      writer.uint32(18).string(message.strategy_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamDumpsadTradesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamDumpsadTradesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.strategy_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamDumpsadTradesRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      strategy_id: isSet(object.strategy_id) ? globalThis.String(object.strategy_id) : "",
    };
  },

  toJSON(message: StreamDumpsadTradesRequest): unknown {
    const obj: any = {};
    if (message.denom !== undefined) {
      obj.denom = message.denom;
    }
    if (message.strategy_id !== undefined) {
      obj.strategy_id = message.strategy_id;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamDumpsadTradesRequest>): StreamDumpsadTradesRequest {
    return StreamDumpsadTradesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamDumpsadTradesRequest>): StreamDumpsadTradesRequest {
    const message = createBaseStreamDumpsadTradesRequest();
    message.denom = object.denom ?? "";
    message.strategy_id = object.strategy_id ?? "";
    return message;
  },
};

function createBaseStreamDumpsadTradesResponse(): StreamDumpsadTradesResponse {
  return { height: "0", deleted: "0", trade: undefined };
}

export const StreamDumpsadTradesResponse = {
  $type: "flux.indexer.explorer.StreamDumpsadTradesResponse" as const,

  encode(message: StreamDumpsadTradesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).uint64(message.height);
    }
    if (message.deleted !== "0") {
      writer.uint32(16).uint64(message.deleted);
    }
    if (message.trade !== undefined) {
      DumpsadTrade.encode(message.trade, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamDumpsadTradesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamDumpsadTradesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.trade = DumpsadTrade.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamDumpsadTradesResponse {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "0",
      trade: isSet(object.trade) ? DumpsadTrade.fromJSON(object.trade) : undefined,
    };
  },

  toJSON(message: StreamDumpsadTradesResponse): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.trade !== undefined) {
      obj.trade = DumpsadTrade.toJSON(message.trade);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamDumpsadTradesResponse>): StreamDumpsadTradesResponse {
    return StreamDumpsadTradesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamDumpsadTradesResponse>): StreamDumpsadTradesResponse {
    const message = createBaseStreamDumpsadTradesResponse();
    message.height = object.height ?? "0";
    message.deleted = object.deleted ?? "0";
    message.trade = (object.trade !== undefined && object.trade !== null)
      ? DumpsadTrade.fromPartial(object.trade)
      : undefined;
    return message;
  },
};

export interface API {
  ListEvmContracts(
    request: DeepPartial<ListEvmContractsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListEvmContractsResponse>;
  Balances(request: DeepPartial<BalancesRequest>, metadata?: grpc.Metadata): Promise<BalancesResponse>;
  ListStrategies(
    request: DeepPartial<ListStrategiesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListStrategiesResponse>;
  ListStrategiesByOwner(
    request: DeepPartial<ListStrategiesByOwnerRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListStrategiesResponse>;
  GetMetrics(request: DeepPartial<GetMetricsRequest>, metadata?: grpc.Metadata): Promise<GetMetricsResponse>;
  ListStrategyTriggersById(
    request: DeepPartial<ListStrategyTriggerByIdRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListStrategyTriggerByIdResponse>;
  ListTokenMetadata(
    request: DeepPartial<ListTokenMetadataRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListTokenMetadataResponse>;
  ListSvmAccountLinks(
    request: DeepPartial<ListSvmAccountLinksRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListSvmAccountLinksResponse>;
  StreamBalances(request: DeepPartial<BalancesRequest>, metadata?: grpc.Metadata): Observable<StreamBalanceResponse>;
  StreamStrategyTriggers(
    request: DeepPartial<StreamStrategyTriggerRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamStrategyTriggerResponse>;
  StreamStrategies(
    request: DeepPartial<StreamStrategiesRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamStrategiesResponse>;
  StreamTokenMetadata(
    request: DeepPartial<StreamTokenMetadataRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamTokenMetadataResponse>;
  StreamSvmAccountLink(
    request: DeepPartial<StreamSvmAccountLinkRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamSvmAccountLinkResponse>;
  ListDriftOrders(
    request: DeepPartial<ListDriftOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListDriftOrdersResponse>;
  ListFillableDriftJITOrders(
    request: DeepPartial<ListFillableDriftJITOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListFillableDriftJITOrdersResponse>;
  StreamDriftOrders(
    request: DeepPartial<StreamDriftOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamDriftOrdersResponse>;
  ListTxs(request: DeepPartial<ListTxsRequest>, metadata?: grpc.Metadata): Promise<ListTxsResponse>;
  GetTx(request: DeepPartial<GetTxRequest>, metadata?: grpc.Metadata): Promise<GetTxResponse>;
  ListAccountTxs(
    request: DeepPartial<ListAccountTxsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListAccountTxsResponse>;
  ListBlocks(request: DeepPartial<ListBlocksRequest>, metadata?: grpc.Metadata): Promise<ListBlocksResponse>;
  GetBlock(request: DeepPartial<GetBlockRequest>, metadata?: grpc.Metadata): Promise<GetBlockResponse>;
  StreamTxs(request: DeepPartial<StreamTxsRequest>, metadata?: grpc.Metadata): Observable<StreamTxsResponse>;
  StreamBlocks(request: DeepPartial<StreamBlocksRequest>, metadata?: grpc.Metadata): Observable<StreamBlocksResponse>;
  ListContracts(request: DeepPartial<ListContractsRequest>, metadata?: grpc.Metadata): Promise<ListContractsResponse>;
  GetContract(request: DeepPartial<GetContractRequest>, metadata?: grpc.Metadata): Promise<GetContractResponse>;
  StreamContract(
    request: DeepPartial<StreamContractRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamContractResponse>;
  ListDumpsadCoins(
    request: DeepPartial<ListDumpsadCoinsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListDumpsadCoinsResponse>;
  StreamDumpsadCoins(
    request: DeepPartial<StreamDumpsadCoinsRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamDumpsadCoinsResponse>;
  ListDumpsadTrades(
    request: DeepPartial<ListDumpsadTradesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListDumpsadTradesResponse>;
  StreamDumpsadTrades(
    request: DeepPartial<StreamDumpsadTradesRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamDumpsadTradesResponse>;
}

export class APIClientImpl implements API {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.ListEvmContracts = this.ListEvmContracts.bind(this);
    this.Balances = this.Balances.bind(this);
    this.ListStrategies = this.ListStrategies.bind(this);
    this.ListStrategiesByOwner = this.ListStrategiesByOwner.bind(this);
    this.GetMetrics = this.GetMetrics.bind(this);
    this.ListStrategyTriggersById = this.ListStrategyTriggersById.bind(this);
    this.ListTokenMetadata = this.ListTokenMetadata.bind(this);
    this.ListSvmAccountLinks = this.ListSvmAccountLinks.bind(this);
    this.StreamBalances = this.StreamBalances.bind(this);
    this.StreamStrategyTriggers = this.StreamStrategyTriggers.bind(this);
    this.StreamStrategies = this.StreamStrategies.bind(this);
    this.StreamTokenMetadata = this.StreamTokenMetadata.bind(this);
    this.StreamSvmAccountLink = this.StreamSvmAccountLink.bind(this);
    this.ListDriftOrders = this.ListDriftOrders.bind(this);
    this.ListFillableDriftJITOrders = this.ListFillableDriftJITOrders.bind(this);
    this.StreamDriftOrders = this.StreamDriftOrders.bind(this);
    this.ListTxs = this.ListTxs.bind(this);
    this.GetTx = this.GetTx.bind(this);
    this.ListAccountTxs = this.ListAccountTxs.bind(this);
    this.ListBlocks = this.ListBlocks.bind(this);
    this.GetBlock = this.GetBlock.bind(this);
    this.StreamTxs = this.StreamTxs.bind(this);
    this.StreamBlocks = this.StreamBlocks.bind(this);
    this.ListContracts = this.ListContracts.bind(this);
    this.GetContract = this.GetContract.bind(this);
    this.StreamContract = this.StreamContract.bind(this);
    this.ListDumpsadCoins = this.ListDumpsadCoins.bind(this);
    this.StreamDumpsadCoins = this.StreamDumpsadCoins.bind(this);
    this.ListDumpsadTrades = this.ListDumpsadTrades.bind(this);
    this.StreamDumpsadTrades = this.StreamDumpsadTrades.bind(this);
  }

  ListEvmContracts(
    request: DeepPartial<ListEvmContractsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListEvmContractsResponse> {
    return this.rpc.unary(APIListEvmContractsDesc, ListEvmContractsRequest.fromPartial(request), metadata);
  }

  Balances(request: DeepPartial<BalancesRequest>, metadata?: grpc.Metadata): Promise<BalancesResponse> {
    return this.rpc.unary(APIBalancesDesc, BalancesRequest.fromPartial(request), metadata);
  }

  ListStrategies(
    request: DeepPartial<ListStrategiesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListStrategiesResponse> {
    return this.rpc.unary(APIListStrategiesDesc, ListStrategiesRequest.fromPartial(request), metadata);
  }

  ListStrategiesByOwner(
    request: DeepPartial<ListStrategiesByOwnerRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListStrategiesResponse> {
    return this.rpc.unary(APIListStrategiesByOwnerDesc, ListStrategiesByOwnerRequest.fromPartial(request), metadata);
  }

  GetMetrics(request: DeepPartial<GetMetricsRequest>, metadata?: grpc.Metadata): Promise<GetMetricsResponse> {
    return this.rpc.unary(APIGetMetricsDesc, GetMetricsRequest.fromPartial(request), metadata);
  }

  ListStrategyTriggersById(
    request: DeepPartial<ListStrategyTriggerByIdRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListStrategyTriggerByIdResponse> {
    return this.rpc.unary(
      APIListStrategyTriggersByIdDesc,
      ListStrategyTriggerByIdRequest.fromPartial(request),
      metadata,
    );
  }

  ListTokenMetadata(
    request: DeepPartial<ListTokenMetadataRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListTokenMetadataResponse> {
    return this.rpc.unary(APIListTokenMetadataDesc, ListTokenMetadataRequest.fromPartial(request), metadata);
  }

  ListSvmAccountLinks(
    request: DeepPartial<ListSvmAccountLinksRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListSvmAccountLinksResponse> {
    return this.rpc.unary(APIListSvmAccountLinksDesc, ListSvmAccountLinksRequest.fromPartial(request), metadata);
  }

  StreamBalances(request: DeepPartial<BalancesRequest>, metadata?: grpc.Metadata): Observable<StreamBalanceResponse> {
    return this.rpc.invoke(APIStreamBalancesDesc, BalancesRequest.fromPartial(request), metadata);
  }

  StreamStrategyTriggers(
    request: DeepPartial<StreamStrategyTriggerRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamStrategyTriggerResponse> {
    return this.rpc.invoke(APIStreamStrategyTriggersDesc, StreamStrategyTriggerRequest.fromPartial(request), metadata);
  }

  StreamStrategies(
    request: DeepPartial<StreamStrategiesRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamStrategiesResponse> {
    return this.rpc.invoke(APIStreamStrategiesDesc, StreamStrategiesRequest.fromPartial(request), metadata);
  }

  StreamTokenMetadata(
    request: DeepPartial<StreamTokenMetadataRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamTokenMetadataResponse> {
    return this.rpc.invoke(APIStreamTokenMetadataDesc, StreamTokenMetadataRequest.fromPartial(request), metadata);
  }

  StreamSvmAccountLink(
    request: DeepPartial<StreamSvmAccountLinkRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamSvmAccountLinkResponse> {
    return this.rpc.invoke(APIStreamSvmAccountLinkDesc, StreamSvmAccountLinkRequest.fromPartial(request), metadata);
  }

  ListDriftOrders(
    request: DeepPartial<ListDriftOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListDriftOrdersResponse> {
    return this.rpc.unary(APIListDriftOrdersDesc, ListDriftOrdersRequest.fromPartial(request), metadata);
  }

  ListFillableDriftJITOrders(
    request: DeepPartial<ListFillableDriftJITOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListFillableDriftJITOrdersResponse> {
    return this.rpc.unary(
      APIListFillableDriftJITOrdersDesc,
      ListFillableDriftJITOrdersRequest.fromPartial(request),
      metadata,
    );
  }

  StreamDriftOrders(
    request: DeepPartial<StreamDriftOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamDriftOrdersResponse> {
    return this.rpc.invoke(APIStreamDriftOrdersDesc, StreamDriftOrdersRequest.fromPartial(request), metadata);
  }

  ListTxs(request: DeepPartial<ListTxsRequest>, metadata?: grpc.Metadata): Promise<ListTxsResponse> {
    return this.rpc.unary(APIListTxsDesc, ListTxsRequest.fromPartial(request), metadata);
  }

  GetTx(request: DeepPartial<GetTxRequest>, metadata?: grpc.Metadata): Promise<GetTxResponse> {
    return this.rpc.unary(APIGetTxDesc, GetTxRequest.fromPartial(request), metadata);
  }

  ListAccountTxs(
    request: DeepPartial<ListAccountTxsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListAccountTxsResponse> {
    return this.rpc.unary(APIListAccountTxsDesc, ListAccountTxsRequest.fromPartial(request), metadata);
  }

  ListBlocks(request: DeepPartial<ListBlocksRequest>, metadata?: grpc.Metadata): Promise<ListBlocksResponse> {
    return this.rpc.unary(APIListBlocksDesc, ListBlocksRequest.fromPartial(request), metadata);
  }

  GetBlock(request: DeepPartial<GetBlockRequest>, metadata?: grpc.Metadata): Promise<GetBlockResponse> {
    return this.rpc.unary(APIGetBlockDesc, GetBlockRequest.fromPartial(request), metadata);
  }

  StreamTxs(request: DeepPartial<StreamTxsRequest>, metadata?: grpc.Metadata): Observable<StreamTxsResponse> {
    return this.rpc.invoke(APIStreamTxsDesc, StreamTxsRequest.fromPartial(request), metadata);
  }

  StreamBlocks(request: DeepPartial<StreamBlocksRequest>, metadata?: grpc.Metadata): Observable<StreamBlocksResponse> {
    return this.rpc.invoke(APIStreamBlocksDesc, StreamBlocksRequest.fromPartial(request), metadata);
  }

  ListContracts(request: DeepPartial<ListContractsRequest>, metadata?: grpc.Metadata): Promise<ListContractsResponse> {
    return this.rpc.unary(APIListContractsDesc, ListContractsRequest.fromPartial(request), metadata);
  }

  GetContract(request: DeepPartial<GetContractRequest>, metadata?: grpc.Metadata): Promise<GetContractResponse> {
    return this.rpc.unary(APIGetContractDesc, GetContractRequest.fromPartial(request), metadata);
  }

  StreamContract(
    request: DeepPartial<StreamContractRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamContractResponse> {
    return this.rpc.invoke(APIStreamContractDesc, StreamContractRequest.fromPartial(request), metadata);
  }

  ListDumpsadCoins(
    request: DeepPartial<ListDumpsadCoinsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListDumpsadCoinsResponse> {
    return this.rpc.unary(APIListDumpsadCoinsDesc, ListDumpsadCoinsRequest.fromPartial(request), metadata);
  }

  StreamDumpsadCoins(
    request: DeepPartial<StreamDumpsadCoinsRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamDumpsadCoinsResponse> {
    return this.rpc.invoke(APIStreamDumpsadCoinsDesc, StreamDumpsadCoinsRequest.fromPartial(request), metadata);
  }

  ListDumpsadTrades(
    request: DeepPartial<ListDumpsadTradesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListDumpsadTradesResponse> {
    return this.rpc.unary(APIListDumpsadTradesDesc, ListDumpsadTradesRequest.fromPartial(request), metadata);
  }

  StreamDumpsadTrades(
    request: DeepPartial<StreamDumpsadTradesRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamDumpsadTradesResponse> {
    return this.rpc.invoke(APIStreamDumpsadTradesDesc, StreamDumpsadTradesRequest.fromPartial(request), metadata);
  }
}

export const APIDesc = { serviceName: "flux.indexer.explorer.API" };

export const APIListEvmContractsDesc: UnaryMethodDefinitionish = {
  methodName: "ListEvmContracts",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListEvmContractsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListEvmContractsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIBalancesDesc: UnaryMethodDefinitionish = {
  methodName: "Balances",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return BalancesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = BalancesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListStrategiesDesc: UnaryMethodDefinitionish = {
  methodName: "ListStrategies",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListStrategiesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListStrategiesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListStrategiesByOwnerDesc: UnaryMethodDefinitionish = {
  methodName: "ListStrategiesByOwner",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListStrategiesByOwnerRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListStrategiesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIGetMetricsDesc: UnaryMethodDefinitionish = {
  methodName: "GetMetrics",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetMetricsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetMetricsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListStrategyTriggersByIdDesc: UnaryMethodDefinitionish = {
  methodName: "ListStrategyTriggersById",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListStrategyTriggerByIdRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListStrategyTriggerByIdResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListTokenMetadataDesc: UnaryMethodDefinitionish = {
  methodName: "ListTokenMetadata",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListTokenMetadataRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListTokenMetadataResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListSvmAccountLinksDesc: UnaryMethodDefinitionish = {
  methodName: "ListSvmAccountLinks",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListSvmAccountLinksRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListSvmAccountLinksResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIStreamBalancesDesc: UnaryMethodDefinitionish = {
  methodName: "StreamBalances",
  service: APIDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return BalancesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamBalanceResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIStreamStrategyTriggersDesc: UnaryMethodDefinitionish = {
  methodName: "StreamStrategyTriggers",
  service: APIDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamStrategyTriggerRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamStrategyTriggerResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIStreamStrategiesDesc: UnaryMethodDefinitionish = {
  methodName: "StreamStrategies",
  service: APIDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamStrategiesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamStrategiesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIStreamTokenMetadataDesc: UnaryMethodDefinitionish = {
  methodName: "StreamTokenMetadata",
  service: APIDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamTokenMetadataRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamTokenMetadataResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIStreamSvmAccountLinkDesc: UnaryMethodDefinitionish = {
  methodName: "StreamSvmAccountLink",
  service: APIDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamSvmAccountLinkRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamSvmAccountLinkResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListDriftOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "ListDriftOrders",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListDriftOrdersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListDriftOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListFillableDriftJITOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "ListFillableDriftJITOrders",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListFillableDriftJITOrdersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListFillableDriftJITOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIStreamDriftOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "StreamDriftOrders",
  service: APIDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamDriftOrdersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamDriftOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListTxsDesc: UnaryMethodDefinitionish = {
  methodName: "ListTxs",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListTxsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListTxsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIGetTxDesc: UnaryMethodDefinitionish = {
  methodName: "GetTx",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetTxRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetTxResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListAccountTxsDesc: UnaryMethodDefinitionish = {
  methodName: "ListAccountTxs",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListAccountTxsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListAccountTxsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListBlocksDesc: UnaryMethodDefinitionish = {
  methodName: "ListBlocks",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListBlocksRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListBlocksResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIGetBlockDesc: UnaryMethodDefinitionish = {
  methodName: "GetBlock",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetBlockRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetBlockResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIStreamTxsDesc: UnaryMethodDefinitionish = {
  methodName: "StreamTxs",
  service: APIDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamTxsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamTxsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIStreamBlocksDesc: UnaryMethodDefinitionish = {
  methodName: "StreamBlocks",
  service: APIDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamBlocksRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamBlocksResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListContractsDesc: UnaryMethodDefinitionish = {
  methodName: "ListContracts",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListContractsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListContractsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIGetContractDesc: UnaryMethodDefinitionish = {
  methodName: "GetContract",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetContractRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetContractResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIStreamContractDesc: UnaryMethodDefinitionish = {
  methodName: "StreamContract",
  service: APIDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamContractRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamContractResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListDumpsadCoinsDesc: UnaryMethodDefinitionish = {
  methodName: "ListDumpsadCoins",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListDumpsadCoinsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListDumpsadCoinsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIStreamDumpsadCoinsDesc: UnaryMethodDefinitionish = {
  methodName: "StreamDumpsadCoins",
  service: APIDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamDumpsadCoinsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamDumpsadCoinsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListDumpsadTradesDesc: UnaryMethodDefinitionish = {
  methodName: "ListDumpsadTrades",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListDumpsadTradesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListDumpsadTradesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIStreamDumpsadTradesDesc: UnaryMethodDefinitionish = {
  methodName: "StreamDumpsadTrades",
  service: APIDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamDumpsadTradesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamDumpsadTradesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;
    streamingTransport?: grpc.TransportFactory;
    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;
      streamingTransport?: grpc.TransportFactory;
      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }

  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any> {
    const upStreamCodes = this.options.upStreamRetryCodes ?? [];
    const DEFAULT_TIMEOUT_TIME: number = 3_000;
    const request = { ..._request, ...methodDesc.requestType };
    const transport = this.options.streamingTransport ?? this.options.transport;
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Observable((observer) => {
      const upStream = () => {
        const client = grpc.invoke(methodDesc, {
          host: this.host,
          request,
          ...(transport !== undefined ? { transport } : {}),
          metadata: maybeCombinedMetadata ?? {},
          debug: this.options.debug ?? false,
          onMessage: (next) => observer.next(next),
          onEnd: (code: grpc.Code, message: string, trailers: grpc.Metadata) => {
            if (code === 0) {
              observer.complete();
            } else if (upStreamCodes.includes(code)) {
              setTimeout(upStream, DEFAULT_TIMEOUT_TIME);
            } else {
              const err = new Error(message) as any;
              err.code = code;
              err.metadata = trailers;
              observer.error(err);
            }
          },
        });
        observer.add(() => client.close());
      };
      upStream();
    }).pipe(share());
  }
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
