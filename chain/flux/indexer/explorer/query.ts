// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: flux/indexer/explorer/query.proto

/* eslint-disable */
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import { share } from "rxjs/operators";
import { PageRequest, PageResponse } from "../../../cosmos/base/query/v1beta1/pagination";
import { BoolValue } from "../../../google/protobuf/wrappers";
import { TokenMetadata } from "../../astromesh/v1beta1/event";
import { Plane, planeFromJSON, planeToJSON } from "../../astromesh/v1beta1/tx";
import { ContractInfo } from "../../evm/v1beta1/evm";
import { StrategyTriggerEvent } from "../../strategy/v1beta1/event";
import { Strategy, StrategyType, strategyTypeFromJSON, strategyTypeToJSON } from "../../strategy/v1beta1/strategy";
import { AccountLink } from "../../svm/v1beta1/svm";

export enum OrderDirection {
  long = 0,
  short = 1,
  UNRECOGNIZED = -1,
}

export function orderDirectionFromJSON(object: any): OrderDirection {
  switch (object) {
    case 0:
    case "long":
      return OrderDirection.long;
    case 1:
    case "short":
      return OrderDirection.short;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderDirection.UNRECOGNIZED;
  }
}

export function orderDirectionToJSON(object: OrderDirection): string {
  switch (object) {
    case OrderDirection.long:
      return "long";
    case OrderDirection.short:
      return "short";
    case OrderDirection.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ListEvmContractsRequest {
  /** owner of the contract to filter */
  address: string;
  pagination: PageRequest | undefined;
}

export interface ListEvmContractsResponse {
  contracts: ContractInfo[];
  pagination: PageResponse | undefined;
}

export interface BalancesRequest {
  address: string;
  pagination: PageRequest | undefined;
}

export interface BalanceInfo {
  acc: string;
  plane: Plane;
  denom: string;
  amount: string;
  updated_height: string;
  updated_time: string;
  denom_metadata: TokenMetadata | undefined;
}

export interface BalancesResponse {
  balances: BalanceInfo[];
  pagination: PageResponse | undefined;
}

/** strategy type filter, could be generic strategies, intent solver or cron bot */
export interface TypeFilter {
  value: StrategyType;
}

export interface SupportedAppFilter {
  plane: Plane;
  contract_address: string;
  verified: boolean | undefined;
}

/**
 * ListStrategiesRequest is a query type to list out existing on-chain strategies
 * with some filters For unused fields, just leave them empty
 */
export interface ListStrategiesRequest {
  /** use pagination to limit the output item list */
  pagination: PageRequest | undefined;
  type:
    | TypeFilter
    | undefined;
  /** strategy id to filter, this is useful to get info of a single strategy */
  id: string;
  /** strategy enable/disable status to filter */
  enabled:
    | boolean
    | undefined;
  /** tags to filter */
  tags: string[];
  /** filter by supported app (filter single app for now) */
  supported_app: SupportedAppFilter | undefined;
}

export interface ListStrategiesResponse {
  /** pagination response shows which page the strategy list is at */
  pagination:
    | PageResponse
    | undefined;
  /**
   * strategies shows existing strategies after applied the filters in
   * ListStrategiesRequest
   */
  strategies: Strategy[];
}

/** List strategies by an owner with some additional filters */
export interface ListStrategiesByOwnerRequest {
  /** use pagination to limit the output item list */
  pagination:
    | PageRequest
    | undefined;
  /** owner of the strategy, required by this query */
  owner: string;
  /** strategy type, could be generic strategies, intent solver or cron bot */
  type:
    | TypeFilter
    | undefined;
  /** strategy enable/disable status to filter */
  enabled:
    | boolean
    | undefined;
  /** tags to filter */
  tags: string[];
  /** filter by supported app (filter single app for now) */
  supported_app: SupportedAppFilter | undefined;
}

export interface Pool {
  exchange: string;
  plane: Plane;
  /** ID of the pool */
  pool_id: string;
  /** Volume of token0 */
  token0_volume: string;
  /** Volume of token1 */
  token1_volume: string;
  /** Locked amount of token0 */
  token0_liquidity: string;
  /** Locked amount of token1 */
  token1_liquidity: string;
  /** total swap count */
  swap_count: string;
}

export interface Metrics {
  /** Transaction count */
  tx_count: string;
  /** Block count */
  block_count: string;
  /** List of pools with their token volumes */
  pools: Pool[];
}

export interface GetMetricsRequest {
}

export interface GetMetricsResponse {
  data: Metrics | undefined;
}

export interface StreamBalanceResponse {
  height: string;
  deleted: string;
  balances: BalanceInfo[];
}

export interface ListStrategyTriggerByIdRequest {
  /** Use pagination to limit the output item list */
  pagination:
    | PageRequest
    | undefined;
  /** Strategy ID to filter */
  id: string;
  /** Start time to filter */
  from_time: string;
  /** End time to filter */
  to_time: string;
  /** Filter only succeeded/failed triggers */
  success: boolean | undefined;
}

export interface ListStrategyTriggerByIdResponse {
  /** pagination response shows which page the strategy trigger list is at */
  pagination: PageResponse | undefined;
  triggers: StrategyTriggerEvent[];
}

export interface StreamStrategyTriggerRequest {
  id: string[];
}

export interface StreamStrategyTriggerResponse {
  height: string;
  deleted: string;
  triggers: StrategyTriggerEvent[];
}

export interface StreamStrategiesRequest {
  /** owner of the strategy, required by this query */
  owner: string;
  /** strategy type, could be generic strategies, intent solver or cron bot */
  type:
    | TypeFilter
    | undefined;
  /** tags to filter */
  tags: string[];
  /** filter by supported app (filter single app for now) */
  supported_app: SupportedAppFilter | undefined;
}

export interface StreamStrategiesResponse {
  height: string;
  deleted: string;
  strategies: Strategy[];
}

export interface ListTokenMetadataRequest {
  pagination: PageRequest | undefined;
}

export interface ListTokenMetadataResponse {
  pagination: PageResponse | undefined;
  metadata: TokenMetadata[];
}

export interface StreamTokenMetadataRequest {
}

export interface StreamTokenMetadataResponse {
  height: string;
  deleted: string;
  metadata: TokenMetadata[];
}

export interface ListSvmAccountLinksRequest {
  /** optional */
  cosmos_addr: string;
  /** optional */
  svm_addr: string;
  pagination: PageRequest | undefined;
}

export interface ListSvmAccountLinksResponse {
  pagination: PageResponse | undefined;
  account_links: AccountLink[];
}

export interface StreamSvmAccountLinkRequest {
  /** Optional input: Cosmos address */
  cosmos_address: string;
  /** Optional input: SVM address */
  svm_address: string;
}

export interface StreamSvmAccountLinkResponse {
  height: string;
  deleted: string;
  account_link: AccountLink[];
}

/** Request and response messages for ListDriftOrders */
export interface ListDriftOrdersRequest {
  /** Optional filter by market name */
  market_name: string;
}

export interface ListDriftOrdersResponse {
  orders: DriftOrder[];
}

/** Request and response messages for ListFillableDriftJITOrders */
export interface ListFillableDriftJITOrdersRequest {
  market_name: string;
  worst_price: string;
  direction: OrderDirection;
  quantity: string;
}

export interface ListFillableDriftJITOrdersResponse {
  fillable_orders: DriftOrder[];
}

/** Order structure with auction_start_price and auction_end_price */
export interface DriftOrder {
  subaccount_address: string;
  owner_address: string;
  price: string;
  total_quantity: string;
  market_name: string;
  order_id: number;
  auction_start_price: string;
  auction_end_price: string;
  slot: string;
  auction_duration: number;
  expired_at: string;
  direction: OrderDirection;
  fillable_quantity: string;
}

export interface StreamDriftOrdersRequest {
  /** Optional filter by market name */
  market_name: string;
  /** Optional filter for specific price */
  price: string;
  /** Optional filter, e.g., "buy" or "sell" */
  direction: string;
}

export interface StreamDriftOrdersResponse {
  /** Block height at which the order was created or updated */
  height: string;
  /** Indicator if the order is deleted (1 for true, 0 for false) */
  deleted: string;
  /** The DriftOrder object */
  order: DriftOrder | undefined;
}

function createBaseListEvmContractsRequest(): ListEvmContractsRequest {
  return { address: "", pagination: undefined };
}

export const ListEvmContractsRequest = {
  $type: "flux.indexer.explorer.ListEvmContractsRequest" as const,

  encode(message: ListEvmContractsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListEvmContractsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEvmContractsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEvmContractsRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListEvmContractsRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListEvmContractsRequest>): ListEvmContractsRequest {
    return ListEvmContractsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEvmContractsRequest>): ListEvmContractsRequest {
    const message = createBaseListEvmContractsRequest();
    message.address = object.address ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListEvmContractsResponse(): ListEvmContractsResponse {
  return { contracts: [], pagination: undefined };
}

export const ListEvmContractsResponse = {
  $type: "flux.indexer.explorer.ListEvmContractsResponse" as const,

  encode(message: ListEvmContractsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.contracts) {
      ContractInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListEvmContractsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEvmContractsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contracts.push(ContractInfo.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEvmContractsResponse {
    return {
      contracts: globalThis.Array.isArray(object?.contracts)
        ? object.contracts.map((e: any) => ContractInfo.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListEvmContractsResponse): unknown {
    const obj: any = {};
    if (message.contracts?.length) {
      obj.contracts = message.contracts.map((e) => ContractInfo.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListEvmContractsResponse>): ListEvmContractsResponse {
    return ListEvmContractsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEvmContractsResponse>): ListEvmContractsResponse {
    const message = createBaseListEvmContractsResponse();
    message.contracts = object.contracts?.map((e) => ContractInfo.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseBalancesRequest(): BalancesRequest {
  return { address: "", pagination: undefined };
}

export const BalancesRequest = {
  $type: "flux.indexer.explorer.BalancesRequest" as const,

  encode(message: BalancesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BalancesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalancesRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: BalancesRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<BalancesRequest>): BalancesRequest {
    return BalancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BalancesRequest>): BalancesRequest {
    const message = createBaseBalancesRequest();
    message.address = object.address ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseBalanceInfo(): BalanceInfo {
  return {
    acc: "",
    plane: 0,
    denom: "",
    amount: "",
    updated_height: "0",
    updated_time: "0",
    denom_metadata: undefined,
  };
}

export const BalanceInfo = {
  $type: "flux.indexer.explorer.BalanceInfo" as const,

  encode(message: BalanceInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.acc !== "") {
      writer.uint32(10).string(message.acc);
    }
    if (message.plane !== 0) {
      writer.uint32(16).int32(message.plane);
    }
    if (message.denom !== "") {
      writer.uint32(26).string(message.denom);
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    if (message.updated_height !== "0") {
      writer.uint32(40).uint64(message.updated_height);
    }
    if (message.updated_time !== "0") {
      writer.uint32(48).uint64(message.updated_time);
    }
    if (message.denom_metadata !== undefined) {
      TokenMetadata.encode(message.denom_metadata, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BalanceInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.acc = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.plane = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.denom = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.updated_height = longToString(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.updated_time = longToString(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.denom_metadata = TokenMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalanceInfo {
    return {
      acc: isSet(object.acc) ? globalThis.String(object.acc) : "",
      plane: isSet(object.plane) ? planeFromJSON(object.plane) : 0,
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      updated_height: isSet(object.updated_height) ? globalThis.String(object.updated_height) : "0",
      updated_time: isSet(object.updated_time) ? globalThis.String(object.updated_time) : "0",
      denom_metadata: isSet(object.denom_metadata) ? TokenMetadata.fromJSON(object.denom_metadata) : undefined,
    };
  },

  toJSON(message: BalanceInfo): unknown {
    const obj: any = {};
    if (message.acc !== undefined) {
      obj.acc = message.acc;
    }
    if (message.plane !== undefined) {
      obj.plane = planeToJSON(message.plane);
    }
    if (message.denom !== undefined) {
      obj.denom = message.denom;
    }
    if (message.amount !== undefined) {
      obj.amount = message.amount;
    }
    if (message.updated_height !== undefined) {
      obj.updated_height = message.updated_height;
    }
    if (message.updated_time !== undefined) {
      obj.updated_time = message.updated_time;
    }
    if (message.denom_metadata !== undefined) {
      obj.denom_metadata = TokenMetadata.toJSON(message.denom_metadata);
    }
    return obj;
  },

  create(base?: DeepPartial<BalanceInfo>): BalanceInfo {
    return BalanceInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BalanceInfo>): BalanceInfo {
    const message = createBaseBalanceInfo();
    message.acc = object.acc ?? "";
    message.plane = object.plane ?? 0;
    message.denom = object.denom ?? "";
    message.amount = object.amount ?? "";
    message.updated_height = object.updated_height ?? "0";
    message.updated_time = object.updated_time ?? "0";
    message.denom_metadata = (object.denom_metadata !== undefined && object.denom_metadata !== null)
      ? TokenMetadata.fromPartial(object.denom_metadata)
      : undefined;
    return message;
  },
};

function createBaseBalancesResponse(): BalancesResponse {
  return { balances: [], pagination: undefined };
}

export const BalancesResponse = {
  $type: "flux.indexer.explorer.BalancesResponse" as const,

  encode(message: BalancesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.balances) {
      BalanceInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BalancesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.balances.push(BalanceInfo.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalancesResponse {
    return {
      balances: globalThis.Array.isArray(object?.balances)
        ? object.balances.map((e: any) => BalanceInfo.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: BalancesResponse): unknown {
    const obj: any = {};
    if (message.balances?.length) {
      obj.balances = message.balances.map((e) => BalanceInfo.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<BalancesResponse>): BalancesResponse {
    return BalancesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BalancesResponse>): BalancesResponse {
    const message = createBaseBalancesResponse();
    message.balances = object.balances?.map((e) => BalanceInfo.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseTypeFilter(): TypeFilter {
  return { value: 0 };
}

export const TypeFilter = {
  $type: "flux.indexer.explorer.TypeFilter" as const,

  encode(message: TypeFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TypeFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypeFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypeFilter {
    return { value: isSet(object.value) ? strategyTypeFromJSON(object.value) : 0 };
  },

  toJSON(message: TypeFilter): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = strategyTypeToJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<TypeFilter>): TypeFilter {
    return TypeFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TypeFilter>): TypeFilter {
    const message = createBaseTypeFilter();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseSupportedAppFilter(): SupportedAppFilter {
  return { plane: 0, contract_address: "", verified: undefined };
}

export const SupportedAppFilter = {
  $type: "flux.indexer.explorer.SupportedAppFilter" as const,

  encode(message: SupportedAppFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.plane !== 0) {
      writer.uint32(8).int32(message.plane);
    }
    if (message.contract_address !== "") {
      writer.uint32(18).string(message.contract_address);
    }
    if (message.verified !== undefined) {
      BoolValue.encode({ value: message.verified! }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SupportedAppFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupportedAppFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.plane = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contract_address = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.verified = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupportedAppFilter {
    return {
      plane: isSet(object.plane) ? planeFromJSON(object.plane) : 0,
      contract_address: isSet(object.contract_address) ? globalThis.String(object.contract_address) : "",
      verified: isSet(object.verified) ? Boolean(object.verified) : undefined,
    };
  },

  toJSON(message: SupportedAppFilter): unknown {
    const obj: any = {};
    if (message.plane !== undefined) {
      obj.plane = planeToJSON(message.plane);
    }
    if (message.contract_address !== undefined) {
      obj.contract_address = message.contract_address;
    }
    if (message.verified !== undefined) {
      obj.verified = message.verified;
    }
    return obj;
  },

  create(base?: DeepPartial<SupportedAppFilter>): SupportedAppFilter {
    return SupportedAppFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SupportedAppFilter>): SupportedAppFilter {
    const message = createBaseSupportedAppFilter();
    message.plane = object.plane ?? 0;
    message.contract_address = object.contract_address ?? "";
    message.verified = object.verified ?? undefined;
    return message;
  },
};

function createBaseListStrategiesRequest(): ListStrategiesRequest {
  return { pagination: undefined, type: undefined, id: "", enabled: undefined, tags: [], supported_app: undefined };
}

export const ListStrategiesRequest = {
  $type: "flux.indexer.explorer.ListStrategiesRequest" as const,

  encode(message: ListStrategiesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    if (message.type !== undefined) {
      TypeFilter.encode(message.type, writer.uint32(18).fork()).ldelim();
    }
    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }
    if (message.enabled !== undefined) {
      BoolValue.encode({ value: message.enabled! }, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.tags) {
      writer.uint32(42).string(v!);
    }
    if (message.supported_app !== undefined) {
      SupportedAppFilter.encode(message.supported_app, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListStrategiesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStrategiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = TypeFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.enabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.supported_app = SupportedAppFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStrategiesRequest {
    return {
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
      type: isSet(object.type) ? TypeFilter.fromJSON(object.type) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      enabled: isSet(object.enabled) ? Boolean(object.enabled) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      supported_app: isSet(object.supported_app) ? SupportedAppFilter.fromJSON(object.supported_app) : undefined,
    };
  },

  toJSON(message: ListStrategiesRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    if (message.type !== undefined) {
      obj.type = TypeFilter.toJSON(message.type);
    }
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.enabled !== undefined) {
      obj.enabled = message.enabled;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.supported_app !== undefined) {
      obj.supported_app = SupportedAppFilter.toJSON(message.supported_app);
    }
    return obj;
  },

  create(base?: DeepPartial<ListStrategiesRequest>): ListStrategiesRequest {
    return ListStrategiesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListStrategiesRequest>): ListStrategiesRequest {
    const message = createBaseListStrategiesRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    message.type = (object.type !== undefined && object.type !== null)
      ? TypeFilter.fromPartial(object.type)
      : undefined;
    message.id = object.id ?? "";
    message.enabled = object.enabled ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.supported_app = (object.supported_app !== undefined && object.supported_app !== null)
      ? SupportedAppFilter.fromPartial(object.supported_app)
      : undefined;
    return message;
  },
};

function createBaseListStrategiesResponse(): ListStrategiesResponse {
  return { pagination: undefined, strategies: [] };
}

export const ListStrategiesResponse = {
  $type: "flux.indexer.explorer.ListStrategiesResponse" as const,

  encode(message: ListStrategiesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.strategies) {
      Strategy.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListStrategiesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStrategiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.strategies.push(Strategy.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStrategiesResponse {
    return {
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
      strategies: globalThis.Array.isArray(object?.strategies)
        ? object.strategies.map((e: any) => Strategy.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListStrategiesResponse): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    if (message.strategies?.length) {
      obj.strategies = message.strategies.map((e) => Strategy.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListStrategiesResponse>): ListStrategiesResponse {
    return ListStrategiesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListStrategiesResponse>): ListStrategiesResponse {
    const message = createBaseListStrategiesResponse();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    message.strategies = object.strategies?.map((e) => Strategy.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListStrategiesByOwnerRequest(): ListStrategiesByOwnerRequest {
  return { pagination: undefined, owner: "", type: undefined, enabled: undefined, tags: [], supported_app: undefined };
}

export const ListStrategiesByOwnerRequest = {
  $type: "flux.indexer.explorer.ListStrategiesByOwnerRequest" as const,

  encode(message: ListStrategiesByOwnerRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    if (message.owner !== "") {
      writer.uint32(18).string(message.owner);
    }
    if (message.type !== undefined) {
      TypeFilter.encode(message.type, writer.uint32(26).fork()).ldelim();
    }
    if (message.enabled !== undefined) {
      BoolValue.encode({ value: message.enabled! }, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.tags) {
      writer.uint32(42).string(v!);
    }
    if (message.supported_app !== undefined) {
      SupportedAppFilter.encode(message.supported_app, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListStrategiesByOwnerRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStrategiesByOwnerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = TypeFilter.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.enabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.supported_app = SupportedAppFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStrategiesByOwnerRequest {
    return {
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      type: isSet(object.type) ? TypeFilter.fromJSON(object.type) : undefined,
      enabled: isSet(object.enabled) ? Boolean(object.enabled) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      supported_app: isSet(object.supported_app) ? SupportedAppFilter.fromJSON(object.supported_app) : undefined,
    };
  },

  toJSON(message: ListStrategiesByOwnerRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.type !== undefined) {
      obj.type = TypeFilter.toJSON(message.type);
    }
    if (message.enabled !== undefined) {
      obj.enabled = message.enabled;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.supported_app !== undefined) {
      obj.supported_app = SupportedAppFilter.toJSON(message.supported_app);
    }
    return obj;
  },

  create(base?: DeepPartial<ListStrategiesByOwnerRequest>): ListStrategiesByOwnerRequest {
    return ListStrategiesByOwnerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListStrategiesByOwnerRequest>): ListStrategiesByOwnerRequest {
    const message = createBaseListStrategiesByOwnerRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    message.owner = object.owner ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? TypeFilter.fromPartial(object.type)
      : undefined;
    message.enabled = object.enabled ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.supported_app = (object.supported_app !== undefined && object.supported_app !== null)
      ? SupportedAppFilter.fromPartial(object.supported_app)
      : undefined;
    return message;
  },
};

function createBasePool(): Pool {
  return {
    exchange: "",
    plane: 0,
    pool_id: "",
    token0_volume: "",
    token1_volume: "",
    token0_liquidity: "",
    token1_liquidity: "",
    swap_count: "0",
  };
}

export const Pool = {
  $type: "flux.indexer.explorer.Pool" as const,

  encode(message: Pool, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.exchange !== "") {
      writer.uint32(10).string(message.exchange);
    }
    if (message.plane !== 0) {
      writer.uint32(16).int32(message.plane);
    }
    if (message.pool_id !== "") {
      writer.uint32(26).string(message.pool_id);
    }
    if (message.token0_volume !== "") {
      writer.uint32(34).string(message.token0_volume);
    }
    if (message.token1_volume !== "") {
      writer.uint32(42).string(message.token1_volume);
    }
    if (message.token0_liquidity !== "") {
      writer.uint32(50).string(message.token0_liquidity);
    }
    if (message.token1_liquidity !== "") {
      writer.uint32(58).string(message.token1_liquidity);
    }
    if (message.swap_count !== "0") {
      writer.uint32(64).int64(message.swap_count);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Pool {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.exchange = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.plane = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pool_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.token0_volume = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.token1_volume = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.token0_liquidity = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.token1_liquidity = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.swap_count = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pool {
    return {
      exchange: isSet(object.exchange) ? globalThis.String(object.exchange) : "",
      plane: isSet(object.plane) ? planeFromJSON(object.plane) : 0,
      pool_id: isSet(object.pool_id) ? globalThis.String(object.pool_id) : "",
      token0_volume: isSet(object.token0_volume) ? globalThis.String(object.token0_volume) : "",
      token1_volume: isSet(object.token1_volume) ? globalThis.String(object.token1_volume) : "",
      token0_liquidity: isSet(object.token0_liquidity) ? globalThis.String(object.token0_liquidity) : "",
      token1_liquidity: isSet(object.token1_liquidity) ? globalThis.String(object.token1_liquidity) : "",
      swap_count: isSet(object.swap_count) ? globalThis.String(object.swap_count) : "0",
    };
  },

  toJSON(message: Pool): unknown {
    const obj: any = {};
    if (message.exchange !== undefined) {
      obj.exchange = message.exchange;
    }
    if (message.plane !== undefined) {
      obj.plane = planeToJSON(message.plane);
    }
    if (message.pool_id !== undefined) {
      obj.pool_id = message.pool_id;
    }
    if (message.token0_volume !== undefined) {
      obj.token0_volume = message.token0_volume;
    }
    if (message.token1_volume !== undefined) {
      obj.token1_volume = message.token1_volume;
    }
    if (message.token0_liquidity !== undefined) {
      obj.token0_liquidity = message.token0_liquidity;
    }
    if (message.token1_liquidity !== undefined) {
      obj.token1_liquidity = message.token1_liquidity;
    }
    if (message.swap_count !== undefined) {
      obj.swap_count = message.swap_count;
    }
    return obj;
  },

  create(base?: DeepPartial<Pool>): Pool {
    return Pool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Pool>): Pool {
    const message = createBasePool();
    message.exchange = object.exchange ?? "";
    message.plane = object.plane ?? 0;
    message.pool_id = object.pool_id ?? "";
    message.token0_volume = object.token0_volume ?? "";
    message.token1_volume = object.token1_volume ?? "";
    message.token0_liquidity = object.token0_liquidity ?? "";
    message.token1_liquidity = object.token1_liquidity ?? "";
    message.swap_count = object.swap_count ?? "0";
    return message;
  },
};

function createBaseMetrics(): Metrics {
  return { tx_count: "0", block_count: "0", pools: [] };
}

export const Metrics = {
  $type: "flux.indexer.explorer.Metrics" as const,

  encode(message: Metrics, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tx_count !== "0") {
      writer.uint32(8).int64(message.tx_count);
    }
    if (message.block_count !== "0") {
      writer.uint32(16).int64(message.block_count);
    }
    for (const v of message.pools) {
      Pool.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Metrics {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tx_count = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.block_count = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pools.push(Pool.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metrics {
    return {
      tx_count: isSet(object.tx_count) ? globalThis.String(object.tx_count) : "0",
      block_count: isSet(object.block_count) ? globalThis.String(object.block_count) : "0",
      pools: globalThis.Array.isArray(object?.pools) ? object.pools.map((e: any) => Pool.fromJSON(e)) : [],
    };
  },

  toJSON(message: Metrics): unknown {
    const obj: any = {};
    if (message.tx_count !== undefined) {
      obj.tx_count = message.tx_count;
    }
    if (message.block_count !== undefined) {
      obj.block_count = message.block_count;
    }
    if (message.pools?.length) {
      obj.pools = message.pools.map((e) => Pool.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Metrics>): Metrics {
    return Metrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Metrics>): Metrics {
    const message = createBaseMetrics();
    message.tx_count = object.tx_count ?? "0";
    message.block_count = object.block_count ?? "0";
    message.pools = object.pools?.map((e) => Pool.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetMetricsRequest(): GetMetricsRequest {
  return {};
}

export const GetMetricsRequest = {
  $type: "flux.indexer.explorer.GetMetricsRequest" as const,

  encode(_: GetMetricsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMetricsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetMetricsRequest {
    return {};
  },

  toJSON(_: GetMetricsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetMetricsRequest>): GetMetricsRequest {
    return GetMetricsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetMetricsRequest>): GetMetricsRequest {
    const message = createBaseGetMetricsRequest();
    return message;
  },
};

function createBaseGetMetricsResponse(): GetMetricsResponse {
  return { data: undefined };
}

export const GetMetricsResponse = {
  $type: "flux.indexer.explorer.GetMetricsResponse" as const,

  encode(message: GetMetricsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data !== undefined) {
      Metrics.encode(message.data, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMetricsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = Metrics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMetricsResponse {
    return { data: isSet(object.data) ? Metrics.fromJSON(object.data) : undefined };
  },

  toJSON(message: GetMetricsResponse): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = Metrics.toJSON(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<GetMetricsResponse>): GetMetricsResponse {
    return GetMetricsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMetricsResponse>): GetMetricsResponse {
    const message = createBaseGetMetricsResponse();
    message.data = (object.data !== undefined && object.data !== null) ? Metrics.fromPartial(object.data) : undefined;
    return message;
  },
};

function createBaseStreamBalanceResponse(): StreamBalanceResponse {
  return { height: "0", deleted: "0", balances: [] };
}

export const StreamBalanceResponse = {
  $type: "flux.indexer.explorer.StreamBalanceResponse" as const,

  encode(message: StreamBalanceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).uint64(message.height);
    }
    if (message.deleted !== "0") {
      writer.uint32(16).uint64(message.deleted);
    }
    for (const v of message.balances) {
      BalanceInfo.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamBalanceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamBalanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.balances.push(BalanceInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamBalanceResponse {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "0",
      balances: globalThis.Array.isArray(object?.balances)
        ? object.balances.map((e: any) => BalanceInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamBalanceResponse): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.balances?.length) {
      obj.balances = message.balances.map((e) => BalanceInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StreamBalanceResponse>): StreamBalanceResponse {
    return StreamBalanceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamBalanceResponse>): StreamBalanceResponse {
    const message = createBaseStreamBalanceResponse();
    message.height = object.height ?? "0";
    message.deleted = object.deleted ?? "0";
    message.balances = object.balances?.map((e) => BalanceInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListStrategyTriggerByIdRequest(): ListStrategyTriggerByIdRequest {
  return { pagination: undefined, id: "", from_time: "0", to_time: "0", success: undefined };
}

export const ListStrategyTriggerByIdRequest = {
  $type: "flux.indexer.explorer.ListStrategyTriggerByIdRequest" as const,

  encode(message: ListStrategyTriggerByIdRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.from_time !== "0") {
      writer.uint32(24).int64(message.from_time);
    }
    if (message.to_time !== "0") {
      writer.uint32(32).int64(message.to_time);
    }
    if (message.success !== undefined) {
      BoolValue.encode({ value: message.success! }, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListStrategyTriggerByIdRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStrategyTriggerByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.from_time = longToString(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.to_time = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.success = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStrategyTriggerByIdRequest {
    return {
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      from_time: isSet(object.from_time) ? globalThis.String(object.from_time) : "0",
      to_time: isSet(object.to_time) ? globalThis.String(object.to_time) : "0",
      success: isSet(object.success) ? Boolean(object.success) : undefined,
    };
  },

  toJSON(message: ListStrategyTriggerByIdRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.from_time !== undefined) {
      obj.from_time = message.from_time;
    }
    if (message.to_time !== undefined) {
      obj.to_time = message.to_time;
    }
    if (message.success !== undefined) {
      obj.success = message.success;
    }
    return obj;
  },

  create(base?: DeepPartial<ListStrategyTriggerByIdRequest>): ListStrategyTriggerByIdRequest {
    return ListStrategyTriggerByIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListStrategyTriggerByIdRequest>): ListStrategyTriggerByIdRequest {
    const message = createBaseListStrategyTriggerByIdRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    message.id = object.id ?? "";
    message.from_time = object.from_time ?? "0";
    message.to_time = object.to_time ?? "0";
    message.success = object.success ?? undefined;
    return message;
  },
};

function createBaseListStrategyTriggerByIdResponse(): ListStrategyTriggerByIdResponse {
  return { pagination: undefined, triggers: [] };
}

export const ListStrategyTriggerByIdResponse = {
  $type: "flux.indexer.explorer.ListStrategyTriggerByIdResponse" as const,

  encode(message: ListStrategyTriggerByIdResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.triggers) {
      StrategyTriggerEvent.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListStrategyTriggerByIdResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStrategyTriggerByIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.triggers.push(StrategyTriggerEvent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStrategyTriggerByIdResponse {
    return {
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
      triggers: globalThis.Array.isArray(object?.triggers)
        ? object.triggers.map((e: any) => StrategyTriggerEvent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListStrategyTriggerByIdResponse): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    if (message.triggers?.length) {
      obj.triggers = message.triggers.map((e) => StrategyTriggerEvent.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListStrategyTriggerByIdResponse>): ListStrategyTriggerByIdResponse {
    return ListStrategyTriggerByIdResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListStrategyTriggerByIdResponse>): ListStrategyTriggerByIdResponse {
    const message = createBaseListStrategyTriggerByIdResponse();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    message.triggers = object.triggers?.map((e) => StrategyTriggerEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStreamStrategyTriggerRequest(): StreamStrategyTriggerRequest {
  return { id: [] };
}

export const StreamStrategyTriggerRequest = {
  $type: "flux.indexer.explorer.StreamStrategyTriggerRequest" as const,

  encode(message: StreamStrategyTriggerRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.id) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamStrategyTriggerRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamStrategyTriggerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamStrategyTriggerRequest {
    return { id: globalThis.Array.isArray(object?.id) ? object.id.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: StreamStrategyTriggerRequest): unknown {
    const obj: any = {};
    if (message.id?.length) {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamStrategyTriggerRequest>): StreamStrategyTriggerRequest {
    return StreamStrategyTriggerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamStrategyTriggerRequest>): StreamStrategyTriggerRequest {
    const message = createBaseStreamStrategyTriggerRequest();
    message.id = object.id?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamStrategyTriggerResponse(): StreamStrategyTriggerResponse {
  return { height: "0", deleted: "0", triggers: [] };
}

export const StreamStrategyTriggerResponse = {
  $type: "flux.indexer.explorer.StreamStrategyTriggerResponse" as const,

  encode(message: StreamStrategyTriggerResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).uint64(message.height);
    }
    if (message.deleted !== "0") {
      writer.uint32(16).uint64(message.deleted);
    }
    for (const v of message.triggers) {
      StrategyTriggerEvent.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamStrategyTriggerResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamStrategyTriggerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.triggers.push(StrategyTriggerEvent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamStrategyTriggerResponse {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "0",
      triggers: globalThis.Array.isArray(object?.triggers)
        ? object.triggers.map((e: any) => StrategyTriggerEvent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamStrategyTriggerResponse): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.triggers?.length) {
      obj.triggers = message.triggers.map((e) => StrategyTriggerEvent.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StreamStrategyTriggerResponse>): StreamStrategyTriggerResponse {
    return StreamStrategyTriggerResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamStrategyTriggerResponse>): StreamStrategyTriggerResponse {
    const message = createBaseStreamStrategyTriggerResponse();
    message.height = object.height ?? "0";
    message.deleted = object.deleted ?? "0";
    message.triggers = object.triggers?.map((e) => StrategyTriggerEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStreamStrategiesRequest(): StreamStrategiesRequest {
  return { owner: "", type: undefined, tags: [], supported_app: undefined };
}

export const StreamStrategiesRequest = {
  $type: "flux.indexer.explorer.StreamStrategiesRequest" as const,

  encode(message: StreamStrategiesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.type !== undefined) {
      TypeFilter.encode(message.type, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.tags) {
      writer.uint32(26).string(v!);
    }
    if (message.supported_app !== undefined) {
      SupportedAppFilter.encode(message.supported_app, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamStrategiesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamStrategiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = TypeFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.supported_app = SupportedAppFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamStrategiesRequest {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      type: isSet(object.type) ? TypeFilter.fromJSON(object.type) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      supported_app: isSet(object.supported_app) ? SupportedAppFilter.fromJSON(object.supported_app) : undefined,
    };
  },

  toJSON(message: StreamStrategiesRequest): unknown {
    const obj: any = {};
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.type !== undefined) {
      obj.type = TypeFilter.toJSON(message.type);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.supported_app !== undefined) {
      obj.supported_app = SupportedAppFilter.toJSON(message.supported_app);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamStrategiesRequest>): StreamStrategiesRequest {
    return StreamStrategiesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamStrategiesRequest>): StreamStrategiesRequest {
    const message = createBaseStreamStrategiesRequest();
    message.owner = object.owner ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? TypeFilter.fromPartial(object.type)
      : undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.supported_app = (object.supported_app !== undefined && object.supported_app !== null)
      ? SupportedAppFilter.fromPartial(object.supported_app)
      : undefined;
    return message;
  },
};

function createBaseStreamStrategiesResponse(): StreamStrategiesResponse {
  return { height: "0", deleted: "0", strategies: [] };
}

export const StreamStrategiesResponse = {
  $type: "flux.indexer.explorer.StreamStrategiesResponse" as const,

  encode(message: StreamStrategiesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).uint64(message.height);
    }
    if (message.deleted !== "0") {
      writer.uint32(16).uint64(message.deleted);
    }
    for (const v of message.strategies) {
      Strategy.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamStrategiesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamStrategiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.strategies.push(Strategy.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamStrategiesResponse {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "0",
      strategies: globalThis.Array.isArray(object?.strategies)
        ? object.strategies.map((e: any) => Strategy.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamStrategiesResponse): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.strategies?.length) {
      obj.strategies = message.strategies.map((e) => Strategy.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StreamStrategiesResponse>): StreamStrategiesResponse {
    return StreamStrategiesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamStrategiesResponse>): StreamStrategiesResponse {
    const message = createBaseStreamStrategiesResponse();
    message.height = object.height ?? "0";
    message.deleted = object.deleted ?? "0";
    message.strategies = object.strategies?.map((e) => Strategy.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListTokenMetadataRequest(): ListTokenMetadataRequest {
  return { pagination: undefined };
}

export const ListTokenMetadataRequest = {
  $type: "flux.indexer.explorer.ListTokenMetadataRequest" as const,

  encode(message: ListTokenMetadataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTokenMetadataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTokenMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTokenMetadataRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: ListTokenMetadataRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListTokenMetadataRequest>): ListTokenMetadataRequest {
    return ListTokenMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTokenMetadataRequest>): ListTokenMetadataRequest {
    const message = createBaseListTokenMetadataRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListTokenMetadataResponse(): ListTokenMetadataResponse {
  return { pagination: undefined, metadata: [] };
}

export const ListTokenMetadataResponse = {
  $type: "flux.indexer.explorer.ListTokenMetadataResponse" as const,

  encode(message: ListTokenMetadataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.metadata) {
      TokenMetadata.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTokenMetadataResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTokenMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metadata.push(TokenMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTokenMetadataResponse {
    return {
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
      metadata: globalThis.Array.isArray(object?.metadata)
        ? object.metadata.map((e: any) => TokenMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListTokenMetadataResponse): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata.map((e) => TokenMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListTokenMetadataResponse>): ListTokenMetadataResponse {
    return ListTokenMetadataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTokenMetadataResponse>): ListTokenMetadataResponse {
    const message = createBaseListTokenMetadataResponse();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    message.metadata = object.metadata?.map((e) => TokenMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStreamTokenMetadataRequest(): StreamTokenMetadataRequest {
  return {};
}

export const StreamTokenMetadataRequest = {
  $type: "flux.indexer.explorer.StreamTokenMetadataRequest" as const,

  encode(_: StreamTokenMetadataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamTokenMetadataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamTokenMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StreamTokenMetadataRequest {
    return {};
  },

  toJSON(_: StreamTokenMetadataRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<StreamTokenMetadataRequest>): StreamTokenMetadataRequest {
    return StreamTokenMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<StreamTokenMetadataRequest>): StreamTokenMetadataRequest {
    const message = createBaseStreamTokenMetadataRequest();
    return message;
  },
};

function createBaseStreamTokenMetadataResponse(): StreamTokenMetadataResponse {
  return { height: "0", deleted: "0", metadata: [] };
}

export const StreamTokenMetadataResponse = {
  $type: "flux.indexer.explorer.StreamTokenMetadataResponse" as const,

  encode(message: StreamTokenMetadataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).uint64(message.height);
    }
    if (message.deleted !== "0") {
      writer.uint32(16).uint64(message.deleted);
    }
    for (const v of message.metadata) {
      TokenMetadata.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamTokenMetadataResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamTokenMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadata.push(TokenMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamTokenMetadataResponse {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "0",
      metadata: globalThis.Array.isArray(object?.metadata)
        ? object.metadata.map((e: any) => TokenMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamTokenMetadataResponse): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata.map((e) => TokenMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StreamTokenMetadataResponse>): StreamTokenMetadataResponse {
    return StreamTokenMetadataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamTokenMetadataResponse>): StreamTokenMetadataResponse {
    const message = createBaseStreamTokenMetadataResponse();
    message.height = object.height ?? "0";
    message.deleted = object.deleted ?? "0";
    message.metadata = object.metadata?.map((e) => TokenMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListSvmAccountLinksRequest(): ListSvmAccountLinksRequest {
  return { cosmos_addr: "", svm_addr: "", pagination: undefined };
}

export const ListSvmAccountLinksRequest = {
  $type: "flux.indexer.explorer.ListSvmAccountLinksRequest" as const,

  encode(message: ListSvmAccountLinksRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cosmos_addr !== "") {
      writer.uint32(10).string(message.cosmos_addr);
    }
    if (message.svm_addr !== "") {
      writer.uint32(18).string(message.svm_addr);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSvmAccountLinksRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSvmAccountLinksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cosmos_addr = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.svm_addr = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSvmAccountLinksRequest {
    return {
      cosmos_addr: isSet(object.cosmos_addr) ? globalThis.String(object.cosmos_addr) : "",
      svm_addr: isSet(object.svm_addr) ? globalThis.String(object.svm_addr) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListSvmAccountLinksRequest): unknown {
    const obj: any = {};
    if (message.cosmos_addr !== undefined) {
      obj.cosmos_addr = message.cosmos_addr;
    }
    if (message.svm_addr !== undefined) {
      obj.svm_addr = message.svm_addr;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListSvmAccountLinksRequest>): ListSvmAccountLinksRequest {
    return ListSvmAccountLinksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSvmAccountLinksRequest>): ListSvmAccountLinksRequest {
    const message = createBaseListSvmAccountLinksRequest();
    message.cosmos_addr = object.cosmos_addr ?? "";
    message.svm_addr = object.svm_addr ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListSvmAccountLinksResponse(): ListSvmAccountLinksResponse {
  return { pagination: undefined, account_links: [] };
}

export const ListSvmAccountLinksResponse = {
  $type: "flux.indexer.explorer.ListSvmAccountLinksResponse" as const,

  encode(message: ListSvmAccountLinksResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.account_links) {
      AccountLink.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSvmAccountLinksResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSvmAccountLinksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.account_links.push(AccountLink.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSvmAccountLinksResponse {
    return {
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
      account_links: globalThis.Array.isArray(object?.account_links)
        ? object.account_links.map((e: any) => AccountLink.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListSvmAccountLinksResponse): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    if (message.account_links?.length) {
      obj.account_links = message.account_links.map((e) => AccountLink.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListSvmAccountLinksResponse>): ListSvmAccountLinksResponse {
    return ListSvmAccountLinksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSvmAccountLinksResponse>): ListSvmAccountLinksResponse {
    const message = createBaseListSvmAccountLinksResponse();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    message.account_links = object.account_links?.map((e) => AccountLink.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStreamSvmAccountLinkRequest(): StreamSvmAccountLinkRequest {
  return { cosmos_address: "", svm_address: "" };
}

export const StreamSvmAccountLinkRequest = {
  $type: "flux.indexer.explorer.StreamSvmAccountLinkRequest" as const,

  encode(message: StreamSvmAccountLinkRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cosmos_address !== "") {
      writer.uint32(10).string(message.cosmos_address);
    }
    if (message.svm_address !== "") {
      writer.uint32(18).string(message.svm_address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamSvmAccountLinkRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamSvmAccountLinkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cosmos_address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.svm_address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamSvmAccountLinkRequest {
    return {
      cosmos_address: isSet(object.cosmos_address) ? globalThis.String(object.cosmos_address) : "",
      svm_address: isSet(object.svm_address) ? globalThis.String(object.svm_address) : "",
    };
  },

  toJSON(message: StreamSvmAccountLinkRequest): unknown {
    const obj: any = {};
    if (message.cosmos_address !== undefined) {
      obj.cosmos_address = message.cosmos_address;
    }
    if (message.svm_address !== undefined) {
      obj.svm_address = message.svm_address;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamSvmAccountLinkRequest>): StreamSvmAccountLinkRequest {
    return StreamSvmAccountLinkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamSvmAccountLinkRequest>): StreamSvmAccountLinkRequest {
    const message = createBaseStreamSvmAccountLinkRequest();
    message.cosmos_address = object.cosmos_address ?? "";
    message.svm_address = object.svm_address ?? "";
    return message;
  },
};

function createBaseStreamSvmAccountLinkResponse(): StreamSvmAccountLinkResponse {
  return { height: "0", deleted: "0", account_link: [] };
}

export const StreamSvmAccountLinkResponse = {
  $type: "flux.indexer.explorer.StreamSvmAccountLinkResponse" as const,

  encode(message: StreamSvmAccountLinkResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).uint64(message.height);
    }
    if (message.deleted !== "0") {
      writer.uint32(16).uint64(message.deleted);
    }
    for (const v of message.account_link) {
      AccountLink.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamSvmAccountLinkResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamSvmAccountLinkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.account_link.push(AccountLink.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamSvmAccountLinkResponse {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "0",
      account_link: globalThis.Array.isArray(object?.account_link)
        ? object.account_link.map((e: any) => AccountLink.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamSvmAccountLinkResponse): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.account_link?.length) {
      obj.account_link = message.account_link.map((e) => AccountLink.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StreamSvmAccountLinkResponse>): StreamSvmAccountLinkResponse {
    return StreamSvmAccountLinkResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamSvmAccountLinkResponse>): StreamSvmAccountLinkResponse {
    const message = createBaseStreamSvmAccountLinkResponse();
    message.height = object.height ?? "0";
    message.deleted = object.deleted ?? "0";
    message.account_link = object.account_link?.map((e) => AccountLink.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListDriftOrdersRequest(): ListDriftOrdersRequest {
  return { market_name: "" };
}

export const ListDriftOrdersRequest = {
  $type: "flux.indexer.explorer.ListDriftOrdersRequest" as const,

  encode(message: ListDriftOrdersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.market_name !== "") {
      writer.uint32(10).string(message.market_name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDriftOrdersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDriftOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.market_name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDriftOrdersRequest {
    return { market_name: isSet(object.market_name) ? globalThis.String(object.market_name) : "" };
  },

  toJSON(message: ListDriftOrdersRequest): unknown {
    const obj: any = {};
    if (message.market_name !== undefined) {
      obj.market_name = message.market_name;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDriftOrdersRequest>): ListDriftOrdersRequest {
    return ListDriftOrdersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDriftOrdersRequest>): ListDriftOrdersRequest {
    const message = createBaseListDriftOrdersRequest();
    message.market_name = object.market_name ?? "";
    return message;
  },
};

function createBaseListDriftOrdersResponse(): ListDriftOrdersResponse {
  return { orders: [] };
}

export const ListDriftOrdersResponse = {
  $type: "flux.indexer.explorer.ListDriftOrdersResponse" as const,

  encode(message: ListDriftOrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orders) {
      DriftOrder.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDriftOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDriftOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orders.push(DriftOrder.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDriftOrdersResponse {
    return {
      orders: globalThis.Array.isArray(object?.orders) ? object.orders.map((e: any) => DriftOrder.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListDriftOrdersResponse): unknown {
    const obj: any = {};
    if (message.orders?.length) {
      obj.orders = message.orders.map((e) => DriftOrder.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListDriftOrdersResponse>): ListDriftOrdersResponse {
    return ListDriftOrdersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDriftOrdersResponse>): ListDriftOrdersResponse {
    const message = createBaseListDriftOrdersResponse();
    message.orders = object.orders?.map((e) => DriftOrder.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListFillableDriftJITOrdersRequest(): ListFillableDriftJITOrdersRequest {
  return { market_name: "", worst_price: "0", direction: 0, quantity: "0" };
}

export const ListFillableDriftJITOrdersRequest = {
  $type: "flux.indexer.explorer.ListFillableDriftJITOrdersRequest" as const,

  encode(message: ListFillableDriftJITOrdersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.market_name !== "") {
      writer.uint32(10).string(message.market_name);
    }
    if (message.worst_price !== "0") {
      writer.uint32(16).uint64(message.worst_price);
    }
    if (message.direction !== 0) {
      writer.uint32(24).int32(message.direction);
    }
    if (message.quantity !== "0") {
      writer.uint32(32).uint64(message.quantity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListFillableDriftJITOrdersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFillableDriftJITOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.market_name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.worst_price = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.quantity = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFillableDriftJITOrdersRequest {
    return {
      market_name: isSet(object.market_name) ? globalThis.String(object.market_name) : "",
      worst_price: isSet(object.worst_price) ? globalThis.String(object.worst_price) : "0",
      direction: isSet(object.direction) ? orderDirectionFromJSON(object.direction) : 0,
      quantity: isSet(object.quantity) ? globalThis.String(object.quantity) : "0",
    };
  },

  toJSON(message: ListFillableDriftJITOrdersRequest): unknown {
    const obj: any = {};
    if (message.market_name !== undefined) {
      obj.market_name = message.market_name;
    }
    if (message.worst_price !== undefined) {
      obj.worst_price = message.worst_price;
    }
    if (message.direction !== undefined) {
      obj.direction = orderDirectionToJSON(message.direction);
    }
    if (message.quantity !== undefined) {
      obj.quantity = message.quantity;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFillableDriftJITOrdersRequest>): ListFillableDriftJITOrdersRequest {
    return ListFillableDriftJITOrdersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFillableDriftJITOrdersRequest>): ListFillableDriftJITOrdersRequest {
    const message = createBaseListFillableDriftJITOrdersRequest();
    message.market_name = object.market_name ?? "";
    message.worst_price = object.worst_price ?? "0";
    message.direction = object.direction ?? 0;
    message.quantity = object.quantity ?? "0";
    return message;
  },
};

function createBaseListFillableDriftJITOrdersResponse(): ListFillableDriftJITOrdersResponse {
  return { fillable_orders: [] };
}

export const ListFillableDriftJITOrdersResponse = {
  $type: "flux.indexer.explorer.ListFillableDriftJITOrdersResponse" as const,

  encode(message: ListFillableDriftJITOrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.fillable_orders) {
      DriftOrder.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListFillableDriftJITOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFillableDriftJITOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fillable_orders.push(DriftOrder.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFillableDriftJITOrdersResponse {
    return {
      fillable_orders: globalThis.Array.isArray(object?.fillable_orders)
        ? object.fillable_orders.map((e: any) => DriftOrder.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListFillableDriftJITOrdersResponse): unknown {
    const obj: any = {};
    if (message.fillable_orders?.length) {
      obj.fillable_orders = message.fillable_orders.map((e) => DriftOrder.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListFillableDriftJITOrdersResponse>): ListFillableDriftJITOrdersResponse {
    return ListFillableDriftJITOrdersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFillableDriftJITOrdersResponse>): ListFillableDriftJITOrdersResponse {
    const message = createBaseListFillableDriftJITOrdersResponse();
    message.fillable_orders = object.fillable_orders?.map((e) => DriftOrder.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDriftOrder(): DriftOrder {
  return {
    subaccount_address: "",
    owner_address: "",
    price: "0",
    total_quantity: "0",
    market_name: "",
    order_id: 0,
    auction_start_price: "0",
    auction_end_price: "0",
    slot: "0",
    auction_duration: 0,
    expired_at: "0",
    direction: 0,
    fillable_quantity: "0",
  };
}

export const DriftOrder = {
  $type: "flux.indexer.explorer.DriftOrder" as const,

  encode(message: DriftOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccount_address !== "") {
      writer.uint32(10).string(message.subaccount_address);
    }
    if (message.owner_address !== "") {
      writer.uint32(18).string(message.owner_address);
    }
    if (message.price !== "0") {
      writer.uint32(24).uint64(message.price);
    }
    if (message.total_quantity !== "0") {
      writer.uint32(32).uint64(message.total_quantity);
    }
    if (message.market_name !== "") {
      writer.uint32(42).string(message.market_name);
    }
    if (message.order_id !== 0) {
      writer.uint32(48).uint32(message.order_id);
    }
    if (message.auction_start_price !== "0") {
      writer.uint32(56).int64(message.auction_start_price);
    }
    if (message.auction_end_price !== "0") {
      writer.uint32(64).int64(message.auction_end_price);
    }
    if (message.slot !== "0") {
      writer.uint32(72).uint64(message.slot);
    }
    if (message.auction_duration !== 0) {
      writer.uint32(80).uint32(message.auction_duration);
    }
    if (message.expired_at !== "0") {
      writer.uint32(88).int64(message.expired_at);
    }
    if (message.direction !== 0) {
      writer.uint32(96).int32(message.direction);
    }
    if (message.fillable_quantity !== "0") {
      writer.uint32(104).uint64(message.fillable_quantity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DriftOrder {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDriftOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subaccount_address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.owner_address = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.price = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.total_quantity = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.market_name = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.order_id = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.auction_start_price = longToString(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.auction_end_price = longToString(reader.int64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.slot = longToString(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.auction_duration = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.expired_at = longToString(reader.int64() as Long);
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.fillable_quantity = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DriftOrder {
    return {
      subaccount_address: isSet(object.subaccount_address) ? globalThis.String(object.subaccount_address) : "",
      owner_address: isSet(object.owner_address) ? globalThis.String(object.owner_address) : "",
      price: isSet(object.price) ? globalThis.String(object.price) : "0",
      total_quantity: isSet(object.total_quantity) ? globalThis.String(object.total_quantity) : "0",
      market_name: isSet(object.market_name) ? globalThis.String(object.market_name) : "",
      order_id: isSet(object.order_id) ? globalThis.Number(object.order_id) : 0,
      auction_start_price: isSet(object.auction_start_price) ? globalThis.String(object.auction_start_price) : "0",
      auction_end_price: isSet(object.auction_end_price) ? globalThis.String(object.auction_end_price) : "0",
      slot: isSet(object.slot) ? globalThis.String(object.slot) : "0",
      auction_duration: isSet(object.auction_duration) ? globalThis.Number(object.auction_duration) : 0,
      expired_at: isSet(object.expired_at) ? globalThis.String(object.expired_at) : "0",
      direction: isSet(object.direction) ? orderDirectionFromJSON(object.direction) : 0,
      fillable_quantity: isSet(object.fillable_quantity) ? globalThis.String(object.fillable_quantity) : "0",
    };
  },

  toJSON(message: DriftOrder): unknown {
    const obj: any = {};
    if (message.subaccount_address !== undefined) {
      obj.subaccount_address = message.subaccount_address;
    }
    if (message.owner_address !== undefined) {
      obj.owner_address = message.owner_address;
    }
    if (message.price !== undefined) {
      obj.price = message.price;
    }
    if (message.total_quantity !== undefined) {
      obj.total_quantity = message.total_quantity;
    }
    if (message.market_name !== undefined) {
      obj.market_name = message.market_name;
    }
    if (message.order_id !== undefined) {
      obj.order_id = Math.round(message.order_id);
    }
    if (message.auction_start_price !== undefined) {
      obj.auction_start_price = message.auction_start_price;
    }
    if (message.auction_end_price !== undefined) {
      obj.auction_end_price = message.auction_end_price;
    }
    if (message.slot !== undefined) {
      obj.slot = message.slot;
    }
    if (message.auction_duration !== undefined) {
      obj.auction_duration = Math.round(message.auction_duration);
    }
    if (message.expired_at !== undefined) {
      obj.expired_at = message.expired_at;
    }
    if (message.direction !== undefined) {
      obj.direction = orderDirectionToJSON(message.direction);
    }
    if (message.fillable_quantity !== undefined) {
      obj.fillable_quantity = message.fillable_quantity;
    }
    return obj;
  },

  create(base?: DeepPartial<DriftOrder>): DriftOrder {
    return DriftOrder.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DriftOrder>): DriftOrder {
    const message = createBaseDriftOrder();
    message.subaccount_address = object.subaccount_address ?? "";
    message.owner_address = object.owner_address ?? "";
    message.price = object.price ?? "0";
    message.total_quantity = object.total_quantity ?? "0";
    message.market_name = object.market_name ?? "";
    message.order_id = object.order_id ?? 0;
    message.auction_start_price = object.auction_start_price ?? "0";
    message.auction_end_price = object.auction_end_price ?? "0";
    message.slot = object.slot ?? "0";
    message.auction_duration = object.auction_duration ?? 0;
    message.expired_at = object.expired_at ?? "0";
    message.direction = object.direction ?? 0;
    message.fillable_quantity = object.fillable_quantity ?? "0";
    return message;
  },
};

function createBaseStreamDriftOrdersRequest(): StreamDriftOrdersRequest {
  return { market_name: "", price: "0", direction: "" };
}

export const StreamDriftOrdersRequest = {
  $type: "flux.indexer.explorer.StreamDriftOrdersRequest" as const,

  encode(message: StreamDriftOrdersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.market_name !== "") {
      writer.uint32(10).string(message.market_name);
    }
    if (message.price !== "0") {
      writer.uint32(16).uint64(message.price);
    }
    if (message.direction !== "") {
      writer.uint32(26).string(message.direction);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamDriftOrdersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamDriftOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.market_name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.price = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.direction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamDriftOrdersRequest {
    return {
      market_name: isSet(object.market_name) ? globalThis.String(object.market_name) : "",
      price: isSet(object.price) ? globalThis.String(object.price) : "0",
      direction: isSet(object.direction) ? globalThis.String(object.direction) : "",
    };
  },

  toJSON(message: StreamDriftOrdersRequest): unknown {
    const obj: any = {};
    if (message.market_name !== undefined) {
      obj.market_name = message.market_name;
    }
    if (message.price !== undefined) {
      obj.price = message.price;
    }
    if (message.direction !== undefined) {
      obj.direction = message.direction;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamDriftOrdersRequest>): StreamDriftOrdersRequest {
    return StreamDriftOrdersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamDriftOrdersRequest>): StreamDriftOrdersRequest {
    const message = createBaseStreamDriftOrdersRequest();
    message.market_name = object.market_name ?? "";
    message.price = object.price ?? "0";
    message.direction = object.direction ?? "";
    return message;
  },
};

function createBaseStreamDriftOrdersResponse(): StreamDriftOrdersResponse {
  return { height: "0", deleted: "0", order: undefined };
}

export const StreamDriftOrdersResponse = {
  $type: "flux.indexer.explorer.StreamDriftOrdersResponse" as const,

  encode(message: StreamDriftOrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.height !== "0") {
      writer.uint32(8).uint64(message.height);
    }
    if (message.deleted !== "0") {
      writer.uint32(16).uint64(message.deleted);
    }
    if (message.order !== undefined) {
      DriftOrder.encode(message.order, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamDriftOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamDriftOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.order = DriftOrder.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamDriftOrdersResponse {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "0",
      order: isSet(object.order) ? DriftOrder.fromJSON(object.order) : undefined,
    };
  },

  toJSON(message: StreamDriftOrdersResponse): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.order !== undefined) {
      obj.order = DriftOrder.toJSON(message.order);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamDriftOrdersResponse>): StreamDriftOrdersResponse {
    return StreamDriftOrdersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamDriftOrdersResponse>): StreamDriftOrdersResponse {
    const message = createBaseStreamDriftOrdersResponse();
    message.height = object.height ?? "0";
    message.deleted = object.deleted ?? "0";
    message.order = (object.order !== undefined && object.order !== null)
      ? DriftOrder.fromPartial(object.order)
      : undefined;
    return message;
  },
};

export interface API {
  ListEvmContracts(
    request: DeepPartial<ListEvmContractsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListEvmContractsResponse>;
  Balances(request: DeepPartial<BalancesRequest>, metadata?: grpc.Metadata): Promise<BalancesResponse>;
  ListStrategies(
    request: DeepPartial<ListStrategiesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListStrategiesResponse>;
  ListStrategiesByOwner(
    request: DeepPartial<ListStrategiesByOwnerRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListStrategiesResponse>;
  GetMetrics(request: DeepPartial<GetMetricsRequest>, metadata?: grpc.Metadata): Promise<GetMetricsResponse>;
  ListStrategyTriggersById(
    request: DeepPartial<ListStrategyTriggerByIdRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListStrategyTriggerByIdResponse>;
  ListTokenMetadata(
    request: DeepPartial<ListTokenMetadataRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListTokenMetadataResponse>;
  ListSvmAccountLinks(
    request: DeepPartial<ListSvmAccountLinksRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListSvmAccountLinksResponse>;
  StreamBalances(request: DeepPartial<BalancesRequest>, metadata?: grpc.Metadata): Observable<StreamBalanceResponse>;
  StreamStrategyTriggers(
    request: DeepPartial<StreamStrategyTriggerRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamStrategyTriggerResponse>;
  StreamStrategies(
    request: DeepPartial<StreamStrategiesRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamStrategiesResponse>;
  StreamTokenMetadata(
    request: DeepPartial<StreamTokenMetadataRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamTokenMetadataResponse>;
  StreamSvmAccountLink(
    request: DeepPartial<StreamSvmAccountLinkRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamSvmAccountLinkResponse>;
  ListDriftOrders(
    request: DeepPartial<ListDriftOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListDriftOrdersResponse>;
  ListFillableDriftJITOrders(
    request: DeepPartial<ListFillableDriftJITOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListFillableDriftJITOrdersResponse>;
  StreamDriftOrders(
    request: DeepPartial<StreamDriftOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamDriftOrdersResponse>;
}

export class APIClientImpl implements API {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.ListEvmContracts = this.ListEvmContracts.bind(this);
    this.Balances = this.Balances.bind(this);
    this.ListStrategies = this.ListStrategies.bind(this);
    this.ListStrategiesByOwner = this.ListStrategiesByOwner.bind(this);
    this.GetMetrics = this.GetMetrics.bind(this);
    this.ListStrategyTriggersById = this.ListStrategyTriggersById.bind(this);
    this.ListTokenMetadata = this.ListTokenMetadata.bind(this);
    this.ListSvmAccountLinks = this.ListSvmAccountLinks.bind(this);
    this.StreamBalances = this.StreamBalances.bind(this);
    this.StreamStrategyTriggers = this.StreamStrategyTriggers.bind(this);
    this.StreamStrategies = this.StreamStrategies.bind(this);
    this.StreamTokenMetadata = this.StreamTokenMetadata.bind(this);
    this.StreamSvmAccountLink = this.StreamSvmAccountLink.bind(this);
    this.ListDriftOrders = this.ListDriftOrders.bind(this);
    this.ListFillableDriftJITOrders = this.ListFillableDriftJITOrders.bind(this);
    this.StreamDriftOrders = this.StreamDriftOrders.bind(this);
  }

  ListEvmContracts(
    request: DeepPartial<ListEvmContractsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListEvmContractsResponse> {
    return this.rpc.unary(APIListEvmContractsDesc, ListEvmContractsRequest.fromPartial(request), metadata);
  }

  Balances(request: DeepPartial<BalancesRequest>, metadata?: grpc.Metadata): Promise<BalancesResponse> {
    return this.rpc.unary(APIBalancesDesc, BalancesRequest.fromPartial(request), metadata);
  }

  ListStrategies(
    request: DeepPartial<ListStrategiesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListStrategiesResponse> {
    return this.rpc.unary(APIListStrategiesDesc, ListStrategiesRequest.fromPartial(request), metadata);
  }

  ListStrategiesByOwner(
    request: DeepPartial<ListStrategiesByOwnerRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListStrategiesResponse> {
    return this.rpc.unary(APIListStrategiesByOwnerDesc, ListStrategiesByOwnerRequest.fromPartial(request), metadata);
  }

  GetMetrics(request: DeepPartial<GetMetricsRequest>, metadata?: grpc.Metadata): Promise<GetMetricsResponse> {
    return this.rpc.unary(APIGetMetricsDesc, GetMetricsRequest.fromPartial(request), metadata);
  }

  ListStrategyTriggersById(
    request: DeepPartial<ListStrategyTriggerByIdRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListStrategyTriggerByIdResponse> {
    return this.rpc.unary(
      APIListStrategyTriggersByIdDesc,
      ListStrategyTriggerByIdRequest.fromPartial(request),
      metadata,
    );
  }

  ListTokenMetadata(
    request: DeepPartial<ListTokenMetadataRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListTokenMetadataResponse> {
    return this.rpc.unary(APIListTokenMetadataDesc, ListTokenMetadataRequest.fromPartial(request), metadata);
  }

  ListSvmAccountLinks(
    request: DeepPartial<ListSvmAccountLinksRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListSvmAccountLinksResponse> {
    return this.rpc.unary(APIListSvmAccountLinksDesc, ListSvmAccountLinksRequest.fromPartial(request), metadata);
  }

  StreamBalances(request: DeepPartial<BalancesRequest>, metadata?: grpc.Metadata): Observable<StreamBalanceResponse> {
    return this.rpc.invoke(APIStreamBalancesDesc, BalancesRequest.fromPartial(request), metadata);
  }

  StreamStrategyTriggers(
    request: DeepPartial<StreamStrategyTriggerRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamStrategyTriggerResponse> {
    return this.rpc.invoke(APIStreamStrategyTriggersDesc, StreamStrategyTriggerRequest.fromPartial(request), metadata);
  }

  StreamStrategies(
    request: DeepPartial<StreamStrategiesRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamStrategiesResponse> {
    return this.rpc.invoke(APIStreamStrategiesDesc, StreamStrategiesRequest.fromPartial(request), metadata);
  }

  StreamTokenMetadata(
    request: DeepPartial<StreamTokenMetadataRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamTokenMetadataResponse> {
    return this.rpc.invoke(APIStreamTokenMetadataDesc, StreamTokenMetadataRequest.fromPartial(request), metadata);
  }

  StreamSvmAccountLink(
    request: DeepPartial<StreamSvmAccountLinkRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamSvmAccountLinkResponse> {
    return this.rpc.invoke(APIStreamSvmAccountLinkDesc, StreamSvmAccountLinkRequest.fromPartial(request), metadata);
  }

  ListDriftOrders(
    request: DeepPartial<ListDriftOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListDriftOrdersResponse> {
    return this.rpc.unary(APIListDriftOrdersDesc, ListDriftOrdersRequest.fromPartial(request), metadata);
  }

  ListFillableDriftJITOrders(
    request: DeepPartial<ListFillableDriftJITOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListFillableDriftJITOrdersResponse> {
    return this.rpc.unary(
      APIListFillableDriftJITOrdersDesc,
      ListFillableDriftJITOrdersRequest.fromPartial(request),
      metadata,
    );
  }

  StreamDriftOrders(
    request: DeepPartial<StreamDriftOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamDriftOrdersResponse> {
    return this.rpc.invoke(APIStreamDriftOrdersDesc, StreamDriftOrdersRequest.fromPartial(request), metadata);
  }
}

export const APIDesc = { serviceName: "flux.indexer.explorer.API" };

export const APIListEvmContractsDesc: UnaryMethodDefinitionish = {
  methodName: "ListEvmContracts",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListEvmContractsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListEvmContractsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIBalancesDesc: UnaryMethodDefinitionish = {
  methodName: "Balances",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return BalancesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = BalancesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListStrategiesDesc: UnaryMethodDefinitionish = {
  methodName: "ListStrategies",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListStrategiesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListStrategiesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListStrategiesByOwnerDesc: UnaryMethodDefinitionish = {
  methodName: "ListStrategiesByOwner",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListStrategiesByOwnerRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListStrategiesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIGetMetricsDesc: UnaryMethodDefinitionish = {
  methodName: "GetMetrics",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetMetricsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetMetricsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListStrategyTriggersByIdDesc: UnaryMethodDefinitionish = {
  methodName: "ListStrategyTriggersById",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListStrategyTriggerByIdRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListStrategyTriggerByIdResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListTokenMetadataDesc: UnaryMethodDefinitionish = {
  methodName: "ListTokenMetadata",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListTokenMetadataRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListTokenMetadataResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListSvmAccountLinksDesc: UnaryMethodDefinitionish = {
  methodName: "ListSvmAccountLinks",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListSvmAccountLinksRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListSvmAccountLinksResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIStreamBalancesDesc: UnaryMethodDefinitionish = {
  methodName: "StreamBalances",
  service: APIDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return BalancesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamBalanceResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIStreamStrategyTriggersDesc: UnaryMethodDefinitionish = {
  methodName: "StreamStrategyTriggers",
  service: APIDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamStrategyTriggerRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamStrategyTriggerResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIStreamStrategiesDesc: UnaryMethodDefinitionish = {
  methodName: "StreamStrategies",
  service: APIDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamStrategiesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamStrategiesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIStreamTokenMetadataDesc: UnaryMethodDefinitionish = {
  methodName: "StreamTokenMetadata",
  service: APIDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamTokenMetadataRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamTokenMetadataResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIStreamSvmAccountLinkDesc: UnaryMethodDefinitionish = {
  methodName: "StreamSvmAccountLink",
  service: APIDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamSvmAccountLinkRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamSvmAccountLinkResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListDriftOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "ListDriftOrders",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListDriftOrdersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListDriftOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListFillableDriftJITOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "ListFillableDriftJITOrders",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListFillableDriftJITOrdersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListFillableDriftJITOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIStreamDriftOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "StreamDriftOrders",
  service: APIDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamDriftOrdersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamDriftOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;
    streamingTransport?: grpc.TransportFactory;
    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;
      streamingTransport?: grpc.TransportFactory;
      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }

  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any> {
    const upStreamCodes = this.options.upStreamRetryCodes ?? [];
    const DEFAULT_TIMEOUT_TIME: number = 3_000;
    const request = { ..._request, ...methodDesc.requestType };
    const transport = this.options.streamingTransport ?? this.options.transport;
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Observable((observer) => {
      const upStream = () => {
        const client = grpc.invoke(methodDesc, {
          host: this.host,
          request,
          ...(transport !== undefined ? { transport } : {}),
          metadata: maybeCombinedMetadata ?? {},
          debug: this.options.debug ?? false,
          onMessage: (next) => observer.next(next),
          onEnd: (code: grpc.Code, message: string, trailers: grpc.Metadata) => {
            if (code === 0) {
              observer.complete();
            } else if (upStreamCodes.includes(code)) {
              setTimeout(upStream, DEFAULT_TIMEOUT_TIME);
            } else {
              const err = new Error(message) as any;
              err.code = code;
              err.metadata = trailers;
              observer.error(err);
            }
          },
        });
        observer.add(() => client.close());
      };
      upStream();
    }).pipe(share());
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
