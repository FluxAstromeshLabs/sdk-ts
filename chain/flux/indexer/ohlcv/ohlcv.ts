// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: flux/indexer/ohlcv/ohlcv.proto

/* eslint-disable */
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal";

export interface QueryRequest {
  symbol: string;
  timeframe: string;
  limit: string;
  start_epoch: string;
  end_epoch: string;
}

export interface QueryResponse {
  data: string;
}

export interface ListSymbolsRequest {
}

export interface ListSymbolsResponse {
  symbols: string[];
}

function createBaseQueryRequest(): QueryRequest {
  return { symbol: "", timeframe: "", limit: "0", start_epoch: "0", end_epoch: "0" };
}

export const QueryRequest = {
  $type: "flux.indexer.ohlcv.QueryRequest" as const,

  encode(message: QueryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    if (message.timeframe !== "") {
      writer.uint32(18).string(message.timeframe);
    }
    if (message.limit !== "0") {
      writer.uint32(24).uint64(message.limit);
    }
    if (message.start_epoch !== "0") {
      writer.uint32(32).int64(message.start_epoch);
    }
    if (message.end_epoch !== "0") {
      writer.uint32(40).int64(message.end_epoch);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timeframe = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.limit = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.start_epoch = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.end_epoch = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRequest {
    return {
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      timeframe: isSet(object.timeframe) ? globalThis.String(object.timeframe) : "",
      limit: isSet(object.limit) ? globalThis.String(object.limit) : "0",
      start_epoch: isSet(object.start_epoch) ? globalThis.String(object.start_epoch) : "0",
      end_epoch: isSet(object.end_epoch) ? globalThis.String(object.end_epoch) : "0",
    };
  },

  toJSON(message: QueryRequest): unknown {
    const obj: any = {};
    if (message.symbol !== undefined) {
      obj.symbol = message.symbol;
    }
    if (message.timeframe !== undefined) {
      obj.timeframe = message.timeframe;
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.start_epoch !== undefined) {
      obj.start_epoch = message.start_epoch;
    }
    if (message.end_epoch !== undefined) {
      obj.end_epoch = message.end_epoch;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryRequest>): QueryRequest {
    return QueryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryRequest>): QueryRequest {
    const message = createBaseQueryRequest();
    message.symbol = object.symbol ?? "";
    message.timeframe = object.timeframe ?? "";
    message.limit = object.limit ?? "0";
    message.start_epoch = object.start_epoch ?? "0";
    message.end_epoch = object.end_epoch ?? "0";
    return message;
  },
};

function createBaseQueryResponse(): QueryResponse {
  return { data: "" };
}

export const QueryResponse = {
  $type: "flux.indexer.ohlcv.QueryResponse" as const,

  encode(message: QueryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data !== "") {
      writer.uint32(10).string(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryResponse {
    return { data: isSet(object.data) ? globalThis.String(object.data) : "" };
  },

  toJSON(message: QueryResponse): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryResponse>): QueryResponse {
    return QueryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryResponse>): QueryResponse {
    const message = createBaseQueryResponse();
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseListSymbolsRequest(): ListSymbolsRequest {
  return {};
}

export const ListSymbolsRequest = {
  $type: "flux.indexer.ohlcv.ListSymbolsRequest" as const,

  encode(_: ListSymbolsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSymbolsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSymbolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListSymbolsRequest {
    return {};
  },

  toJSON(_: ListSymbolsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ListSymbolsRequest>): ListSymbolsRequest {
    return ListSymbolsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ListSymbolsRequest>): ListSymbolsRequest {
    const message = createBaseListSymbolsRequest();
    return message;
  },
};

function createBaseListSymbolsResponse(): ListSymbolsResponse {
  return { symbols: [] };
}

export const ListSymbolsResponse = {
  $type: "flux.indexer.ohlcv.ListSymbolsResponse" as const,

  encode(message: ListSymbolsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.symbols) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSymbolsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSymbolsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.symbols.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSymbolsResponse {
    return {
      symbols: globalThis.Array.isArray(object?.symbols) ? object.symbols.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ListSymbolsResponse): unknown {
    const obj: any = {};
    if (message.symbols?.length) {
      obj.symbols = message.symbols;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSymbolsResponse>): ListSymbolsResponse {
    return ListSymbolsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSymbolsResponse>): ListSymbolsResponse {
    const message = createBaseListSymbolsResponse();
    message.symbols = object.symbols?.map((e) => e) || [];
    return message;
  },
};

export interface API {
  Query(request: DeepPartial<QueryRequest>, metadata?: grpc.Metadata): Promise<QueryResponse>;
  ListSymbols(request: DeepPartial<ListSymbolsRequest>, metadata?: grpc.Metadata): Promise<ListSymbolsResponse>;
}

export class APIClientImpl implements API {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.Query = this.Query.bind(this);
    this.ListSymbols = this.ListSymbols.bind(this);
  }

  Query(request: DeepPartial<QueryRequest>, metadata?: grpc.Metadata): Promise<QueryResponse> {
    return this.rpc.unary(APIQueryDesc, QueryRequest.fromPartial(request), metadata);
  }

  ListSymbols(request: DeepPartial<ListSymbolsRequest>, metadata?: grpc.Metadata): Promise<ListSymbolsResponse> {
    return this.rpc.unary(APIListSymbolsDesc, ListSymbolsRequest.fromPartial(request), metadata);
  }
}

export const APIDesc = { serviceName: "flux.indexer.ohlcv.API" };

export const APIQueryDesc: UnaryMethodDefinitionish = {
  methodName: "Query",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const APIListSymbolsDesc: UnaryMethodDefinitionish = {
  methodName: "ListSymbols",
  service: APIDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListSymbolsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListSymbolsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
