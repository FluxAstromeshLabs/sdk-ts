// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: flux/indexer/campclash/camp.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Coin } from "../../../cosmos/base/v1beta1/coin";

export interface CurveConfig {
  a: string;
  b: string;
  c: string;
  graduation_threshold: string;
  cap: string;
}

/** Camp structure */
export interface Project {
  contract_address: string;
  camp_denom: string;
  name: string;
  symbol: string;
  logo: string;
  creator: string;
  /** Cast to math.Int */
  graduation_threshold: string;
  graduation_dex: string;
  graduated: boolean;
  pool_seeded: boolean;
  pool_address: string;
  graduate_progress: number;
  /** Cast to math.Int */
  camp_amount: string;
  quote_denom: string;
  /** Cast to math.Int */
  quote_amount: string;
  /** Cast to math.Int */
  market_cap: string;
  updated_height: string;
  metadata: string;
  metrics: Metrics | undefined;
  metadata_object: MetadataObject | undefined;
  created_at: string;
  disable_buy: boolean;
  disable_sell: boolean;
  challenge_id: string;
  has_challenge: boolean;
  /** helix market id */
  market_id: string;
  curve_config: CurveConfig | undefined;
  defeated: boolean;
}

export interface Tweet {
  /** Tweet URL */
  tweet_url: string;
  /** Tweet author profile image URL */
  tweet_author_profile_image_url: string;
  /** Tweet author display name */
  tweet_author_display_name: string;
  /** Smart engagement points */
  smart_engagement_points: number;
  /** Impressions count */
  impressions_count: number;
}

/** Metrics structure */
export interface Metrics {
  mind_share: number;
  inferences: string;
  holders: string;
  impressions: number;
  engagement: number;
  followers: string;
  smart_followers: string;
  top_tweets: Tweet[];
  /** Cast to math.Int */
  volume_24h: string;
  /** Cast to math.Int */
  total_volume: string;
  updated_at: string;
}

/** User structure */
export interface UserBalance {
  address: string;
  camp_denom: string;
  /** Cast to math.Int */
  amount: string;
  updated_height: string;
  project:
    | Project
    | undefined;
  /** Amount of tokens that locked in camp contract, user still need to see */
  locked_amount: string;
  /** this */
  vote_type: string;
  challenge_id: string;
  vote: string;
  claimed: boolean;
  created_height: string;
}

/** Agent structure */
export interface Agent {
  camp_denom: string;
  wallet: string;
}

/** Trade structure */
export interface Trade {
  address: string;
  contract_address: string;
  camp_denom: string;
  action: string;
  input_coin: Coin | undefined;
  output_coin: Coin | undefined;
  price: string;
  height: string;
  timestamp: string;
  camp_type: string;
}

export interface MetadataObject {
  description: string;
  camp_type: string;
  website: string;
  twitter: string;
  telegram: string;
  agent_id: string;
  tags: string[];
}

export interface VoteCount {
  accept: string;
  reject: string;
}

export interface Challenge {
  contract_address: string;
  challenger_denom: string;
  challenged_denom: string;
  /** ChallengeStatus as string */
  status: string;
  challenger_vote: VoteCount | undefined;
  challenged_vote: VoteCount | undefined;
  vote_duration: string;
  match_duration: string;
  challenger_vote_start_time: string;
  challenged_vote_start_time: string;
  bonding_curve_reward_percentage: string;
  match_start_time: string;
  winner: string;
  reward_coin: Coin | undefined;
  challenge_id: string;
  updated_height: string;
  finalized_reason: string;
  user_claimable: Claimable | undefined;
  challenger_project: Project | undefined;
  challenged_project: Project | undefined;
  created_height: string;
}

/** Define the VoteEvent message */
export interface ChallengeVote {
  /** Contract address */
  contract_address: string;
  challenge_id: string;
  voter: string;
  coin: Coin | undefined;
  vote_type: string;
  height: string;
  locked_coin: Coin | undefined;
}

export interface Claimable {
  contract_address: string;
  challenge_id: string;
  address: string;
  coins: Coin[];
  is_claimed: boolean;
  height: string;
}

function createBaseCurveConfig(): CurveConfig {
  return { a: "", b: "", c: "", graduation_threshold: "", cap: "" };
}

export const CurveConfig = {
  $type: "flux.indexer.campclash.CurveConfig" as const,

  encode(message: CurveConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.a !== "") {
      writer.uint32(10).string(message.a);
    }
    if (message.b !== "") {
      writer.uint32(18).string(message.b);
    }
    if (message.c !== "") {
      writer.uint32(26).string(message.c);
    }
    if (message.graduation_threshold !== "") {
      writer.uint32(34).string(message.graduation_threshold);
    }
    if (message.cap !== "") {
      writer.uint32(42).string(message.cap);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CurveConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCurveConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.a = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.b = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.c = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.graduation_threshold = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cap = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CurveConfig {
    return {
      a: isSet(object.a) ? globalThis.String(object.a) : "",
      b: isSet(object.b) ? globalThis.String(object.b) : "",
      c: isSet(object.c) ? globalThis.String(object.c) : "",
      graduation_threshold: isSet(object.graduation_threshold) ? globalThis.String(object.graduation_threshold) : "",
      cap: isSet(object.cap) ? globalThis.String(object.cap) : "",
    };
  },

  toJSON(message: CurveConfig): unknown {
    const obj: any = {};
    if (message.a !== undefined) {
      obj.a = message.a;
    }
    if (message.b !== undefined) {
      obj.b = message.b;
    }
    if (message.c !== undefined) {
      obj.c = message.c;
    }
    if (message.graduation_threshold !== undefined) {
      obj.graduation_threshold = message.graduation_threshold;
    }
    if (message.cap !== undefined) {
      obj.cap = message.cap;
    }
    return obj;
  },

  create(base?: DeepPartial<CurveConfig>): CurveConfig {
    return CurveConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CurveConfig>): CurveConfig {
    const message = createBaseCurveConfig();
    message.a = object.a ?? "";
    message.b = object.b ?? "";
    message.c = object.c ?? "";
    message.graduation_threshold = object.graduation_threshold ?? "";
    message.cap = object.cap ?? "";
    return message;
  },
};

function createBaseProject(): Project {
  return {
    contract_address: "",
    camp_denom: "",
    name: "",
    symbol: "",
    logo: "",
    creator: "",
    graduation_threshold: "",
    graduation_dex: "",
    graduated: false,
    pool_seeded: false,
    pool_address: "",
    graduate_progress: 0,
    camp_amount: "",
    quote_denom: "",
    quote_amount: "",
    market_cap: "",
    updated_height: "0",
    metadata: "",
    metrics: undefined,
    metadata_object: undefined,
    created_at: "0",
    disable_buy: false,
    disable_sell: false,
    challenge_id: "0",
    has_challenge: false,
    market_id: "",
    curve_config: undefined,
    defeated: false,
  };
}

export const Project = {
  $type: "flux.indexer.campclash.Project" as const,

  encode(message: Project, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contract_address !== "") {
      writer.uint32(10).string(message.contract_address);
    }
    if (message.camp_denom !== "") {
      writer.uint32(18).string(message.camp_denom);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(34).string(message.symbol);
    }
    if (message.logo !== "") {
      writer.uint32(42).string(message.logo);
    }
    if (message.creator !== "") {
      writer.uint32(50).string(message.creator);
    }
    if (message.graduation_threshold !== "") {
      writer.uint32(58).string(message.graduation_threshold);
    }
    if (message.graduation_dex !== "") {
      writer.uint32(66).string(message.graduation_dex);
    }
    if (message.graduated !== false) {
      writer.uint32(72).bool(message.graduated);
    }
    if (message.pool_seeded !== false) {
      writer.uint32(80).bool(message.pool_seeded);
    }
    if (message.pool_address !== "") {
      writer.uint32(90).string(message.pool_address);
    }
    if (message.graduate_progress !== 0) {
      writer.uint32(97).double(message.graduate_progress);
    }
    if (message.camp_amount !== "") {
      writer.uint32(106).string(message.camp_amount);
    }
    if (message.quote_denom !== "") {
      writer.uint32(114).string(message.quote_denom);
    }
    if (message.quote_amount !== "") {
      writer.uint32(122).string(message.quote_amount);
    }
    if (message.market_cap !== "") {
      writer.uint32(130).string(message.market_cap);
    }
    if (message.updated_height !== "0") {
      writer.uint32(136).uint64(message.updated_height);
    }
    if (message.metadata !== "") {
      writer.uint32(146).string(message.metadata);
    }
    if (message.metrics !== undefined) {
      Metrics.encode(message.metrics, writer.uint32(154).fork()).ldelim();
    }
    if (message.metadata_object !== undefined) {
      MetadataObject.encode(message.metadata_object, writer.uint32(162).fork()).ldelim();
    }
    if (message.created_at !== "0") {
      writer.uint32(168).int64(message.created_at);
    }
    if (message.disable_buy !== false) {
      writer.uint32(176).bool(message.disable_buy);
    }
    if (message.disable_sell !== false) {
      writer.uint32(184).bool(message.disable_sell);
    }
    if (message.challenge_id !== "0") {
      writer.uint32(192).uint64(message.challenge_id);
    }
    if (message.has_challenge !== false) {
      writer.uint32(200).bool(message.has_challenge);
    }
    if (message.market_id !== "") {
      writer.uint32(210).string(message.market_id);
    }
    if (message.curve_config !== undefined) {
      CurveConfig.encode(message.curve_config, writer.uint32(218).fork()).ldelim();
    }
    if (message.defeated !== false) {
      writer.uint32(224).bool(message.defeated);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Project {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contract_address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.camp_denom = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.logo = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.creator = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.graduation_threshold = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.graduation_dex = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.graduated = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.pool_seeded = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.pool_address = reader.string();
          continue;
        case 12:
          if (tag !== 97) {
            break;
          }

          message.graduate_progress = reader.double();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.camp_amount = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.quote_denom = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.quote_amount = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.market_cap = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.updated_height = longToString(reader.uint64() as Long);
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.metadata = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.metrics = Metrics.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.metadata_object = MetadataObject.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.created_at = longToString(reader.int64() as Long);
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.disable_buy = reader.bool();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.disable_sell = reader.bool();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.challenge_id = longToString(reader.uint64() as Long);
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.has_challenge = reader.bool();
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.market_id = reader.string();
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.curve_config = CurveConfig.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.defeated = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Project {
    return {
      contract_address: isSet(object.contract_address) ? globalThis.String(object.contract_address) : "",
      camp_denom: isSet(object.camp_denom) ? globalThis.String(object.camp_denom) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      graduation_threshold: isSet(object.graduation_threshold) ? globalThis.String(object.graduation_threshold) : "",
      graduation_dex: isSet(object.graduation_dex) ? globalThis.String(object.graduation_dex) : "",
      graduated: isSet(object.graduated) ? globalThis.Boolean(object.graduated) : false,
      pool_seeded: isSet(object.pool_seeded) ? globalThis.Boolean(object.pool_seeded) : false,
      pool_address: isSet(object.pool_address) ? globalThis.String(object.pool_address) : "",
      graduate_progress: isSet(object.graduate_progress) ? globalThis.Number(object.graduate_progress) : 0,
      camp_amount: isSet(object.camp_amount) ? globalThis.String(object.camp_amount) : "",
      quote_denom: isSet(object.quote_denom) ? globalThis.String(object.quote_denom) : "",
      quote_amount: isSet(object.quote_amount) ? globalThis.String(object.quote_amount) : "",
      market_cap: isSet(object.market_cap) ? globalThis.String(object.market_cap) : "",
      updated_height: isSet(object.updated_height) ? globalThis.String(object.updated_height) : "0",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      metrics: isSet(object.metrics) ? Metrics.fromJSON(object.metrics) : undefined,
      metadata_object: isSet(object.metadata_object) ? MetadataObject.fromJSON(object.metadata_object) : undefined,
      created_at: isSet(object.created_at) ? globalThis.String(object.created_at) : "0",
      disable_buy: isSet(object.disable_buy) ? globalThis.Boolean(object.disable_buy) : false,
      disable_sell: isSet(object.disable_sell) ? globalThis.Boolean(object.disable_sell) : false,
      challenge_id: isSet(object.challenge_id) ? globalThis.String(object.challenge_id) : "0",
      has_challenge: isSet(object.has_challenge) ? globalThis.Boolean(object.has_challenge) : false,
      market_id: isSet(object.market_id) ? globalThis.String(object.market_id) : "",
      curve_config: isSet(object.curve_config) ? CurveConfig.fromJSON(object.curve_config) : undefined,
      defeated: isSet(object.defeated) ? globalThis.Boolean(object.defeated) : false,
    };
  },

  toJSON(message: Project): unknown {
    const obj: any = {};
    if (message.contract_address !== undefined) {
      obj.contract_address = message.contract_address;
    }
    if (message.camp_denom !== undefined) {
      obj.camp_denom = message.camp_denom;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.symbol !== undefined) {
      obj.symbol = message.symbol;
    }
    if (message.logo !== undefined) {
      obj.logo = message.logo;
    }
    if (message.creator !== undefined) {
      obj.creator = message.creator;
    }
    if (message.graduation_threshold !== undefined) {
      obj.graduation_threshold = message.graduation_threshold;
    }
    if (message.graduation_dex !== undefined) {
      obj.graduation_dex = message.graduation_dex;
    }
    if (message.graduated !== undefined) {
      obj.graduated = message.graduated;
    }
    if (message.pool_seeded !== undefined) {
      obj.pool_seeded = message.pool_seeded;
    }
    if (message.pool_address !== undefined) {
      obj.pool_address = message.pool_address;
    }
    if (message.graduate_progress !== undefined) {
      obj.graduate_progress = message.graduate_progress;
    }
    if (message.camp_amount !== undefined) {
      obj.camp_amount = message.camp_amount;
    }
    if (message.quote_denom !== undefined) {
      obj.quote_denom = message.quote_denom;
    }
    if (message.quote_amount !== undefined) {
      obj.quote_amount = message.quote_amount;
    }
    if (message.market_cap !== undefined) {
      obj.market_cap = message.market_cap;
    }
    if (message.updated_height !== undefined) {
      obj.updated_height = message.updated_height;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.metrics !== undefined) {
      obj.metrics = Metrics.toJSON(message.metrics);
    }
    if (message.metadata_object !== undefined) {
      obj.metadata_object = MetadataObject.toJSON(message.metadata_object);
    }
    if (message.created_at !== undefined) {
      obj.created_at = message.created_at;
    }
    if (message.disable_buy !== undefined) {
      obj.disable_buy = message.disable_buy;
    }
    if (message.disable_sell !== undefined) {
      obj.disable_sell = message.disable_sell;
    }
    if (message.challenge_id !== undefined) {
      obj.challenge_id = message.challenge_id;
    }
    if (message.has_challenge !== undefined) {
      obj.has_challenge = message.has_challenge;
    }
    if (message.market_id !== undefined) {
      obj.market_id = message.market_id;
    }
    if (message.curve_config !== undefined) {
      obj.curve_config = CurveConfig.toJSON(message.curve_config);
    }
    if (message.defeated !== undefined) {
      obj.defeated = message.defeated;
    }
    return obj;
  },

  create(base?: DeepPartial<Project>): Project {
    return Project.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Project>): Project {
    const message = createBaseProject();
    message.contract_address = object.contract_address ?? "";
    message.camp_denom = object.camp_denom ?? "";
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.logo = object.logo ?? "";
    message.creator = object.creator ?? "";
    message.graduation_threshold = object.graduation_threshold ?? "";
    message.graduation_dex = object.graduation_dex ?? "";
    message.graduated = object.graduated ?? false;
    message.pool_seeded = object.pool_seeded ?? false;
    message.pool_address = object.pool_address ?? "";
    message.graduate_progress = object.graduate_progress ?? 0;
    message.camp_amount = object.camp_amount ?? "";
    message.quote_denom = object.quote_denom ?? "";
    message.quote_amount = object.quote_amount ?? "";
    message.market_cap = object.market_cap ?? "";
    message.updated_height = object.updated_height ?? "0";
    message.metadata = object.metadata ?? "";
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? Metrics.fromPartial(object.metrics)
      : undefined;
    message.metadata_object = (object.metadata_object !== undefined && object.metadata_object !== null)
      ? MetadataObject.fromPartial(object.metadata_object)
      : undefined;
    message.created_at = object.created_at ?? "0";
    message.disable_buy = object.disable_buy ?? false;
    message.disable_sell = object.disable_sell ?? false;
    message.challenge_id = object.challenge_id ?? "0";
    message.has_challenge = object.has_challenge ?? false;
    message.market_id = object.market_id ?? "";
    message.curve_config = (object.curve_config !== undefined && object.curve_config !== null)
      ? CurveConfig.fromPartial(object.curve_config)
      : undefined;
    message.defeated = object.defeated ?? false;
    return message;
  },
};

function createBaseTweet(): Tweet {
  return {
    tweet_url: "",
    tweet_author_profile_image_url: "",
    tweet_author_display_name: "",
    smart_engagement_points: 0,
    impressions_count: 0,
  };
}

export const Tweet = {
  $type: "flux.indexer.campclash.Tweet" as const,

  encode(message: Tweet, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tweet_url !== "") {
      writer.uint32(10).string(message.tweet_url);
    }
    if (message.tweet_author_profile_image_url !== "") {
      writer.uint32(18).string(message.tweet_author_profile_image_url);
    }
    if (message.tweet_author_display_name !== "") {
      writer.uint32(26).string(message.tweet_author_display_name);
    }
    if (message.smart_engagement_points !== 0) {
      writer.uint32(32).int32(message.smart_engagement_points);
    }
    if (message.impressions_count !== 0) {
      writer.uint32(40).int32(message.impressions_count);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Tweet {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTweet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tweet_url = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tweet_author_profile_image_url = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tweet_author_display_name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.smart_engagement_points = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.impressions_count = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tweet {
    return {
      tweet_url: isSet(object.tweet_url) ? globalThis.String(object.tweet_url) : "",
      tweet_author_profile_image_url: isSet(object.tweet_author_profile_image_url)
        ? globalThis.String(object.tweet_author_profile_image_url)
        : "",
      tweet_author_display_name: isSet(object.tweet_author_display_name)
        ? globalThis.String(object.tweet_author_display_name)
        : "",
      smart_engagement_points: isSet(object.smart_engagement_points)
        ? globalThis.Number(object.smart_engagement_points)
        : 0,
      impressions_count: isSet(object.impressions_count) ? globalThis.Number(object.impressions_count) : 0,
    };
  },

  toJSON(message: Tweet): unknown {
    const obj: any = {};
    if (message.tweet_url !== undefined) {
      obj.tweet_url = message.tweet_url;
    }
    if (message.tweet_author_profile_image_url !== undefined) {
      obj.tweet_author_profile_image_url = message.tweet_author_profile_image_url;
    }
    if (message.tweet_author_display_name !== undefined) {
      obj.tweet_author_display_name = message.tweet_author_display_name;
    }
    if (message.smart_engagement_points !== undefined) {
      obj.smart_engagement_points = Math.round(message.smart_engagement_points);
    }
    if (message.impressions_count !== undefined) {
      obj.impressions_count = Math.round(message.impressions_count);
    }
    return obj;
  },

  create(base?: DeepPartial<Tweet>): Tweet {
    return Tweet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Tweet>): Tweet {
    const message = createBaseTweet();
    message.tweet_url = object.tweet_url ?? "";
    message.tweet_author_profile_image_url = object.tweet_author_profile_image_url ?? "";
    message.tweet_author_display_name = object.tweet_author_display_name ?? "";
    message.smart_engagement_points = object.smart_engagement_points ?? 0;
    message.impressions_count = object.impressions_count ?? 0;
    return message;
  },
};

function createBaseMetrics(): Metrics {
  return {
    mind_share: 0,
    inferences: "0",
    holders: "0",
    impressions: 0,
    engagement: 0,
    followers: "0",
    smart_followers: "0",
    top_tweets: [],
    volume_24h: "",
    total_volume: "",
    updated_at: "0",
  };
}

export const Metrics = {
  $type: "flux.indexer.campclash.Metrics" as const,

  encode(message: Metrics, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mind_share !== 0) {
      writer.uint32(9).double(message.mind_share);
    }
    if (message.inferences !== "0") {
      writer.uint32(16).int64(message.inferences);
    }
    if (message.holders !== "0") {
      writer.uint32(24).int64(message.holders);
    }
    if (message.impressions !== 0) {
      writer.uint32(33).double(message.impressions);
    }
    if (message.engagement !== 0) {
      writer.uint32(41).double(message.engagement);
    }
    if (message.followers !== "0") {
      writer.uint32(48).int64(message.followers);
    }
    if (message.smart_followers !== "0") {
      writer.uint32(56).int64(message.smart_followers);
    }
    for (const v of message.top_tweets) {
      Tweet.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.volume_24h !== "") {
      writer.uint32(74).string(message.volume_24h);
    }
    if (message.total_volume !== "") {
      writer.uint32(82).string(message.total_volume);
    }
    if (message.updated_at !== "0") {
      writer.uint32(88).int64(message.updated_at);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Metrics {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.mind_share = reader.double();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.inferences = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.holders = longToString(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.impressions = reader.double();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.engagement = reader.double();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.followers = longToString(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.smart_followers = longToString(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.top_tweets.push(Tweet.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.volume_24h = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.total_volume = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.updated_at = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metrics {
    return {
      mind_share: isSet(object.mind_share) ? globalThis.Number(object.mind_share) : 0,
      inferences: isSet(object.inferences) ? globalThis.String(object.inferences) : "0",
      holders: isSet(object.holders) ? globalThis.String(object.holders) : "0",
      impressions: isSet(object.impressions) ? globalThis.Number(object.impressions) : 0,
      engagement: isSet(object.engagement) ? globalThis.Number(object.engagement) : 0,
      followers: isSet(object.followers) ? globalThis.String(object.followers) : "0",
      smart_followers: isSet(object.smart_followers) ? globalThis.String(object.smart_followers) : "0",
      top_tweets: globalThis.Array.isArray(object?.top_tweets)
        ? object.top_tweets.map((e: any) => Tweet.fromJSON(e))
        : [],
      volume_24h: isSet(object.volume_24h) ? globalThis.String(object.volume_24h) : "",
      total_volume: isSet(object.total_volume) ? globalThis.String(object.total_volume) : "",
      updated_at: isSet(object.updated_at) ? globalThis.String(object.updated_at) : "0",
    };
  },

  toJSON(message: Metrics): unknown {
    const obj: any = {};
    if (message.mind_share !== undefined) {
      obj.mind_share = message.mind_share;
    }
    if (message.inferences !== undefined) {
      obj.inferences = message.inferences;
    }
    if (message.holders !== undefined) {
      obj.holders = message.holders;
    }
    if (message.impressions !== undefined) {
      obj.impressions = message.impressions;
    }
    if (message.engagement !== undefined) {
      obj.engagement = message.engagement;
    }
    if (message.followers !== undefined) {
      obj.followers = message.followers;
    }
    if (message.smart_followers !== undefined) {
      obj.smart_followers = message.smart_followers;
    }
    if (message.top_tweets?.length) {
      obj.top_tweets = message.top_tweets.map((e) => Tweet.toJSON(e));
    }
    if (message.volume_24h !== undefined) {
      obj.volume_24h = message.volume_24h;
    }
    if (message.total_volume !== undefined) {
      obj.total_volume = message.total_volume;
    }
    if (message.updated_at !== undefined) {
      obj.updated_at = message.updated_at;
    }
    return obj;
  },

  create(base?: DeepPartial<Metrics>): Metrics {
    return Metrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Metrics>): Metrics {
    const message = createBaseMetrics();
    message.mind_share = object.mind_share ?? 0;
    message.inferences = object.inferences ?? "0";
    message.holders = object.holders ?? "0";
    message.impressions = object.impressions ?? 0;
    message.engagement = object.engagement ?? 0;
    message.followers = object.followers ?? "0";
    message.smart_followers = object.smart_followers ?? "0";
    message.top_tweets = object.top_tweets?.map((e) => Tweet.fromPartial(e)) || [];
    message.volume_24h = object.volume_24h ?? "";
    message.total_volume = object.total_volume ?? "";
    message.updated_at = object.updated_at ?? "0";
    return message;
  },
};

function createBaseUserBalance(): UserBalance {
  return {
    address: "",
    camp_denom: "",
    amount: "",
    updated_height: "0",
    project: undefined,
    locked_amount: "",
    vote_type: "",
    challenge_id: "0",
    vote: "",
    claimed: false,
    created_height: "0",
  };
}

export const UserBalance = {
  $type: "flux.indexer.campclash.UserBalance" as const,

  encode(message: UserBalance, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.camp_denom !== "") {
      writer.uint32(18).string(message.camp_denom);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.updated_height !== "0") {
      writer.uint32(32).uint64(message.updated_height);
    }
    if (message.project !== undefined) {
      Project.encode(message.project, writer.uint32(42).fork()).ldelim();
    }
    if (message.locked_amount !== "") {
      writer.uint32(50).string(message.locked_amount);
    }
    if (message.vote_type !== "") {
      writer.uint32(58).string(message.vote_type);
    }
    if (message.challenge_id !== "0") {
      writer.uint32(64).uint64(message.challenge_id);
    }
    if (message.vote !== "") {
      writer.uint32(74).string(message.vote);
    }
    if (message.claimed !== false) {
      writer.uint32(80).bool(message.claimed);
    }
    if (message.created_height !== "0") {
      writer.uint32(88).uint64(message.created_height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserBalance {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.camp_denom = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.updated_height = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.project = Project.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.locked_amount = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.vote_type = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.challenge_id = longToString(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.vote = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.claimed = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.created_height = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserBalance {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      camp_denom: isSet(object.camp_denom) ? globalThis.String(object.camp_denom) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      updated_height: isSet(object.updated_height) ? globalThis.String(object.updated_height) : "0",
      project: isSet(object.project) ? Project.fromJSON(object.project) : undefined,
      locked_amount: isSet(object.locked_amount) ? globalThis.String(object.locked_amount) : "",
      vote_type: isSet(object.vote_type) ? globalThis.String(object.vote_type) : "",
      challenge_id: isSet(object.challenge_id) ? globalThis.String(object.challenge_id) : "0",
      vote: isSet(object.vote) ? globalThis.String(object.vote) : "",
      claimed: isSet(object.claimed) ? globalThis.Boolean(object.claimed) : false,
      created_height: isSet(object.created_height) ? globalThis.String(object.created_height) : "0",
    };
  },

  toJSON(message: UserBalance): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.camp_denom !== undefined) {
      obj.camp_denom = message.camp_denom;
    }
    if (message.amount !== undefined) {
      obj.amount = message.amount;
    }
    if (message.updated_height !== undefined) {
      obj.updated_height = message.updated_height;
    }
    if (message.project !== undefined) {
      obj.project = Project.toJSON(message.project);
    }
    if (message.locked_amount !== undefined) {
      obj.locked_amount = message.locked_amount;
    }
    if (message.vote_type !== undefined) {
      obj.vote_type = message.vote_type;
    }
    if (message.challenge_id !== undefined) {
      obj.challenge_id = message.challenge_id;
    }
    if (message.vote !== undefined) {
      obj.vote = message.vote;
    }
    if (message.claimed !== undefined) {
      obj.claimed = message.claimed;
    }
    if (message.created_height !== undefined) {
      obj.created_height = message.created_height;
    }
    return obj;
  },

  create(base?: DeepPartial<UserBalance>): UserBalance {
    return UserBalance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserBalance>): UserBalance {
    const message = createBaseUserBalance();
    message.address = object.address ?? "";
    message.camp_denom = object.camp_denom ?? "";
    message.amount = object.amount ?? "";
    message.updated_height = object.updated_height ?? "0";
    message.project = (object.project !== undefined && object.project !== null)
      ? Project.fromPartial(object.project)
      : undefined;
    message.locked_amount = object.locked_amount ?? "";
    message.vote_type = object.vote_type ?? "";
    message.challenge_id = object.challenge_id ?? "0";
    message.vote = object.vote ?? "";
    message.claimed = object.claimed ?? false;
    message.created_height = object.created_height ?? "0";
    return message;
  },
};

function createBaseAgent(): Agent {
  return { camp_denom: "", wallet: "" };
}

export const Agent = {
  $type: "flux.indexer.campclash.Agent" as const,

  encode(message: Agent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.camp_denom !== "") {
      writer.uint32(10).string(message.camp_denom);
    }
    if (message.wallet !== "") {
      writer.uint32(18).string(message.wallet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Agent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.camp_denom = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.wallet = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Agent {
    return {
      camp_denom: isSet(object.camp_denom) ? globalThis.String(object.camp_denom) : "",
      wallet: isSet(object.wallet) ? globalThis.String(object.wallet) : "",
    };
  },

  toJSON(message: Agent): unknown {
    const obj: any = {};
    if (message.camp_denom !== undefined) {
      obj.camp_denom = message.camp_denom;
    }
    if (message.wallet !== undefined) {
      obj.wallet = message.wallet;
    }
    return obj;
  },

  create(base?: DeepPartial<Agent>): Agent {
    return Agent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Agent>): Agent {
    const message = createBaseAgent();
    message.camp_denom = object.camp_denom ?? "";
    message.wallet = object.wallet ?? "";
    return message;
  },
};

function createBaseTrade(): Trade {
  return {
    address: "",
    contract_address: "",
    camp_denom: "",
    action: "",
    input_coin: undefined,
    output_coin: undefined,
    price: "",
    height: "0",
    timestamp: "0",
    camp_type: "",
  };
}

export const Trade = {
  $type: "flux.indexer.campclash.Trade" as const,

  encode(message: Trade, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.contract_address !== "") {
      writer.uint32(18).string(message.contract_address);
    }
    if (message.camp_denom !== "") {
      writer.uint32(26).string(message.camp_denom);
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    if (message.input_coin !== undefined) {
      Coin.encode(message.input_coin, writer.uint32(42).fork()).ldelim();
    }
    if (message.output_coin !== undefined) {
      Coin.encode(message.output_coin, writer.uint32(50).fork()).ldelim();
    }
    if (message.price !== "") {
      writer.uint32(58).string(message.price);
    }
    if (message.height !== "0") {
      writer.uint32(64).uint64(message.height);
    }
    if (message.timestamp !== "0") {
      writer.uint32(72).int64(message.timestamp);
    }
    if (message.camp_type !== "") {
      writer.uint32(82).string(message.camp_type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Trade {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contract_address = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.camp_denom = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.input_coin = Coin.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.output_coin = Coin.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.price = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.timestamp = longToString(reader.int64() as Long);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.camp_type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trade {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      contract_address: isSet(object.contract_address) ? globalThis.String(object.contract_address) : "",
      camp_denom: isSet(object.camp_denom) ? globalThis.String(object.camp_denom) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      input_coin: isSet(object.input_coin) ? Coin.fromJSON(object.input_coin) : undefined,
      output_coin: isSet(object.output_coin) ? Coin.fromJSON(object.output_coin) : undefined,
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0",
      camp_type: isSet(object.camp_type) ? globalThis.String(object.camp_type) : "",
    };
  },

  toJSON(message: Trade): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.contract_address !== undefined) {
      obj.contract_address = message.contract_address;
    }
    if (message.camp_denom !== undefined) {
      obj.camp_denom = message.camp_denom;
    }
    if (message.action !== undefined) {
      obj.action = message.action;
    }
    if (message.input_coin !== undefined) {
      obj.input_coin = Coin.toJSON(message.input_coin);
    }
    if (message.output_coin !== undefined) {
      obj.output_coin = Coin.toJSON(message.output_coin);
    }
    if (message.price !== undefined) {
      obj.price = message.price;
    }
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp;
    }
    if (message.camp_type !== undefined) {
      obj.camp_type = message.camp_type;
    }
    return obj;
  },

  create(base?: DeepPartial<Trade>): Trade {
    return Trade.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Trade>): Trade {
    const message = createBaseTrade();
    message.address = object.address ?? "";
    message.contract_address = object.contract_address ?? "";
    message.camp_denom = object.camp_denom ?? "";
    message.action = object.action ?? "";
    message.input_coin = (object.input_coin !== undefined && object.input_coin !== null)
      ? Coin.fromPartial(object.input_coin)
      : undefined;
    message.output_coin = (object.output_coin !== undefined && object.output_coin !== null)
      ? Coin.fromPartial(object.output_coin)
      : undefined;
    message.price = object.price ?? "";
    message.height = object.height ?? "0";
    message.timestamp = object.timestamp ?? "0";
    message.camp_type = object.camp_type ?? "";
    return message;
  },
};

function createBaseMetadataObject(): MetadataObject {
  return { description: "", camp_type: "", website: "", twitter: "", telegram: "", agent_id: "", tags: [] };
}

export const MetadataObject = {
  $type: "flux.indexer.campclash.MetadataObject" as const,

  encode(message: MetadataObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.camp_type !== "") {
      writer.uint32(18).string(message.camp_type);
    }
    if (message.website !== "") {
      writer.uint32(26).string(message.website);
    }
    if (message.twitter !== "") {
      writer.uint32(34).string(message.twitter);
    }
    if (message.telegram !== "") {
      writer.uint32(42).string(message.telegram);
    }
    if (message.agent_id !== "") {
      writer.uint32(50).string(message.agent_id);
    }
    for (const v of message.tags) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetadataObject {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.camp_type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.website = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.twitter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.telegram = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.agent_id = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.tags.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetadataObject {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      camp_type: isSet(object.camp_type) ? globalThis.String(object.camp_type) : "",
      website: isSet(object.website) ? globalThis.String(object.website) : "",
      twitter: isSet(object.twitter) ? globalThis.String(object.twitter) : "",
      telegram: isSet(object.telegram) ? globalThis.String(object.telegram) : "",
      agent_id: isSet(object.agent_id) ? globalThis.String(object.agent_id) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MetadataObject): unknown {
    const obj: any = {};
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.camp_type !== undefined) {
      obj.camp_type = message.camp_type;
    }
    if (message.website !== undefined) {
      obj.website = message.website;
    }
    if (message.twitter !== undefined) {
      obj.twitter = message.twitter;
    }
    if (message.telegram !== undefined) {
      obj.telegram = message.telegram;
    }
    if (message.agent_id !== undefined) {
      obj.agent_id = message.agent_id;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create(base?: DeepPartial<MetadataObject>): MetadataObject {
    return MetadataObject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetadataObject>): MetadataObject {
    const message = createBaseMetadataObject();
    message.description = object.description ?? "";
    message.camp_type = object.camp_type ?? "";
    message.website = object.website ?? "";
    message.twitter = object.twitter ?? "";
    message.telegram = object.telegram ?? "";
    message.agent_id = object.agent_id ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseVoteCount(): VoteCount {
  return { accept: "", reject: "" };
}

export const VoteCount = {
  $type: "flux.indexer.campclash.VoteCount" as const,

  encode(message: VoteCount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accept !== "") {
      writer.uint32(10).string(message.accept);
    }
    if (message.reject !== "") {
      writer.uint32(18).string(message.reject);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VoteCount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoteCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accept = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reject = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoteCount {
    return {
      accept: isSet(object.accept) ? globalThis.String(object.accept) : "",
      reject: isSet(object.reject) ? globalThis.String(object.reject) : "",
    };
  },

  toJSON(message: VoteCount): unknown {
    const obj: any = {};
    if (message.accept !== undefined) {
      obj.accept = message.accept;
    }
    if (message.reject !== undefined) {
      obj.reject = message.reject;
    }
    return obj;
  },

  create(base?: DeepPartial<VoteCount>): VoteCount {
    return VoteCount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VoteCount>): VoteCount {
    const message = createBaseVoteCount();
    message.accept = object.accept ?? "";
    message.reject = object.reject ?? "";
    return message;
  },
};

function createBaseChallenge(): Challenge {
  return {
    contract_address: "",
    challenger_denom: "",
    challenged_denom: "",
    status: "",
    challenger_vote: undefined,
    challenged_vote: undefined,
    vote_duration: "0",
    match_duration: "0",
    challenger_vote_start_time: "0",
    challenged_vote_start_time: "0",
    bonding_curve_reward_percentage: "0",
    match_start_time: "0",
    winner: "",
    reward_coin: undefined,
    challenge_id: "0",
    updated_height: "0",
    finalized_reason: "",
    user_claimable: undefined,
    challenger_project: undefined,
    challenged_project: undefined,
    created_height: "0",
  };
}

export const Challenge = {
  $type: "flux.indexer.campclash.Challenge" as const,

  encode(message: Challenge, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contract_address !== "") {
      writer.uint32(10).string(message.contract_address);
    }
    if (message.challenger_denom !== "") {
      writer.uint32(18).string(message.challenger_denom);
    }
    if (message.challenged_denom !== "") {
      writer.uint32(26).string(message.challenged_denom);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.challenger_vote !== undefined) {
      VoteCount.encode(message.challenger_vote, writer.uint32(42).fork()).ldelim();
    }
    if (message.challenged_vote !== undefined) {
      VoteCount.encode(message.challenged_vote, writer.uint32(50).fork()).ldelim();
    }
    if (message.vote_duration !== "0") {
      writer.uint32(56).uint64(message.vote_duration);
    }
    if (message.match_duration !== "0") {
      writer.uint32(64).uint64(message.match_duration);
    }
    if (message.challenger_vote_start_time !== "0") {
      writer.uint32(72).int64(message.challenger_vote_start_time);
    }
    if (message.challenged_vote_start_time !== "0") {
      writer.uint32(80).int64(message.challenged_vote_start_time);
    }
    if (message.bonding_curve_reward_percentage !== "0") {
      writer.uint32(88).uint64(message.bonding_curve_reward_percentage);
    }
    if (message.match_start_time !== "0") {
      writer.uint32(96).int64(message.match_start_time);
    }
    if (message.winner !== "") {
      writer.uint32(106).string(message.winner);
    }
    if (message.reward_coin !== undefined) {
      Coin.encode(message.reward_coin, writer.uint32(114).fork()).ldelim();
    }
    if (message.challenge_id !== "0") {
      writer.uint32(120).uint64(message.challenge_id);
    }
    if (message.updated_height !== "0") {
      writer.uint32(128).uint64(message.updated_height);
    }
    if (message.finalized_reason !== "") {
      writer.uint32(138).string(message.finalized_reason);
    }
    if (message.user_claimable !== undefined) {
      Claimable.encode(message.user_claimable, writer.uint32(146).fork()).ldelim();
    }
    if (message.challenger_project !== undefined) {
      Project.encode(message.challenger_project, writer.uint32(154).fork()).ldelim();
    }
    if (message.challenged_project !== undefined) {
      Project.encode(message.challenged_project, writer.uint32(162).fork()).ldelim();
    }
    if (message.created_height !== "0") {
      writer.uint32(168).uint64(message.created_height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Challenge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contract_address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenger_denom = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.challenged_denom = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.challenger_vote = VoteCount.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.challenged_vote = VoteCount.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.vote_duration = longToString(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.match_duration = longToString(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.challenger_vote_start_time = longToString(reader.int64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.challenged_vote_start_time = longToString(reader.int64() as Long);
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.bonding_curve_reward_percentage = longToString(reader.uint64() as Long);
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.match_start_time = longToString(reader.int64() as Long);
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.winner = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.reward_coin = Coin.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.challenge_id = longToString(reader.uint64() as Long);
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.updated_height = longToString(reader.uint64() as Long);
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.finalized_reason = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.user_claimable = Claimable.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.challenger_project = Project.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.challenged_project = Project.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.created_height = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Challenge {
    return {
      contract_address: isSet(object.contract_address) ? globalThis.String(object.contract_address) : "",
      challenger_denom: isSet(object.challenger_denom) ? globalThis.String(object.challenger_denom) : "",
      challenged_denom: isSet(object.challenged_denom) ? globalThis.String(object.challenged_denom) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      challenger_vote: isSet(object.challenger_vote) ? VoteCount.fromJSON(object.challenger_vote) : undefined,
      challenged_vote: isSet(object.challenged_vote) ? VoteCount.fromJSON(object.challenged_vote) : undefined,
      vote_duration: isSet(object.vote_duration) ? globalThis.String(object.vote_duration) : "0",
      match_duration: isSet(object.match_duration) ? globalThis.String(object.match_duration) : "0",
      challenger_vote_start_time: isSet(object.challenger_vote_start_time)
        ? globalThis.String(object.challenger_vote_start_time)
        : "0",
      challenged_vote_start_time: isSet(object.challenged_vote_start_time)
        ? globalThis.String(object.challenged_vote_start_time)
        : "0",
      bonding_curve_reward_percentage: isSet(object.bonding_curve_reward_percentage)
        ? globalThis.String(object.bonding_curve_reward_percentage)
        : "0",
      match_start_time: isSet(object.match_start_time) ? globalThis.String(object.match_start_time) : "0",
      winner: isSet(object.winner) ? globalThis.String(object.winner) : "",
      reward_coin: isSet(object.reward_coin) ? Coin.fromJSON(object.reward_coin) : undefined,
      challenge_id: isSet(object.challenge_id) ? globalThis.String(object.challenge_id) : "0",
      updated_height: isSet(object.updated_height) ? globalThis.String(object.updated_height) : "0",
      finalized_reason: isSet(object.finalized_reason) ? globalThis.String(object.finalized_reason) : "",
      user_claimable: isSet(object.user_claimable) ? Claimable.fromJSON(object.user_claimable) : undefined,
      challenger_project: isSet(object.challenger_project) ? Project.fromJSON(object.challenger_project) : undefined,
      challenged_project: isSet(object.challenged_project) ? Project.fromJSON(object.challenged_project) : undefined,
      created_height: isSet(object.created_height) ? globalThis.String(object.created_height) : "0",
    };
  },

  toJSON(message: Challenge): unknown {
    const obj: any = {};
    if (message.contract_address !== undefined) {
      obj.contract_address = message.contract_address;
    }
    if (message.challenger_denom !== undefined) {
      obj.challenger_denom = message.challenger_denom;
    }
    if (message.challenged_denom !== undefined) {
      obj.challenged_denom = message.challenged_denom;
    }
    if (message.status !== undefined) {
      obj.status = message.status;
    }
    if (message.challenger_vote !== undefined) {
      obj.challenger_vote = VoteCount.toJSON(message.challenger_vote);
    }
    if (message.challenged_vote !== undefined) {
      obj.challenged_vote = VoteCount.toJSON(message.challenged_vote);
    }
    if (message.vote_duration !== undefined) {
      obj.vote_duration = message.vote_duration;
    }
    if (message.match_duration !== undefined) {
      obj.match_duration = message.match_duration;
    }
    if (message.challenger_vote_start_time !== undefined) {
      obj.challenger_vote_start_time = message.challenger_vote_start_time;
    }
    if (message.challenged_vote_start_time !== undefined) {
      obj.challenged_vote_start_time = message.challenged_vote_start_time;
    }
    if (message.bonding_curve_reward_percentage !== undefined) {
      obj.bonding_curve_reward_percentage = message.bonding_curve_reward_percentage;
    }
    if (message.match_start_time !== undefined) {
      obj.match_start_time = message.match_start_time;
    }
    if (message.winner !== undefined) {
      obj.winner = message.winner;
    }
    if (message.reward_coin !== undefined) {
      obj.reward_coin = Coin.toJSON(message.reward_coin);
    }
    if (message.challenge_id !== undefined) {
      obj.challenge_id = message.challenge_id;
    }
    if (message.updated_height !== undefined) {
      obj.updated_height = message.updated_height;
    }
    if (message.finalized_reason !== undefined) {
      obj.finalized_reason = message.finalized_reason;
    }
    if (message.user_claimable !== undefined) {
      obj.user_claimable = Claimable.toJSON(message.user_claimable);
    }
    if (message.challenger_project !== undefined) {
      obj.challenger_project = Project.toJSON(message.challenger_project);
    }
    if (message.challenged_project !== undefined) {
      obj.challenged_project = Project.toJSON(message.challenged_project);
    }
    if (message.created_height !== undefined) {
      obj.created_height = message.created_height;
    }
    return obj;
  },

  create(base?: DeepPartial<Challenge>): Challenge {
    return Challenge.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Challenge>): Challenge {
    const message = createBaseChallenge();
    message.contract_address = object.contract_address ?? "";
    message.challenger_denom = object.challenger_denom ?? "";
    message.challenged_denom = object.challenged_denom ?? "";
    message.status = object.status ?? "";
    message.challenger_vote = (object.challenger_vote !== undefined && object.challenger_vote !== null)
      ? VoteCount.fromPartial(object.challenger_vote)
      : undefined;
    message.challenged_vote = (object.challenged_vote !== undefined && object.challenged_vote !== null)
      ? VoteCount.fromPartial(object.challenged_vote)
      : undefined;
    message.vote_duration = object.vote_duration ?? "0";
    message.match_duration = object.match_duration ?? "0";
    message.challenger_vote_start_time = object.challenger_vote_start_time ?? "0";
    message.challenged_vote_start_time = object.challenged_vote_start_time ?? "0";
    message.bonding_curve_reward_percentage = object.bonding_curve_reward_percentage ?? "0";
    message.match_start_time = object.match_start_time ?? "0";
    message.winner = object.winner ?? "";
    message.reward_coin = (object.reward_coin !== undefined && object.reward_coin !== null)
      ? Coin.fromPartial(object.reward_coin)
      : undefined;
    message.challenge_id = object.challenge_id ?? "0";
    message.updated_height = object.updated_height ?? "0";
    message.finalized_reason = object.finalized_reason ?? "";
    message.user_claimable = (object.user_claimable !== undefined && object.user_claimable !== null)
      ? Claimable.fromPartial(object.user_claimable)
      : undefined;
    message.challenger_project = (object.challenger_project !== undefined && object.challenger_project !== null)
      ? Project.fromPartial(object.challenger_project)
      : undefined;
    message.challenged_project = (object.challenged_project !== undefined && object.challenged_project !== null)
      ? Project.fromPartial(object.challenged_project)
      : undefined;
    message.created_height = object.created_height ?? "0";
    return message;
  },
};

function createBaseChallengeVote(): ChallengeVote {
  return {
    contract_address: "",
    challenge_id: "0",
    voter: "",
    coin: undefined,
    vote_type: "",
    height: "0",
    locked_coin: undefined,
  };
}

export const ChallengeVote = {
  $type: "flux.indexer.campclash.ChallengeVote" as const,

  encode(message: ChallengeVote, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contract_address !== "") {
      writer.uint32(10).string(message.contract_address);
    }
    if (message.challenge_id !== "0") {
      writer.uint32(16).uint64(message.challenge_id);
    }
    if (message.voter !== "") {
      writer.uint32(26).string(message.voter);
    }
    if (message.coin !== undefined) {
      Coin.encode(message.coin, writer.uint32(34).fork()).ldelim();
    }
    if (message.vote_type !== "") {
      writer.uint32(42).string(message.vote_type);
    }
    if (message.height !== "0") {
      writer.uint32(48).uint64(message.height);
    }
    if (message.locked_coin !== undefined) {
      Coin.encode(message.locked_coin, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChallengeVote {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChallengeVote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contract_address = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.challenge_id = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.voter = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.coin = Coin.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.vote_type = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.locked_coin = Coin.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChallengeVote {
    return {
      contract_address: isSet(object.contract_address) ? globalThis.String(object.contract_address) : "",
      challenge_id: isSet(object.challenge_id) ? globalThis.String(object.challenge_id) : "0",
      voter: isSet(object.voter) ? globalThis.String(object.voter) : "",
      coin: isSet(object.coin) ? Coin.fromJSON(object.coin) : undefined,
      vote_type: isSet(object.vote_type) ? globalThis.String(object.vote_type) : "",
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      locked_coin: isSet(object.locked_coin) ? Coin.fromJSON(object.locked_coin) : undefined,
    };
  },

  toJSON(message: ChallengeVote): unknown {
    const obj: any = {};
    if (message.contract_address !== undefined) {
      obj.contract_address = message.contract_address;
    }
    if (message.challenge_id !== undefined) {
      obj.challenge_id = message.challenge_id;
    }
    if (message.voter !== undefined) {
      obj.voter = message.voter;
    }
    if (message.coin !== undefined) {
      obj.coin = Coin.toJSON(message.coin);
    }
    if (message.vote_type !== undefined) {
      obj.vote_type = message.vote_type;
    }
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.locked_coin !== undefined) {
      obj.locked_coin = Coin.toJSON(message.locked_coin);
    }
    return obj;
  },

  create(base?: DeepPartial<ChallengeVote>): ChallengeVote {
    return ChallengeVote.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChallengeVote>): ChallengeVote {
    const message = createBaseChallengeVote();
    message.contract_address = object.contract_address ?? "";
    message.challenge_id = object.challenge_id ?? "0";
    message.voter = object.voter ?? "";
    message.coin = (object.coin !== undefined && object.coin !== null) ? Coin.fromPartial(object.coin) : undefined;
    message.vote_type = object.vote_type ?? "";
    message.height = object.height ?? "0";
    message.locked_coin = (object.locked_coin !== undefined && object.locked_coin !== null)
      ? Coin.fromPartial(object.locked_coin)
      : undefined;
    return message;
  },
};

function createBaseClaimable(): Claimable {
  return { contract_address: "", challenge_id: "0", address: "", coins: [], is_claimed: false, height: "0" };
}

export const Claimable = {
  $type: "flux.indexer.campclash.Claimable" as const,

  encode(message: Claimable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contract_address !== "") {
      writer.uint32(10).string(message.contract_address);
    }
    if (message.challenge_id !== "0") {
      writer.uint32(16).uint64(message.challenge_id);
    }
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    for (const v of message.coins) {
      Coin.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.is_claimed !== false) {
      writer.uint32(40).bool(message.is_claimed);
    }
    if (message.height !== "0") {
      writer.uint32(48).uint64(message.height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Claimable {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contract_address = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.challenge_id = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.coins.push(Coin.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.is_claimed = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Claimable {
    return {
      contract_address: isSet(object.contract_address) ? globalThis.String(object.contract_address) : "",
      challenge_id: isSet(object.challenge_id) ? globalThis.String(object.challenge_id) : "0",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      coins: globalThis.Array.isArray(object?.coins) ? object.coins.map((e: any) => Coin.fromJSON(e)) : [],
      is_claimed: isSet(object.is_claimed) ? globalThis.Boolean(object.is_claimed) : false,
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
    };
  },

  toJSON(message: Claimable): unknown {
    const obj: any = {};
    if (message.contract_address !== undefined) {
      obj.contract_address = message.contract_address;
    }
    if (message.challenge_id !== undefined) {
      obj.challenge_id = message.challenge_id;
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.coins?.length) {
      obj.coins = message.coins.map((e) => Coin.toJSON(e));
    }
    if (message.is_claimed !== undefined) {
      obj.is_claimed = message.is_claimed;
    }
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    return obj;
  },

  create(base?: DeepPartial<Claimable>): Claimable {
    return Claimable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Claimable>): Claimable {
    const message = createBaseClaimable();
    message.contract_address = object.contract_address ?? "";
    message.challenge_id = object.challenge_id ?? "0";
    message.address = object.address ?? "";
    message.coins = object.coins?.map((e) => Coin.fromPartial(e)) || [];
    message.is_claimed = object.is_claimed ?? false;
    message.height = object.height ?? "0";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
