// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: flux/indexer/campclash/camp.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Coin } from "../../../cosmos/base/v1beta1/coin";

/** Enum for operations */
export enum Ops {
  OpCreateCamp = 0,
  OpGraduateCamp = 1,
  UNRECOGNIZED = -1,
}

export function opsFromJSON(object: any): Ops {
  switch (object) {
    case 0:
    case "OpCreateCamp":
      return Ops.OpCreateCamp;
    case 1:
    case "OpGraduateCamp":
      return Ops.OpGraduateCamp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Ops.UNRECOGNIZED;
  }
}

export function opsToJSON(object: Ops): string {
  switch (object) {
    case Ops.OpCreateCamp:
      return "OpCreateCamp";
    case Ops.OpGraduateCamp:
      return "OpGraduateCamp";
    case Ops.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Event for camp-related operations */
export interface CampEvent {
  /** Contract address */
  contract_address: string;
  /** Enum for operation type */
  op: Ops;
  /** Associated project */
  project: Project | undefined;
}

/** Event for swap operations */
export interface SwapEvent {
  /** Contract address */
  contract_address: string;
  camp_denom: string;
  /** Action type ("buy" or "sell") */
  action: string;
  /** Input coin */
  input_coin:
    | Coin
    | undefined;
  /** Output coin */
  output_coin:
    | Coin
    | undefined;
  /** Cast to math.Int */
  price: string;
  /** Cast to math.Int */
  curve_quote_amount: string;
  /** Cast to math.Int */
  curve_camp_amount: string;
  trader: string;
}

/** Camp structure */
export interface Project {
  contract_address: string;
  camp_denom: string;
  name: string;
  symbol: string;
  logo: string;
  creator: string;
  /** Cast to math.Int */
  graduation_threshold: string;
  graduation_dex: string;
  graduated: boolean;
  pool_seeded: boolean;
  pool_address: string;
  graduate_progress: number;
  /** Cast to math.Int */
  camp_amount: string;
  quote_denom: string;
  /** Cast to math.Int */
  quote_amount: string;
  /** Cast to math.Int */
  market_cap: string;
  updated_height: string;
  metadata: string;
  metrics: Metrics | undefined;
}

/** Metrics structure */
export interface Metrics {
  mind_share: string;
  inferences: string;
  holders: string;
  impressions: string;
  engagement: string;
  followers: string;
  smart_followers: string;
  top_tweets: string[];
}

/** User structure */
export interface User {
  address: string;
  camp_denom: string;
  /** Cast to math.Int */
  camp_amount: string;
  updated_height: string;
}

/** Agent structure */
export interface Agent {
  camp_denom: string;
  wallet: string;
}

/** Trade structure */
export interface Trade {
  address: string;
  contract_address: string;
  camp_denom: string;
  action: string;
  input_coin: Coin | undefined;
  output_coin: Coin | undefined;
  price: string;
  height: string;
  timestamp: string;
}

function createBaseCampEvent(): CampEvent {
  return { contract_address: "", op: 0, project: undefined };
}

export const CampEvent = {
  $type: "flux.indexer.campclash.CampEvent" as const,

  encode(message: CampEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contract_address !== "") {
      writer.uint32(10).string(message.contract_address);
    }
    if (message.op !== 0) {
      writer.uint32(16).int32(message.op);
    }
    if (message.project !== undefined) {
      Project.encode(message.project, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CampEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCampEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contract_address = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.op = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.project = Project.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CampEvent {
    return {
      contract_address: isSet(object.contract_address) ? globalThis.String(object.contract_address) : "",
      op: isSet(object.op) ? opsFromJSON(object.op) : 0,
      project: isSet(object.project) ? Project.fromJSON(object.project) : undefined,
    };
  },

  toJSON(message: CampEvent): unknown {
    const obj: any = {};
    if (message.contract_address !== undefined) {
      obj.contract_address = message.contract_address;
    }
    if (message.op !== undefined) {
      obj.op = opsToJSON(message.op);
    }
    if (message.project !== undefined) {
      obj.project = Project.toJSON(message.project);
    }
    return obj;
  },

  create(base?: DeepPartial<CampEvent>): CampEvent {
    return CampEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CampEvent>): CampEvent {
    const message = createBaseCampEvent();
    message.contract_address = object.contract_address ?? "";
    message.op = object.op ?? 0;
    message.project = (object.project !== undefined && object.project !== null)
      ? Project.fromPartial(object.project)
      : undefined;
    return message;
  },
};

function createBaseSwapEvent(): SwapEvent {
  return {
    contract_address: "",
    camp_denom: "",
    action: "",
    input_coin: undefined,
    output_coin: undefined,
    price: "",
    curve_quote_amount: "",
    curve_camp_amount: "",
    trader: "",
  };
}

export const SwapEvent = {
  $type: "flux.indexer.campclash.SwapEvent" as const,

  encode(message: SwapEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contract_address !== "") {
      writer.uint32(10).string(message.contract_address);
    }
    if (message.camp_denom !== "") {
      writer.uint32(18).string(message.camp_denom);
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    if (message.input_coin !== undefined) {
      Coin.encode(message.input_coin, writer.uint32(34).fork()).ldelim();
    }
    if (message.output_coin !== undefined) {
      Coin.encode(message.output_coin, writer.uint32(42).fork()).ldelim();
    }
    if (message.price !== "") {
      writer.uint32(50).string(message.price);
    }
    if (message.curve_quote_amount !== "") {
      writer.uint32(58).string(message.curve_quote_amount);
    }
    if (message.curve_camp_amount !== "") {
      writer.uint32(66).string(message.curve_camp_amount);
    }
    if (message.trader !== "") {
      writer.uint32(74).string(message.trader);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SwapEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contract_address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.camp_denom = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.input_coin = Coin.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.output_coin = Coin.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.price = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.curve_quote_amount = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.curve_camp_amount = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.trader = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapEvent {
    return {
      contract_address: isSet(object.contract_address) ? globalThis.String(object.contract_address) : "",
      camp_denom: isSet(object.camp_denom) ? globalThis.String(object.camp_denom) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      input_coin: isSet(object.input_coin) ? Coin.fromJSON(object.input_coin) : undefined,
      output_coin: isSet(object.output_coin) ? Coin.fromJSON(object.output_coin) : undefined,
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      curve_quote_amount: isSet(object.curve_quote_amount) ? globalThis.String(object.curve_quote_amount) : "",
      curve_camp_amount: isSet(object.curve_camp_amount) ? globalThis.String(object.curve_camp_amount) : "",
      trader: isSet(object.trader) ? globalThis.String(object.trader) : "",
    };
  },

  toJSON(message: SwapEvent): unknown {
    const obj: any = {};
    if (message.contract_address !== undefined) {
      obj.contract_address = message.contract_address;
    }
    if (message.camp_denom !== undefined) {
      obj.camp_denom = message.camp_denom;
    }
    if (message.action !== undefined) {
      obj.action = message.action;
    }
    if (message.input_coin !== undefined) {
      obj.input_coin = Coin.toJSON(message.input_coin);
    }
    if (message.output_coin !== undefined) {
      obj.output_coin = Coin.toJSON(message.output_coin);
    }
    if (message.price !== undefined) {
      obj.price = message.price;
    }
    if (message.curve_quote_amount !== undefined) {
      obj.curve_quote_amount = message.curve_quote_amount;
    }
    if (message.curve_camp_amount !== undefined) {
      obj.curve_camp_amount = message.curve_camp_amount;
    }
    if (message.trader !== undefined) {
      obj.trader = message.trader;
    }
    return obj;
  },

  create(base?: DeepPartial<SwapEvent>): SwapEvent {
    return SwapEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SwapEvent>): SwapEvent {
    const message = createBaseSwapEvent();
    message.contract_address = object.contract_address ?? "";
    message.camp_denom = object.camp_denom ?? "";
    message.action = object.action ?? "";
    message.input_coin = (object.input_coin !== undefined && object.input_coin !== null)
      ? Coin.fromPartial(object.input_coin)
      : undefined;
    message.output_coin = (object.output_coin !== undefined && object.output_coin !== null)
      ? Coin.fromPartial(object.output_coin)
      : undefined;
    message.price = object.price ?? "";
    message.curve_quote_amount = object.curve_quote_amount ?? "";
    message.curve_camp_amount = object.curve_camp_amount ?? "";
    message.trader = object.trader ?? "";
    return message;
  },
};

function createBaseProject(): Project {
  return {
    contract_address: "",
    camp_denom: "",
    name: "",
    symbol: "",
    logo: "",
    creator: "",
    graduation_threshold: "",
    graduation_dex: "",
    graduated: false,
    pool_seeded: false,
    pool_address: "",
    graduate_progress: 0,
    camp_amount: "",
    quote_denom: "",
    quote_amount: "",
    market_cap: "",
    updated_height: "0",
    metadata: "",
    metrics: undefined,
  };
}

export const Project = {
  $type: "flux.indexer.campclash.Project" as const,

  encode(message: Project, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contract_address !== "") {
      writer.uint32(10).string(message.contract_address);
    }
    if (message.camp_denom !== "") {
      writer.uint32(18).string(message.camp_denom);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(34).string(message.symbol);
    }
    if (message.logo !== "") {
      writer.uint32(42).string(message.logo);
    }
    if (message.creator !== "") {
      writer.uint32(50).string(message.creator);
    }
    if (message.graduation_threshold !== "") {
      writer.uint32(58).string(message.graduation_threshold);
    }
    if (message.graduation_dex !== "") {
      writer.uint32(66).string(message.graduation_dex);
    }
    if (message.graduated !== false) {
      writer.uint32(72).bool(message.graduated);
    }
    if (message.pool_seeded !== false) {
      writer.uint32(80).bool(message.pool_seeded);
    }
    if (message.pool_address !== "") {
      writer.uint32(90).string(message.pool_address);
    }
    if (message.graduate_progress !== 0) {
      writer.uint32(97).double(message.graduate_progress);
    }
    if (message.camp_amount !== "") {
      writer.uint32(106).string(message.camp_amount);
    }
    if (message.quote_denom !== "") {
      writer.uint32(114).string(message.quote_denom);
    }
    if (message.quote_amount !== "") {
      writer.uint32(122).string(message.quote_amount);
    }
    if (message.market_cap !== "") {
      writer.uint32(130).string(message.market_cap);
    }
    if (message.updated_height !== "0") {
      writer.uint32(136).uint64(message.updated_height);
    }
    if (message.metadata !== "") {
      writer.uint32(146).string(message.metadata);
    }
    if (message.metrics !== undefined) {
      Metrics.encode(message.metrics, writer.uint32(154).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Project {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contract_address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.camp_denom = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.logo = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.creator = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.graduation_threshold = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.graduation_dex = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.graduated = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.pool_seeded = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.pool_address = reader.string();
          continue;
        case 12:
          if (tag !== 97) {
            break;
          }

          message.graduate_progress = reader.double();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.camp_amount = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.quote_denom = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.quote_amount = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.market_cap = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.updated_height = longToString(reader.uint64() as Long);
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.metadata = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.metrics = Metrics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Project {
    return {
      contract_address: isSet(object.contract_address) ? globalThis.String(object.contract_address) : "",
      camp_denom: isSet(object.camp_denom) ? globalThis.String(object.camp_denom) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      graduation_threshold: isSet(object.graduation_threshold) ? globalThis.String(object.graduation_threshold) : "",
      graduation_dex: isSet(object.graduation_dex) ? globalThis.String(object.graduation_dex) : "",
      graduated: isSet(object.graduated) ? globalThis.Boolean(object.graduated) : false,
      pool_seeded: isSet(object.pool_seeded) ? globalThis.Boolean(object.pool_seeded) : false,
      pool_address: isSet(object.pool_address) ? globalThis.String(object.pool_address) : "",
      graduate_progress: isSet(object.graduate_progress) ? globalThis.Number(object.graduate_progress) : 0,
      camp_amount: isSet(object.camp_amount) ? globalThis.String(object.camp_amount) : "",
      quote_denom: isSet(object.quote_denom) ? globalThis.String(object.quote_denom) : "",
      quote_amount: isSet(object.quote_amount) ? globalThis.String(object.quote_amount) : "",
      market_cap: isSet(object.market_cap) ? globalThis.String(object.market_cap) : "",
      updated_height: isSet(object.updated_height) ? globalThis.String(object.updated_height) : "0",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      metrics: isSet(object.metrics) ? Metrics.fromJSON(object.metrics) : undefined,
    };
  },

  toJSON(message: Project): unknown {
    const obj: any = {};
    if (message.contract_address !== undefined) {
      obj.contract_address = message.contract_address;
    }
    if (message.camp_denom !== undefined) {
      obj.camp_denom = message.camp_denom;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.symbol !== undefined) {
      obj.symbol = message.symbol;
    }
    if (message.logo !== undefined) {
      obj.logo = message.logo;
    }
    if (message.creator !== undefined) {
      obj.creator = message.creator;
    }
    if (message.graduation_threshold !== undefined) {
      obj.graduation_threshold = message.graduation_threshold;
    }
    if (message.graduation_dex !== undefined) {
      obj.graduation_dex = message.graduation_dex;
    }
    if (message.graduated !== undefined) {
      obj.graduated = message.graduated;
    }
    if (message.pool_seeded !== undefined) {
      obj.pool_seeded = message.pool_seeded;
    }
    if (message.pool_address !== undefined) {
      obj.pool_address = message.pool_address;
    }
    if (message.graduate_progress !== undefined) {
      obj.graduate_progress = message.graduate_progress;
    }
    if (message.camp_amount !== undefined) {
      obj.camp_amount = message.camp_amount;
    }
    if (message.quote_denom !== undefined) {
      obj.quote_denom = message.quote_denom;
    }
    if (message.quote_amount !== undefined) {
      obj.quote_amount = message.quote_amount;
    }
    if (message.market_cap !== undefined) {
      obj.market_cap = message.market_cap;
    }
    if (message.updated_height !== undefined) {
      obj.updated_height = message.updated_height;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.metrics !== undefined) {
      obj.metrics = Metrics.toJSON(message.metrics);
    }
    return obj;
  },

  create(base?: DeepPartial<Project>): Project {
    return Project.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Project>): Project {
    const message = createBaseProject();
    message.contract_address = object.contract_address ?? "";
    message.camp_denom = object.camp_denom ?? "";
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.logo = object.logo ?? "";
    message.creator = object.creator ?? "";
    message.graduation_threshold = object.graduation_threshold ?? "";
    message.graduation_dex = object.graduation_dex ?? "";
    message.graduated = object.graduated ?? false;
    message.pool_seeded = object.pool_seeded ?? false;
    message.pool_address = object.pool_address ?? "";
    message.graduate_progress = object.graduate_progress ?? 0;
    message.camp_amount = object.camp_amount ?? "";
    message.quote_denom = object.quote_denom ?? "";
    message.quote_amount = object.quote_amount ?? "";
    message.market_cap = object.market_cap ?? "";
    message.updated_height = object.updated_height ?? "0";
    message.metadata = object.metadata ?? "";
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? Metrics.fromPartial(object.metrics)
      : undefined;
    return message;
  },
};

function createBaseMetrics(): Metrics {
  return {
    mind_share: "0",
    inferences: "0",
    holders: "0",
    impressions: "0",
    engagement: "0",
    followers: "0",
    smart_followers: "0",
    top_tweets: [],
  };
}

export const Metrics = {
  $type: "flux.indexer.campclash.Metrics" as const,

  encode(message: Metrics, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mind_share !== "0") {
      writer.uint32(8).int64(message.mind_share);
    }
    if (message.inferences !== "0") {
      writer.uint32(16).int64(message.inferences);
    }
    if (message.holders !== "0") {
      writer.uint32(24).int64(message.holders);
    }
    if (message.impressions !== "0") {
      writer.uint32(32).int64(message.impressions);
    }
    if (message.engagement !== "0") {
      writer.uint32(40).int64(message.engagement);
    }
    if (message.followers !== "0") {
      writer.uint32(48).int64(message.followers);
    }
    if (message.smart_followers !== "0") {
      writer.uint32(56).int64(message.smart_followers);
    }
    for (const v of message.top_tweets) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Metrics {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mind_share = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.inferences = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.holders = longToString(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.impressions = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.engagement = longToString(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.followers = longToString(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.smart_followers = longToString(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.top_tweets.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metrics {
    return {
      mind_share: isSet(object.mind_share) ? globalThis.String(object.mind_share) : "0",
      inferences: isSet(object.inferences) ? globalThis.String(object.inferences) : "0",
      holders: isSet(object.holders) ? globalThis.String(object.holders) : "0",
      impressions: isSet(object.impressions) ? globalThis.String(object.impressions) : "0",
      engagement: isSet(object.engagement) ? globalThis.String(object.engagement) : "0",
      followers: isSet(object.followers) ? globalThis.String(object.followers) : "0",
      smart_followers: isSet(object.smart_followers) ? globalThis.String(object.smart_followers) : "0",
      top_tweets: globalThis.Array.isArray(object?.top_tweets)
        ? object.top_tweets.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Metrics): unknown {
    const obj: any = {};
    if (message.mind_share !== undefined) {
      obj.mind_share = message.mind_share;
    }
    if (message.inferences !== undefined) {
      obj.inferences = message.inferences;
    }
    if (message.holders !== undefined) {
      obj.holders = message.holders;
    }
    if (message.impressions !== undefined) {
      obj.impressions = message.impressions;
    }
    if (message.engagement !== undefined) {
      obj.engagement = message.engagement;
    }
    if (message.followers !== undefined) {
      obj.followers = message.followers;
    }
    if (message.smart_followers !== undefined) {
      obj.smart_followers = message.smart_followers;
    }
    if (message.top_tweets?.length) {
      obj.top_tweets = message.top_tweets;
    }
    return obj;
  },

  create(base?: DeepPartial<Metrics>): Metrics {
    return Metrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Metrics>): Metrics {
    const message = createBaseMetrics();
    message.mind_share = object.mind_share ?? "0";
    message.inferences = object.inferences ?? "0";
    message.holders = object.holders ?? "0";
    message.impressions = object.impressions ?? "0";
    message.engagement = object.engagement ?? "0";
    message.followers = object.followers ?? "0";
    message.smart_followers = object.smart_followers ?? "0";
    message.top_tweets = object.top_tweets?.map((e) => e) || [];
    return message;
  },
};

function createBaseUser(): User {
  return { address: "", camp_denom: "", camp_amount: "", updated_height: "0" };
}

export const User = {
  $type: "flux.indexer.campclash.User" as const,

  encode(message: User, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.camp_denom !== "") {
      writer.uint32(18).string(message.camp_denom);
    }
    if (message.camp_amount !== "") {
      writer.uint32(26).string(message.camp_amount);
    }
    if (message.updated_height !== "0") {
      writer.uint32(32).uint64(message.updated_height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): User {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.camp_denom = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.camp_amount = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.updated_height = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      camp_denom: isSet(object.camp_denom) ? globalThis.String(object.camp_denom) : "",
      camp_amount: isSet(object.camp_amount) ? globalThis.String(object.camp_amount) : "",
      updated_height: isSet(object.updated_height) ? globalThis.String(object.updated_height) : "0",
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.camp_denom !== undefined) {
      obj.camp_denom = message.camp_denom;
    }
    if (message.camp_amount !== undefined) {
      obj.camp_amount = message.camp_amount;
    }
    if (message.updated_height !== undefined) {
      obj.updated_height = message.updated_height;
    }
    return obj;
  },

  create(base?: DeepPartial<User>): User {
    return User.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<User>): User {
    const message = createBaseUser();
    message.address = object.address ?? "";
    message.camp_denom = object.camp_denom ?? "";
    message.camp_amount = object.camp_amount ?? "";
    message.updated_height = object.updated_height ?? "0";
    return message;
  },
};

function createBaseAgent(): Agent {
  return { camp_denom: "", wallet: "" };
}

export const Agent = {
  $type: "flux.indexer.campclash.Agent" as const,

  encode(message: Agent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.camp_denom !== "") {
      writer.uint32(10).string(message.camp_denom);
    }
    if (message.wallet !== "") {
      writer.uint32(18).string(message.wallet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Agent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.camp_denom = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.wallet = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Agent {
    return {
      camp_denom: isSet(object.camp_denom) ? globalThis.String(object.camp_denom) : "",
      wallet: isSet(object.wallet) ? globalThis.String(object.wallet) : "",
    };
  },

  toJSON(message: Agent): unknown {
    const obj: any = {};
    if (message.camp_denom !== undefined) {
      obj.camp_denom = message.camp_denom;
    }
    if (message.wallet !== undefined) {
      obj.wallet = message.wallet;
    }
    return obj;
  },

  create(base?: DeepPartial<Agent>): Agent {
    return Agent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Agent>): Agent {
    const message = createBaseAgent();
    message.camp_denom = object.camp_denom ?? "";
    message.wallet = object.wallet ?? "";
    return message;
  },
};

function createBaseTrade(): Trade {
  return {
    address: "",
    contract_address: "",
    camp_denom: "",
    action: "",
    input_coin: undefined,
    output_coin: undefined,
    price: "",
    height: "0",
    timestamp: "0",
  };
}

export const Trade = {
  $type: "flux.indexer.campclash.Trade" as const,

  encode(message: Trade, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.contract_address !== "") {
      writer.uint32(18).string(message.contract_address);
    }
    if (message.camp_denom !== "") {
      writer.uint32(26).string(message.camp_denom);
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    if (message.input_coin !== undefined) {
      Coin.encode(message.input_coin, writer.uint32(42).fork()).ldelim();
    }
    if (message.output_coin !== undefined) {
      Coin.encode(message.output_coin, writer.uint32(50).fork()).ldelim();
    }
    if (message.price !== "") {
      writer.uint32(58).string(message.price);
    }
    if (message.height !== "0") {
      writer.uint32(64).uint64(message.height);
    }
    if (message.timestamp !== "0") {
      writer.uint32(72).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Trade {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contract_address = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.camp_denom = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.input_coin = Coin.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.output_coin = Coin.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.price = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.timestamp = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trade {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      contract_address: isSet(object.contract_address) ? globalThis.String(object.contract_address) : "",
      camp_denom: isSet(object.camp_denom) ? globalThis.String(object.camp_denom) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      input_coin: isSet(object.input_coin) ? Coin.fromJSON(object.input_coin) : undefined,
      output_coin: isSet(object.output_coin) ? Coin.fromJSON(object.output_coin) : undefined,
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0",
    };
  },

  toJSON(message: Trade): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.contract_address !== undefined) {
      obj.contract_address = message.contract_address;
    }
    if (message.camp_denom !== undefined) {
      obj.camp_denom = message.camp_denom;
    }
    if (message.action !== undefined) {
      obj.action = message.action;
    }
    if (message.input_coin !== undefined) {
      obj.input_coin = Coin.toJSON(message.input_coin);
    }
    if (message.output_coin !== undefined) {
      obj.output_coin = Coin.toJSON(message.output_coin);
    }
    if (message.price !== undefined) {
      obj.price = message.price;
    }
    if (message.height !== undefined) {
      obj.height = message.height;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<Trade>): Trade {
    return Trade.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Trade>): Trade {
    const message = createBaseTrade();
    message.address = object.address ?? "";
    message.contract_address = object.contract_address ?? "";
    message.camp_denom = object.camp_denom ?? "";
    message.action = object.action ?? "";
    message.input_coin = (object.input_coin !== undefined && object.input_coin !== null)
      ? Coin.fromPartial(object.input_coin)
      : undefined;
    message.output_coin = (object.output_coin !== undefined && object.output_coin !== null)
      ? Coin.fromPartial(object.output_coin)
      : undefined;
    message.price = object.price ?? "";
    message.height = object.height ?? "0";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
