// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: flux/indexer/campclash/events.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { Challenge, Project } from "./camp";

/** Enum for operations */
export enum CampEventOps {
  OpCreateCamp = 0,
  OpGraduateCamp = 1,
  OpUpdateCamp = 2,
  OpUpdateChallenge = 3,
  UNRECOGNIZED = -1,
}

export function campEventOpsFromJSON(object: any): CampEventOps {
  switch (object) {
    case 0:
    case "OpCreateCamp":
      return CampEventOps.OpCreateCamp;
    case 1:
    case "OpGraduateCamp":
      return CampEventOps.OpGraduateCamp;
    case 2:
    case "OpUpdateCamp":
      return CampEventOps.OpUpdateCamp;
    case 3:
    case "OpUpdateChallenge":
      return CampEventOps.OpUpdateChallenge;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CampEventOps.UNRECOGNIZED;
  }
}

export function campEventOpsToJSON(object: CampEventOps): string {
  switch (object) {
    case CampEventOps.OpCreateCamp:
      return "OpCreateCamp";
    case CampEventOps.OpGraduateCamp:
      return "OpGraduateCamp";
    case CampEventOps.OpUpdateCamp:
      return "OpUpdateCamp";
    case CampEventOps.OpUpdateChallenge:
      return "OpUpdateChallenge";
    case CampEventOps.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Define the ChallengeEventOp enum in camelCase */
export enum ChallengeEventOp {
  OpCreate = 0,
  OpUpdateStatus = 1,
  OpUpdateProgress = 2,
  OpFinalize = 3,
  UNRECOGNIZED = -1,
}

export function challengeEventOpFromJSON(object: any): ChallengeEventOp {
  switch (object) {
    case 0:
    case "OpCreate":
      return ChallengeEventOp.OpCreate;
    case 1:
    case "OpUpdateStatus":
      return ChallengeEventOp.OpUpdateStatus;
    case 2:
    case "OpUpdateProgress":
      return ChallengeEventOp.OpUpdateProgress;
    case 3:
    case "OpFinalize":
      return ChallengeEventOp.OpFinalize;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChallengeEventOp.UNRECOGNIZED;
  }
}

export function challengeEventOpToJSON(object: ChallengeEventOp): string {
  switch (object) {
    case ChallengeEventOp.OpCreate:
      return "OpCreate";
    case ChallengeEventOp.OpUpdateStatus:
      return "OpUpdateStatus";
    case ChallengeEventOp.OpUpdateProgress:
      return "OpUpdateProgress";
    case ChallengeEventOp.OpFinalize:
      return "OpFinalize";
    case ChallengeEventOp.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Event for camp-related operations */
export interface CampEvent {
  /** Contract address */
  contract_address: string;
  /** Enum for operation type */
  op: CampEventOps;
  /** Associated project */
  project: Project | undefined;
}

/** Event for swap operations */
export interface SwapEvent {
  /** Contract address */
  contract_address: string;
  camp_denom: string;
  /** Action type ("buy" or "sell") */
  action: string;
  /** Input coin */
  input_coin:
    | Coin
    | undefined;
  /** Output coin */
  output_coin:
    | Coin
    | undefined;
  /** Cast to math.Int */
  price: string;
  /** Cast to math.Int */
  curve_quote_amount: string;
  /** Cast to math.Int */
  curve_camp_amount: string;
  trader: string;
  output_locked: boolean;
  challenge_id: string;
}

/** Define the ChallengeEvent message */
export interface ChallengeEvent {
  /** Contract address */
  contract_address: string;
  op: ChallengeEventOp;
  challenge: Challenge | undefined;
}

/** Define the ChallengeClaimedEvent message */
export interface ChallengeClaimedEvent {
  /** Contract address */
  contract_address: string;
  challenge_id: string;
  address: string;
  coins: Coin[];
  unlocked_coins: Coin[];
}

export interface CampBalanceUpdate {
  address: string;
  amount: string;
  vote: string;
  challenge_id: string;
}

export interface CampBalanceEvent {
  /** Contract address */
  contract_address: string;
  denom: string;
  updates: CampBalanceUpdate[];
}

function createBaseCampEvent(): CampEvent {
  return { contract_address: "", op: 0, project: undefined };
}

export const CampEvent = {
  $type: "flux.indexer.campclash.CampEvent" as const,

  encode(message: CampEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contract_address !== "") {
      writer.uint32(10).string(message.contract_address);
    }
    if (message.op !== 0) {
      writer.uint32(16).int32(message.op);
    }
    if (message.project !== undefined) {
      Project.encode(message.project, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CampEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCampEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contract_address = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.op = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.project = Project.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CampEvent {
    return {
      contract_address: isSet(object.contract_address) ? globalThis.String(object.contract_address) : "",
      op: isSet(object.op) ? campEventOpsFromJSON(object.op) : 0,
      project: isSet(object.project) ? Project.fromJSON(object.project) : undefined,
    };
  },

  toJSON(message: CampEvent): unknown {
    const obj: any = {};
    if (message.contract_address !== undefined) {
      obj.contract_address = message.contract_address;
    }
    if (message.op !== undefined) {
      obj.op = campEventOpsToJSON(message.op);
    }
    if (message.project !== undefined) {
      obj.project = Project.toJSON(message.project);
    }
    return obj;
  },

  create(base?: DeepPartial<CampEvent>): CampEvent {
    return CampEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CampEvent>): CampEvent {
    const message = createBaseCampEvent();
    message.contract_address = object.contract_address ?? "";
    message.op = object.op ?? 0;
    message.project = (object.project !== undefined && object.project !== null)
      ? Project.fromPartial(object.project)
      : undefined;
    return message;
  },
};

function createBaseSwapEvent(): SwapEvent {
  return {
    contract_address: "",
    camp_denom: "",
    action: "",
    input_coin: undefined,
    output_coin: undefined,
    price: "",
    curve_quote_amount: "",
    curve_camp_amount: "",
    trader: "",
    output_locked: false,
    challenge_id: "0",
  };
}

export const SwapEvent = {
  $type: "flux.indexer.campclash.SwapEvent" as const,

  encode(message: SwapEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contract_address !== "") {
      writer.uint32(10).string(message.contract_address);
    }
    if (message.camp_denom !== "") {
      writer.uint32(18).string(message.camp_denom);
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    if (message.input_coin !== undefined) {
      Coin.encode(message.input_coin, writer.uint32(34).fork()).ldelim();
    }
    if (message.output_coin !== undefined) {
      Coin.encode(message.output_coin, writer.uint32(42).fork()).ldelim();
    }
    if (message.price !== "") {
      writer.uint32(50).string(message.price);
    }
    if (message.curve_quote_amount !== "") {
      writer.uint32(58).string(message.curve_quote_amount);
    }
    if (message.curve_camp_amount !== "") {
      writer.uint32(66).string(message.curve_camp_amount);
    }
    if (message.trader !== "") {
      writer.uint32(74).string(message.trader);
    }
    if (message.output_locked !== false) {
      writer.uint32(80).bool(message.output_locked);
    }
    if (message.challenge_id !== "0") {
      writer.uint32(88).uint64(message.challenge_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SwapEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contract_address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.camp_denom = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.input_coin = Coin.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.output_coin = Coin.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.price = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.curve_quote_amount = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.curve_camp_amount = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.trader = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.output_locked = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.challenge_id = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapEvent {
    return {
      contract_address: isSet(object.contract_address) ? globalThis.String(object.contract_address) : "",
      camp_denom: isSet(object.camp_denom) ? globalThis.String(object.camp_denom) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      input_coin: isSet(object.input_coin) ? Coin.fromJSON(object.input_coin) : undefined,
      output_coin: isSet(object.output_coin) ? Coin.fromJSON(object.output_coin) : undefined,
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      curve_quote_amount: isSet(object.curve_quote_amount) ? globalThis.String(object.curve_quote_amount) : "",
      curve_camp_amount: isSet(object.curve_camp_amount) ? globalThis.String(object.curve_camp_amount) : "",
      trader: isSet(object.trader) ? globalThis.String(object.trader) : "",
      output_locked: isSet(object.output_locked) ? globalThis.Boolean(object.output_locked) : false,
      challenge_id: isSet(object.challenge_id) ? globalThis.String(object.challenge_id) : "0",
    };
  },

  toJSON(message: SwapEvent): unknown {
    const obj: any = {};
    if (message.contract_address !== undefined) {
      obj.contract_address = message.contract_address;
    }
    if (message.camp_denom !== undefined) {
      obj.camp_denom = message.camp_denom;
    }
    if (message.action !== undefined) {
      obj.action = message.action;
    }
    if (message.input_coin !== undefined) {
      obj.input_coin = Coin.toJSON(message.input_coin);
    }
    if (message.output_coin !== undefined) {
      obj.output_coin = Coin.toJSON(message.output_coin);
    }
    if (message.price !== undefined) {
      obj.price = message.price;
    }
    if (message.curve_quote_amount !== undefined) {
      obj.curve_quote_amount = message.curve_quote_amount;
    }
    if (message.curve_camp_amount !== undefined) {
      obj.curve_camp_amount = message.curve_camp_amount;
    }
    if (message.trader !== undefined) {
      obj.trader = message.trader;
    }
    if (message.output_locked !== undefined) {
      obj.output_locked = message.output_locked;
    }
    if (message.challenge_id !== undefined) {
      obj.challenge_id = message.challenge_id;
    }
    return obj;
  },

  create(base?: DeepPartial<SwapEvent>): SwapEvent {
    return SwapEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SwapEvent>): SwapEvent {
    const message = createBaseSwapEvent();
    message.contract_address = object.contract_address ?? "";
    message.camp_denom = object.camp_denom ?? "";
    message.action = object.action ?? "";
    message.input_coin = (object.input_coin !== undefined && object.input_coin !== null)
      ? Coin.fromPartial(object.input_coin)
      : undefined;
    message.output_coin = (object.output_coin !== undefined && object.output_coin !== null)
      ? Coin.fromPartial(object.output_coin)
      : undefined;
    message.price = object.price ?? "";
    message.curve_quote_amount = object.curve_quote_amount ?? "";
    message.curve_camp_amount = object.curve_camp_amount ?? "";
    message.trader = object.trader ?? "";
    message.output_locked = object.output_locked ?? false;
    message.challenge_id = object.challenge_id ?? "0";
    return message;
  },
};

function createBaseChallengeEvent(): ChallengeEvent {
  return { contract_address: "", op: 0, challenge: undefined };
}

export const ChallengeEvent = {
  $type: "flux.indexer.campclash.ChallengeEvent" as const,

  encode(message: ChallengeEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contract_address !== "") {
      writer.uint32(10).string(message.contract_address);
    }
    if (message.op !== 0) {
      writer.uint32(16).int32(message.op);
    }
    if (message.challenge !== undefined) {
      Challenge.encode(message.challenge, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChallengeEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChallengeEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contract_address = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.op = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.challenge = Challenge.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChallengeEvent {
    return {
      contract_address: isSet(object.contract_address) ? globalThis.String(object.contract_address) : "",
      op: isSet(object.op) ? challengeEventOpFromJSON(object.op) : 0,
      challenge: isSet(object.challenge) ? Challenge.fromJSON(object.challenge) : undefined,
    };
  },

  toJSON(message: ChallengeEvent): unknown {
    const obj: any = {};
    if (message.contract_address !== undefined) {
      obj.contract_address = message.contract_address;
    }
    if (message.op !== undefined) {
      obj.op = challengeEventOpToJSON(message.op);
    }
    if (message.challenge !== undefined) {
      obj.challenge = Challenge.toJSON(message.challenge);
    }
    return obj;
  },

  create(base?: DeepPartial<ChallengeEvent>): ChallengeEvent {
    return ChallengeEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChallengeEvent>): ChallengeEvent {
    const message = createBaseChallengeEvent();
    message.contract_address = object.contract_address ?? "";
    message.op = object.op ?? 0;
    message.challenge = (object.challenge !== undefined && object.challenge !== null)
      ? Challenge.fromPartial(object.challenge)
      : undefined;
    return message;
  },
};

function createBaseChallengeClaimedEvent(): ChallengeClaimedEvent {
  return { contract_address: "", challenge_id: "0", address: "", coins: [], unlocked_coins: [] };
}

export const ChallengeClaimedEvent = {
  $type: "flux.indexer.campclash.ChallengeClaimedEvent" as const,

  encode(message: ChallengeClaimedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contract_address !== "") {
      writer.uint32(10).string(message.contract_address);
    }
    if (message.challenge_id !== "0") {
      writer.uint32(16).uint64(message.challenge_id);
    }
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    for (const v of message.coins) {
      Coin.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.unlocked_coins) {
      Coin.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChallengeClaimedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChallengeClaimedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contract_address = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.challenge_id = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.coins.push(Coin.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.unlocked_coins.push(Coin.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChallengeClaimedEvent {
    return {
      contract_address: isSet(object.contract_address) ? globalThis.String(object.contract_address) : "",
      challenge_id: isSet(object.challenge_id) ? globalThis.String(object.challenge_id) : "0",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      coins: globalThis.Array.isArray(object?.coins) ? object.coins.map((e: any) => Coin.fromJSON(e)) : [],
      unlocked_coins: globalThis.Array.isArray(object?.unlocked_coins)
        ? object.unlocked_coins.map((e: any) => Coin.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChallengeClaimedEvent): unknown {
    const obj: any = {};
    if (message.contract_address !== undefined) {
      obj.contract_address = message.contract_address;
    }
    if (message.challenge_id !== undefined) {
      obj.challenge_id = message.challenge_id;
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.coins?.length) {
      obj.coins = message.coins.map((e) => Coin.toJSON(e));
    }
    if (message.unlocked_coins?.length) {
      obj.unlocked_coins = message.unlocked_coins.map((e) => Coin.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChallengeClaimedEvent>): ChallengeClaimedEvent {
    return ChallengeClaimedEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChallengeClaimedEvent>): ChallengeClaimedEvent {
    const message = createBaseChallengeClaimedEvent();
    message.contract_address = object.contract_address ?? "";
    message.challenge_id = object.challenge_id ?? "0";
    message.address = object.address ?? "";
    message.coins = object.coins?.map((e) => Coin.fromPartial(e)) || [];
    message.unlocked_coins = object.unlocked_coins?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCampBalanceUpdate(): CampBalanceUpdate {
  return { address: "", amount: "", vote: "", challenge_id: "0" };
}

export const CampBalanceUpdate = {
  $type: "flux.indexer.campclash.CampBalanceUpdate" as const,

  encode(message: CampBalanceUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.vote !== "") {
      writer.uint32(26).string(message.vote);
    }
    if (message.challenge_id !== "0") {
      writer.uint32(32).uint64(message.challenge_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CampBalanceUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCampBalanceUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.vote = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.challenge_id = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CampBalanceUpdate {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      vote: isSet(object.vote) ? globalThis.String(object.vote) : "",
      challenge_id: isSet(object.challenge_id) ? globalThis.String(object.challenge_id) : "0",
    };
  },

  toJSON(message: CampBalanceUpdate): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.amount !== undefined) {
      obj.amount = message.amount;
    }
    if (message.vote !== undefined) {
      obj.vote = message.vote;
    }
    if (message.challenge_id !== undefined) {
      obj.challenge_id = message.challenge_id;
    }
    return obj;
  },

  create(base?: DeepPartial<CampBalanceUpdate>): CampBalanceUpdate {
    return CampBalanceUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CampBalanceUpdate>): CampBalanceUpdate {
    const message = createBaseCampBalanceUpdate();
    message.address = object.address ?? "";
    message.amount = object.amount ?? "";
    message.vote = object.vote ?? "";
    message.challenge_id = object.challenge_id ?? "0";
    return message;
  },
};

function createBaseCampBalanceEvent(): CampBalanceEvent {
  return { contract_address: "", denom: "", updates: [] };
}

export const CampBalanceEvent = {
  $type: "flux.indexer.campclash.CampBalanceEvent" as const,

  encode(message: CampBalanceEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contract_address !== "") {
      writer.uint32(10).string(message.contract_address);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    for (const v of message.updates) {
      CampBalanceUpdate.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CampBalanceEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCampBalanceEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contract_address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.denom = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updates.push(CampBalanceUpdate.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CampBalanceEvent {
    return {
      contract_address: isSet(object.contract_address) ? globalThis.String(object.contract_address) : "",
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      updates: globalThis.Array.isArray(object?.updates)
        ? object.updates.map((e: any) => CampBalanceUpdate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CampBalanceEvent): unknown {
    const obj: any = {};
    if (message.contract_address !== undefined) {
      obj.contract_address = message.contract_address;
    }
    if (message.denom !== undefined) {
      obj.denom = message.denom;
    }
    if (message.updates?.length) {
      obj.updates = message.updates.map((e) => CampBalanceUpdate.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CampBalanceEvent>): CampBalanceEvent {
    return CampBalanceEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CampBalanceEvent>): CampBalanceEvent {
    const message = createBaseCampBalanceEvent();
    message.contract_address = object.contract_address ?? "";
    message.denom = object.denom ?? "";
    message.updates = object.updates?.map((e) => CampBalanceUpdate.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
